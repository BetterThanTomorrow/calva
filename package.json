{
  "name": "calva",
  "displayName": "Calva: Clojure & ClojureScript Interactive Programming",
  "description": "Integrated REPL, formatter, Paredit, and more. Powered by cider-nrepl and clojure-lsp.",
  "icon": "assets/calva.png",
  "version": "2.0.263",
  "publisher": "betterthantomorrow",
  "author": {
    "name": "Better Than Tomorrow",
    "email": "pez@pezius.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/BetterThanTomorrow/calva.git"
  },
  "license": "MIT",
  "engines": {
    "node": ">=16",
    "vscode": "^1.66.0"
  },
  "categories": [
    "Programming Languages",
    "Testing",
    "Formatters",
    "Linters",
    "Debuggers",
    "Other"
  ],
  "keywords": [
    "Clojure",
    "ClojureScript",
    "Cider",
    "REPL",
    "Formatting",
    "Pretty",
    "EDN",
    "Interactive Programming",
    "bracket",
    "rainbow"
  ],
  "galleryBanner": {
    "color": "#EFEFEF",
    "theme": "light"
  },
  "badges": [
    {
      "url": "https://img.shields.io/badge/clojurians-calva--dev-blue.svg?logo=slack",
      "href": "https://clojurians.slack.com/messages/calva/",
      "description": "Let's talk in the #calva channel at the Clojurians Slack"
    }
  ],
  "activationEvents": [
    "onLanguage:clojure",
    "onCommand:calva.startStandaloneRepl",
    "onCommand:calva.startStandaloneHelloRepl",
    "onCommand:calva.startStandaloneCljsBrowserRepl",
    "onCommand:calva.startStandaloneCljsNodeRepl",
    "onCommand:calva.jackIn",
    "onCommand:calva.startOrConnectRepl",
    "onCommand:calva.connect",
    "onCommand:calva.connectNonProjectREPL",
    "workspaceContains:**/project.clj",
    "workspaceContains:**/shadow-cljs.edn",
    "workspaceContains:**/deps.edn",
    "onDebugResolve:type"
  ],
  "main": "./out/extension",
  "capabilities": {
    "untrustedWorkspaces": {
      "supported": false,
      "description": "With Calva you might evaluate any code in the project."
    }
  },
  "contributes": {
    "debuggers": [
      {
        "type": "clojure",
        "label": "Calva Debug",
        "program": "./out/debugAdapter.js",
        "runtime": "node"
      }
    ],
    "languages": [
      {
        "id": "clojure",
        "aliases": [
          "Clojure",
          "clojure"
        ],
        "extensions": [
          ".clj",
          ".cljs",
          ".cljc",
          ".cljd",
          ".cljx",
          ".clojure",
          ".edn",
          ".joke",
          ".boot",
          ".bb",
          ".calva-repl"
        ],
        "configuration": "./language-configuration.json"
      }
    ],
    "grammars": [
      {
        "language": "clojure",
        "scopeName": "source.clojure",
        "path": "./clojure.tmLanguage.json"
      }
    ],
    "configurationDefaults": {
      "[clojure]": {
        "editor.wordSeparators": "\t ()\"':,;~@#$%^&{}[]`",
        "editor.autoClosingBrackets": "always",
        "editor.autoClosingQuotes": "always",
        "editor.formatOnType": true,
        "editor.autoIndent": "full",
        "editor.formatOnPaste": true,
        "files.trimTrailingWhitespace": false,
        "editor.matchBrackets": "never",
        "editor.guides.indentation": false,
        "editor.parameterHints.enabled": false,
        "editor.unicodeHighlight.allowedCharacters": {
          " ": true,
          "꞉": true
        }
      }
    },
    "semanticTokenScopes": [
      {
        "language": "clojure",
        "scopes": {
          "macro": [
            "storage.control.clojure",
            "keyword.control.clojure"
          ]
        }
      }
    ],
    "configuration": [
      {
        "type": "object",
        "title": "Calva",
        "properties": {
          "calva.useLiveShare": {
            "type": "boolean",
            "markdownDescription": "Enable support for LiveShare. Currently defaults to false, because of [ive-share/issues/4551](https://github.com/MicrosoftDocs/live-share/issues/4551). This issue makes Calva fail to connect to a REPL for some users.",
            "default": false
          },
          "calva.useTestExplorer": {
            "type": "boolean",
            "description": "Enable experimental support for the VSCode Test Explorer",
            "default": false
          },
          "calva.enableClojureLspOnStart": {
            "type": "boolean",
            "markdownDescription": "**Recommended**: Start [clojure-lsp](https://calva.io/clojure-lsp/) automatically when Calva starts",
            "default": true
          },
          "calva.prettyPrintingOptions": {
            "type": "object",
            "description": "Settings for Calva's pretty printing",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Should evaluations be pretty printed?"
              },
              "printEngine": {
                "type": "string",
                "description": "The print engine to use. 'calva' means that the nREPL server will first plain print it and then Calva will prettify. The other options will make the server use the chosen printer-function to print the result, and Calva will not reformat it. To use some other function (on the server), configure `printFn` instead. To use the `nREPL` default (the equivalent of `clojure.core/pr`), set neither this nor `printFn`.",
                "enum": [
                  "calva",
                  "pprint",
                  "fipp",
                  "puget",
                  "zprint"
                ]
              },
              "printFn": {
                "type": "object",
                "markdownDescription": "A custom `nREPL` compatible `print-fn`. See https://nrepl.org/nrepl/usage/misc.html#pretty-printing",
                "properties": {
                  "name": {
                    "type": "string",
                    "markdownDescription": "A symbol referencing a Clojure function to use for printing result values. E.g. `pr`. Or `foo.bar/baz`."
                  },
                  "maxWidthArgument": {
                    "type": "string",
                    "markdownDescription": "Argument that the function uses for setting the max-width of the lines printed. E.g. `width`."
                  },
                  "seqLimitArgument": {
                    "type": "string",
                    "markdownDescription": "Argument that the function uses for truncating the number of elements to print  for sequences. E.g. `length`."
                  },
                  "maxDepthArgument": {
                    "type": "string",
                    "markdownDescription": "Argument that the function uses for limiting the depth that collections are traversed. E.g. `levels`."
                  }
                },
                "required": [
                  "name"
                ]
              },
              "width": {
                "type": "number",
                "description": "The width of the printing. Or line length... Hmmm, you get it, I hope."
              },
              "maxLength": {
                "type": [
                  "number",
                  "null"
                ],
                "description": "The maximum number of forms to print of each collection. For no limit, do not include this in your setting. See https://clojuredocs.org/clojure.core/*print-length*"
              },
              "maxDepth": {
                "type": [
                  "number",
                  "null"
                ],
                "description": "The maximum number of levels deep the printing will go in nested objects. For no limit, do not include this in your setting. Does not exist for `puget`. See also https://clojuredocs.org/clojure.core/*print-level*"
              }
            },
            "required": [
              "enabled"
            ],
            "default": {
              "printEngine": "pprint",
              "enabled": true,
              "width": 120,
              "maxLength": 50
            }
          },
          "clojure.trace.server": {
            "type": "string",
            "default": "off",
            "enum": [
              "off",
              "messages",
              "verbose"
            ],
            "description": "Trace communication between Calva and the Clojure language server, clojure-lsp. Trace messages are displayed in the Clojure Language Client output channel."
          },
          "calva.referencesCodeLens.enabled": {
            "type": "boolean",
            "default": false,
            "description": "Enable/disable references CodeLens in Clojure(Script) files. "
          },
          "clojure.format.enable": {
            "type": "boolean",
            "default": true,
            "description": "Enable/disable calva-fmt as Clojure formatter"
          },
          "calva.evalOnSave": {
            "type": "boolean",
            "default": false,
            "description": "Run load-file when opening a new file and on file save"
          },
          "calva.evaluationSendCodeToOutputWindow": {
            "type": "boolean",
            "default": false,
            "description": "Also send evaluated code to the REPL Window"
          },
          "calva.testOnSave": {
            "type": "boolean",
            "default": false,
            "description": "Run namespace tests on file save"
          },
          "calva.showDocstringInParameterHelp": {
            "type": "boolean",
            "default": false,
            "description": "Show the docstring in the parameter hints"
          },
          "calva.statusColor": {
            "type": "object",
            "description": "Configuration for custom coloring of the statusbar.",
            "properties": {
              "light": {
                "type": "object",
                "description": "Light theme colors",
                "properties": {
                  "disconnectedColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the disconnected status"
                  },
                  "launchingColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the launching status"
                  },
                  "connectedStatusColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the connected status"
                  },
                  "typeStatusColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the type status"
                  }
                }
              },
              "dark": {
                "type": "object",
                "description": "Dark theme colors",
                "properties": {
                  "disconnectedColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the disconnected status"
                  },
                  "launchingColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the launching status"
                  },
                  "connectedStatusColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the connected status"
                  },
                  "typeStatusColor": {
                    "type": "string",
                    "pattern": "#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})",
                    "description": "Foreground color for the type status"
                  }
                }
              }
            },
            "default": {
              "light": {
                "disconnectedColor": "#777777",
                "launchingColor": "#000000",
                "connectedStatusColor": "#DB9550",
                "typeStatusColor": "#91dc47"
              },
              "dark": {
                "disconnectedColor": "#aaaaaa",
                "launchingColor": "#ffffff",
                "connectedStatusColor": "#DB9550",
                "typeStatusColor": "#91dc47"
              }
            }
          },
          "calva.customCljsRepl": {
            "deprecationMessage": "This settings is deprecated. Use `cljsType` in a `calva.replConnectSequences` item instead."
          },
          "calva.jackIn.useDeprecatedAliasFlag": {
            "type": "boolean",
            "default": false,
            "markdownDescription": "Use the `-A` flag instead of `-M` for Clojure CLI versions < `1.10.697`."
          },
          "calva.jackInEnv": {
            "type": "object",
            "default": {},
            "description": "Specifies any environment variables your project needs. (Probably mostly for your Workspace Settings.)"
          },
          "calva.jackInDependencyVersions": {
            "type": "object",
            "description": "Versions of the dependencies injected by Calva Jack-in",
            "properties": {
              "nrepl": {
                "type": "string",
                "description": "nREPL is the wonderful piece of software that gives Calva a structured and extensible connection to the REPL in your Clojure and ClojureScript projects."
              },
              "cider-nrepl": {
                "type": "string",
                "description": "cider-nrepl is middleware that extends the nREPL connection with all sorts of nice stuff that Calva uses to give you a delightful IDE experience."
              },
              "cider/piggieback": {
                "type": "string",
                "description": "Piggieback is used to create nREPL sessions in ClojureScript projects (not with shadow-cljs though, which provides its own middleware for this."
              }
            },
            "default": {
              "nrepl": "0.9.0",
              "cider-nrepl": "0.27.4",
              "cider/piggieback": "0.5.3"
            }
          },
          "calva.clojureLspVersion": {
            "type": "string",
            "default": "latest",
            "markdownDescription": "The version of `clojure-lsp` to download and use. A release tag-name or `latest`. (Will take effect after a reload of the project window.) Remove this setting to switch back to using the current Calva default (`latest`)."
          },
          "calva.clojureLspPath": {
            "type": "string",
            "default": "",
            "markdownDescription": "The absolute path to the `clojure-lsp` native binary you want Calva to use. When this setting is non-blank, the `calva.clojureLspVersion` setting will be ignored. The binary at the path set here will be used and Calva will not overwrite it. (Will take effect after a reload of the project window.)"
          },
          "calva.openBrowserWhenFigwheelStarted": {
            "type": "boolean",
            "default": true,
            "description": "(lein-figwheel only) Should Calva open the Figwheel app for you when Figwheel has been started?"
          },
          "calva.customREPLCommandSnippets": {
            "type": "array",
            "default": [],
            "description": "Configuration for the command **Run Custom REPL Command**",
            "$schema": "http://json-schema.org/draft-06/schema#",
            "items": {
              "title": "replCommand",
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "markDownDescription": "The name of the command will show in the **Run Custom REPL Command** quick-pick menu."
                },
                "key": {
                  "type": "string",
                  "markdownDescription": "The key can be used to reference the snippet from **Run Custom REPL Command** keyboard shortcut arguments. This key will also be used in the quick-pick menu."
                },
                "snippet": {
                  "type": [
                    "string",
                    "array"
                  ],
                  "description": "Command to send to the REPL"
                },
                "ns": {
                  "type": "string",
                  "description": "(optional) Namespace to evaluate the command in. If omitted the command will be executed in the namespace of the current file."
                },
                "repl": {
                  "type": "string",
                  "description": "Choose which REPL should the code should be evaluated in. If omitted, the same REPL as for the current file will be used.",
                  "enum": [
                    "clj",
                    "cljs"
                  ]
                }
              },
              "required": [
                "name",
                "snippet"
              ]
            }
          },
          "calva.customREPLHoverSnippets": {
            "type": "array",
            "default": [],
            "description": "Configuration for snippets that get called on hover",
            "$schema": "http://json-schema.org/draft-06/schema#",
            "items": {
              "title": "replHover",
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "markDownDescription": "The name of the snippet will show inside the hover text."
                },
                "snippet": {
                  "type": [
                    "string",
                    "array"
                  ],
                  "description": "Snippet to send to the REPL"
                },
                "ns": {
                  "type": "string",
                  "description": "(optional) Namespace to evaluate the snippet in. If omitted the snippet will be executed in the namespace of the current file."
                },
                "repl": {
                  "type": "string",
                  "description": "Choose which REPL should the code should be evaluated in. If omitted, the same REPL as for the current file will be used.",
                  "enum": [
                    "clj",
                    "cljs"
                  ]
                }
              },
              "required": [
                "name",
                "snippet"
              ]
            }
          },
          "calva.myLeinProfiles": {
            "type": "array",
            "description": "At Jack in, any profiles listed here will be added to the profiles found in the `project.clj` file.",
            "items": {
              "type": "string"
            }
          },
          "calva.myCljAliases": {
            "type": "array",
            "description": "At Jack in, any aliases listed here will be added to the aliases found in the project's `deps.edn` file.",
            "items": {
              "type": "string"
            }
          },
          "calva.replConnectSequences": {
            "type": "array",
            "description": "For when your project needs a custom REPL connect sequence.",
            "items": {
              "type": "object",
              "required": [
                "name",
                "projectType",
                "cljsType"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "This will show up in the Jack-in quick-pick menu when you start Jack-in if you have more than one sequence configured."
                },
                "projectType": {
                  "type": "string",
                  "description": "Select one of the project types supported by Calva.",
                  "enum": [
                    "Leiningen",
                    "deps.edn",
                    "shadow-cljs",
                    "lein-shadow",
                    "generic"
                  ]
                },
                "nReplPortFile": {
                  "type": "array",
                  "description": "An array of path segments with the project root-relative path to the nREPL port file for this connect sequence. E.g. For shadow-cljs this would be [\".shadow-cljs\", \"nrepl.port\"]",
                  "items": {
                    "type": "string"
                  }
                },
                "afterCLJReplJackInCode": {
                  "type": "string",
                  "description": "Here you can give Calva some Clojure code to evaluate in the CLJ REPL, once it has been created.",
                  "required": false
                },
                "menuSelections": {
                  "type": "object",
                  "description": "Pre-selected menu options. If a selection is made here. Calva won't prompt for it.",
                  "properties": {
                    "leinProfiles": {
                      "type": "array",
                      "description": "At Jack-in to a Leiningen project, use these profiles to launch the repl.",
                      "items": {
                        "type": "string"
                      }
                    },
                    "leinAlias": {
                      "description": "At Jack-in to a Leiningen project, launch with this alias. Set to null to launch with Calva's default task (a headless repl).",
                      "anyOf": [
                        {
                          "type": "string"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "cljAliases": {
                      "type": "array",
                      "description": "At Jack-in to a deps.edn project, use these aliases to launch the repl.",
                      "items": {
                        "type": "string"
                      }
                    },
                    "cljsLaunchBuilds": {
                      "type": "array",
                      "description": "The cljs builds to start/watch at Jack-in/connect.",
                      "items": {
                        "type": "string"
                      }
                    },
                    "cljsDefaultBuild": {
                      "type": "string",
                      "description": "Which cljs build to attach to at the initial connect."
                    }
                  }
                },
                "cljsType": {
                  "description": "Either a built in type, or an object configuring a custom type. If omitted Calva will show a menu with the built-in types.",
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "Figwheel Main",
                        "lein-figwheel",
                        "shadow-cljs",
                        "ClojureScript built-in for browser",
                        "ClojureScript built-in for node",
                        "none"
                      ]
                    },
                    {
                      "type": "object",
                      "required": [
                        "connectCode",
                        "dependsOn"
                      ],
                      "properties": {
                        "dependsOn": {
                          "type": "string",
                          "enum": [
                            "Figwheel Main",
                            "lein-figwheel",
                            "shadow-cljs",
                            "ClojureScript built-in for browser",
                            "ClojureScript built-in for node",
                            "User provided"
                          ],
                          "description": "The ClojureScript REPL dependencies this customization needs. NB: If it is `User provided`, then you need to provide the dependencies in the project, or launch with an alias (deps.edn), profile (Leiningen), or build (shadow-cljs) that provides the dependencies needed."
                        },
                        "buildsRequired": {
                          "type": "boolean",
                          "description": "If the repl type requires that builds are started in order to connect to them, set this to true."
                        },
                        "isStarted": {
                          "type": "boolean",
                          "description": "For cljs repls that Calva does not need to start, set this to true. (If you base your custom cljs repl on shadow-cljs workflow, for instance.)"
                        },
                        "startCode": {
                          "type": "string",
                          "description": "Clojure code to be evaluated to create and/or start your custom CLJS REPL."
                        },
                        "isReadyToStartRegExp": {
                          "type": "string",
                          "description": "A regular expression which, when matched in the stdout from the startCode evaluation, will make Calva continue with connecting the REPL, and to prompt the user to start the application. If omitted and there is startCode Calva will continue when that code is evaluated."
                        },
                        "openUrlRegExp": {
                          "type": "string",
                          "description": "A regular expression, matched against the stdout of cljsType evaluations, for extracting the URL with which the app can be started. The expression should have a capturing group named 'url'. E.g. \\”Open URL: (?<url>\\S+)\\”",
                          "default": "Open(ing)? URL (?<url>\\S+)"
                        },
                        "shouldOpenUrl": {
                          "type": "boolean",
                          "description": "Choose if Calva should automatically open the URL for you or not."
                        },
                        "connectCode": {
                          "type": "string",
                          "description": "Clojure code to be evaluated to convert the REPL to a CLJS REPL that Calva can use to connect to the application."
                        },
                        "isConnectedRegExp": {
                          "type": "string",
                          "description": "A regular expression which, when matched in the stdout of the connectCode evaluation, will tell Calva that the application is connected.",
                          "default": "To quit, type: :cljs/quit"
                        },
                        "printThisLineRegExp": {
                          "type": "string",
                          "description": "A regular expression which, when matched in the stdout from any code evaluations in the cljsType, will make the matched text be printed to the Output/REPL window."
                        }
                      }
                    }
                  ]
                },
                "jackInEnv": {
                  "type": "object",
                  "default": {},
                  "markdownDescription": "Environment variables that will be merged with any global `calva.jackInEnv` and then applied to the Jack-in process. The merge is very similar to how Clojure's `merge` works. So for any common keys between the global setting and this one, the ones from this setting will win."
                }
              }
            }
          },
          "calva.projectRootsSearchExclude": {
            "type": "array",
            "markdownDescription": "Exclude these directories when searching for projects in the workspace during Jack-in/Connect. Each entry is a partial *glob* and will be part of a resulting *glob* of the form `**/{glob1,glob2,...,globN}`. This means that all directories in the workspace matching an entry will be excluded.",
            "items": {
              "type": "string"
            },
            "default": [
              "bower_components",
              ".bzr",
              ".cache",
              ".ccls-cache",
              ".clangd",
              ".classpath",
              ".clj-kondo",
              "*.code-search",
              ".cpcache",
              "_darcs",
              ".DS_Store",
              ".ensime_cache",
              ".eunit",
              "flow-typed",
              "_FOSSIL_",
              ".fslckout",
              ".git",
              ".hg",
              ".idea",
              ".lsp",
              "node_modules",
              ".pijul",
              ".project",
              ".shadow-cljs",
              ".stack-work",
              ".svn",
              "target",
              ".tox",
              ".vscode"
            ]
          },
          "calva.enableJSCompletions": {
            "type": "boolean",
            "description": "Should Calva use suitible and bring you JavaScript completions? This is an experimental cider-nrepl feature. Disable if completions start to throw errors.",
            "default": true
          },
          "calva.autoOpenREPLWindow": {
            "type": "boolean",
            "markdownDescription": "Automatically open the REPL window on Jack-in or Connect.",
            "default": true
          },
          "calva.autoOpenJackInTerminal": {
            "type": "boolean",
            "markdownDescription": "Automatically open the the Jack-in Terminal on Jack-in.",
            "default": true
          },
          "calva.keybindingsEnabled": {
            "type": "boolean",
            "description": "Activate keybindings.",
            "default": true,
            "scope": "window"
          },
          "calva.hideReplUi": {
            "type": "boolean",
            "markdownDescription": "Don't surface REPL UI elements when avoidable. (For when using another REPL extension together with Calva's static features.)",
            "default": false
          },
          "calva.showCalvaSaysOnStart": {
            "type": "boolean",
            "markdownDescription": "Show the Calva Says output panel on start?",
            "default": true
          }
        }
      },
      {
        "title": "Paredit",
        "type": "object",
        "properties": {
          "calva.paredit.defaultKeyMap": {
            "type": "string",
            "description": "The default keymap to use for bindings when there is no custom binding.",
            "default": "strict",
            "enum": [
              "original",
              "strict",
              "none"
            ],
            "scope": "window"
          },
          "calva.paredit.hijackVSCodeDefaults": {
            "type": "boolean",
            "markdownDescription": "When enabled, more VS Code built-in shortcuts are overridden with their ”corresponding” Paredit commands.",
            "default": true,
            "scope": "window"
          },
          "calva.paredit.strictPreventUnmatchedClosingBracket": {
            "type": "boolean",
            "markdownDescription": "Experimental: Prevents you from entering unmatched closing brackets when in `strict` mode. (Does not work when there is an active selection.)",
            "default": false,
            "scope": "window"
          },
          "calva.paredit.killAlsoCutsToClipboard": {
            "type": "boolean",
            "markdownDescription": "When enabled, replaces the clipboard content with the deleted code.",
            "default": false,
            "scope": "window"
          }
        }
      },
      {
        "title": "Calva-fmt",
        "type": "object",
        "properties": {
          "calva.fmt.configPath": {
            "type": "string",
            "markdownDescription": "Path to [cljfmt](https://github.com/weavejester/cljfmt#configuration) configuration file. Absolute or relative to the project root directory. To provide the config via [clojure-lsp](https://clojure-lsp.io), set this to `CLOJURE-LSP` (case sensitive)."
          },
          "calva.fmt.formatAsYouType": {
            "type": "boolean",
            "default": true,
            "description": "Auto-adjust indentation and format as you enter new lines."
          },
          "calva.fmt.newIndentEngine": {
            "type": "boolean",
            "default": true,
            "markdownDescription": "Use the structural editor for indentation (instead of `cljfmt`)."
          },
          "calva.fmt.keepCommentTrailParenOnOwnLine": {
            "type": "boolean",
            "default": true,
            "markdownDescription": "Treat `(comment...)` forms special and keep its closing paren on a line of its own."
          }
        }
      },
      {
        "type": "object",
        "title": "Calva Highlight",
        "properties": {
          "calva.highlight.enableBracketColors": {
            "type": "boolean",
            "default": true,
            "description": "Enable rainbow brackets",
            "scope": "resource"
          },
          "calva.highlight.rainbowIndentGuides": {
            "type": "boolean",
            "default": false,
            "markdownDescription": "Use rainbow indent guides. (To use built-in indent guides, disable this and enable built-in guides in `[\"clojure\"]` scope.",
            "scope": "resource"
          },
          "calva.highlight.highlightActiveIndent": {
            "type": "boolean",
            "default": true,
            "description": "Highlight active indent with a guideline. (Unlike the VS Code built-in setting, this works independently of the rainbowIndentGuides setting.)",
            "scope": "resource"
          },
          "calva.highlight.bracketColors": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "type": "string",
                  "markdownDescription": "CSS color, e.g. `\"#ccc\"`, or `\"#91dc47\"`"
                },
                {
                  "items": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "markdownDescription": "Tuple of CSS colors, `[light, dark]`, e.g. `[\"#ccc\", \"#000\"]`"
                }
              ]
            },
            "default": [
              [
                "#000",
                "#ccc"
              ],
              "#0098e6",
              "#e16d6d",
              "#3fa455",
              "#c968e6",
              "#999",
              "#ce7e00"
            ],
            "markdownDescription": "An array where each element can be either a CSS color string, or a tuple of two CSS color strings. Use tuples when you want a different color for light and dark themes, `[light, dark]`, e.g. `[\"#ccc\", \"#000\"]`",
            "scope": "resource"
          },
          "calva.highlight.cycleBracketColors": {
            "type": "boolean",
            "default": true,
            "description": "If nesting level is greater than amount of colors, start counting over",
            "scope": "resource"
          },
          "calva.highlight.misplacedBracketStyle": {
            "type": "object",
            "default": null,
            "description": "Style of misplaced bracket",
            "scope": "resource"
          },
          "calva.highlight.matchedBracketStyle": {
            "type": "object",
            "default": null,
            "description": "Style of pair bracket highlight",
            "scope": "resource"
          },
          "calva.highlight.commentFormStyle": {
            "type": "object",
            "default": null,
            "description": "Style of `(comment)` forms",
            "scope": "resource"
          },
          "calva.highlight.ignoredFormStyle": {
            "type": "object",
            "default": null,
            "description": "Style of `#_` ignored forms",
            "scope": "resource"
          }
        }
      }
    ],
    "commands": [
      {
        "command": "calva.clojureLsp.showClojureLspStartedMenu",
        "title": "Show clojure-lsp menu",
        "enablement": "clojureLsp:active",
        "category": "Calva Clojure LSP"
      },
      {
        "command": "calva.clojureLsp.showClojureLspStoppedMenu",
        "title": "Show clojure-lsp menu",
        "enablement": "!clojureLsp:active",
        "category": "Calva Clojure LSP"
      },
      {
        "command": "calva.clojureLsp.download",
        "title": "Download the configured Clojure LSP Server version",
        "enablement": "!clojureLsp:active",
        "category": "Calva Clojure LSP"
      },
      {
        "command": "calva.clojureLsp.start",
        "title": "Start the Clojure LSP Server",
        "enablement": "!clojureLsp:active",
        "category": "Calva Clojure LSP"
      },
      {
        "command": "calva.clojureLsp.stop",
        "title": "Stop the Clojure LSP Server",
        "enablement": "clojureLsp:active",
        "category": "Calva Clojure LSP"
      },
      {
        "command": "calva.diagnostics.openClojureLspLogFile",
        "title": "Open Clojure LSP Log File",
        "category": "Calva Diagnostics"
      },
      {
        "command": "calva.diagnostics.toggleNreplLoggingEnabled",
        "title": "Toggle nREPL Logging Enabled",
        "category": "Calva Diagnostics"
      },
      {
        "command": "calva.linting.resolveMacroAs",
        "title": "Resolve Macro As",
        "category": "Calva Linting",
        "enablement": "editorLangId == clojure && workspaceFolderCount > 0"
      },
      {
        "command": "calva.copyJackInCommandToClipboard",
        "title": "Copy Jack-In Command to Clipboard",
        "category": "Calva",
        "enablement": "workspaceFolderCount > 0"
      },
      {
        "command": "calva.openCalvaDocs",
        "title": "Open Documentation (calva.io)",
        "category": "Calva"
      },
      {
        "command": "calva.debug.instrument",
        "title": "Instrument Top Level Form for Debugging",
        "category": "Calva Debug",
        "enablement": "editorLangId == clojure && calva:connected"
      },
      {
        "command": "calva.togglePrettyPrint",
        "title": "Toggle Pretty Printing for All Evaluations",
        "category": "Calva",
        "enablement": "calva:connected"
      },
      {
        "command": "calva.toggleEvaluationSendCodeToOutputWindow",
        "title": "Toggle also sending evaluated code to the REPL Window",
        "category": "Calva",
        "enablement": "calva:connected"
      },
      {
        "command": "calva.jackIn",
        "title": "Start a Project REPL and Connect (aka Jack-In)",
        "category": "Calva",
        "enablement": "workspaceFolderCount > 0"
      },
      {
        "command": "calva.connect",
        "title": "Connect to a Running REPL Server in the Project",
        "category": "Calva",
        "enablement": "workspaceFolderCount > 0"
      },
      {
        "command": "calva.connectNonProjectREPL",
        "title": "Connect to a Running REPL Server, not in Project",
        "category": "Calva"
      },
      {
        "command": "calva.disconnect",
        "title": "Disconnect from the REPL Server",
        "enablement": "calva:connected || calva:connecting || calva:launching",
        "category": "Calva"
      },
      {
        "command": "calva.startOrConnectRepl",
        "title": "Start or Connect to a Clojure REPL",
        "category": "Calva"
      },
      {
        "command": "calva.startStandaloneRepl",
        "title": "Start a standalone REPL (not in a project)",
        "category": "Calva"
      },
      {
        "command": "calva.startStandaloneHelloRepl",
        "title": "Fire up the Getting Started REPL",
        "category": "Calva"
      },
      {
        "command": "calva.startStandaloneCljsBrowserRepl",
        "title": "Fire up the ClojureScript Quick Start Browser REPL",
        "category": "Calva"
      },
      {
        "command": "calva.startStandaloneCljsNodeRepl",
        "title": "Fire up the ClojureScript Quick Start Node REPL",
        "category": "Calva"
      },
      {
        "command": "calva.toggleCLJCSession",
        "title": "Toggle the REPL Connection (clj or cljs) used for CLJC Files",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.selectCurrentForm",
        "title": "Select Current Form",
        "category": "Calva",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva.clearInlineResults",
        "title": "Clear Inline Evaluation Results",
        "category": "Calva",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva.interruptAllEvaluations",
        "title": "Interrupt Running Evaluations",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateSelection",
        "title": "Evaluate Current Form  (or selection, if any)",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateEnclosingForm",
        "title": "Evaluate Current Enclosing Form",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateToCursor",
        "title": "Evaluate From Start of List to Cursor",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateTopLevelFormToCursor",
        "title": "Evaluate From Start of Top Level Form to Cursor",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateStartOfFileToCursor",
        "title": "Evaluate From Start of File to Cursor",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.tapSelection",
        "title": "Tap Current Form (or selection, if any)",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateCurrentTopLevelForm",
        "title": "Evaluate Top Level Form (defun)",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.tapCurrentTopLevelForm",
        "title": "Tap Current Top Level Form",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateSelectionReplace",
        "title": "Evaluate Current Form and Replace it with the Result",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateSelectionAsComment",
        "title": "Evaluate Current Form to Comment",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.evaluateTopLevelFormAsComment",
        "title": "Evaluate Top Level Form (defun) to Comment",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.printLastStacktrace",
        "title": "Print Last Stacktrace to Output Window",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.copyLastResults",
        "title": "Copy Last Evaluation Result to Clipboard",
        "category": "Calva",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva.loadFile",
        "title": "Load Current File and Dependencies",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.requireREPLUtilities",
        "title": "Require REPL utilities, like (doc) etcetera, into Current Namespace",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.runNamespaceTests",
        "title": "Run Tests for Current Namespace",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.runAllTests",
        "title": "Run All Tests",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.rerunTests",
        "title": "Run Failing Tests Again",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.runTestUnderCursor",
        "title": "Run Current Test",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "title": "Run Custom REPL Command",
        "category": "Calva",
        "enablement": "calva:connected && editorLangId == clojure"
      },
      {
        "command": "calva.continueComment",
        "title": "Continue Comment (add a commented line below).",
        "category": "Calva"
      },
      {
        "command": "calva.switchCljsBuild",
        "title": "Select CLJS Build Connection",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.refresh",
        "title": "Refresh Changed Namespaces",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.refreshAll",
        "title": "Refresh All Namespaces",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "category": "Calva",
        "command": "calva.toggleKeybindingsEnabled",
        "title": "Toggle Keybindings Enabled"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.togglemode",
        "title": "Toggle Paredit Mode",
        "when": "editorLangId == clojure && paredit:keyMap =~ /original|strict/",
        "enablement": "editorLangId == clojure && paredit:keyMap =~ /original|strict/"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.forwardSexp",
        "title": "Forward Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.backwardSexp",
        "title": "Backward Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.forwardSexpOrUp",
        "title": "Forward Sexp Or Up",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.backwardSexpOrUp",
        "title": "Backward Sexp Or Up",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.forwardDownSexp",
        "title": "Forward Down Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.backwardDownSexp",
        "title": "Backward Down Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.backwardUpSexp",
        "title": "Backward Up Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.forwardUpSexp",
        "title": "Forward Up Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.closeList",
        "title": "Forward to List End/Close",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectForwardSexp",
        "title": "Select Forward Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectRight",
        "title": "Select Right",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectBackwardSexp",
        "title": "Select Backward Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectForwardDownSexp",
        "title": "Select Forward Down Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectBackwardDownSexp",
        "title": "Select Backward Down Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectBackwardUpSexp",
        "title": "Select Backward Up Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectForwardUpSexp",
        "title": "Select Forward Up Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectBackwardSexpOrUp",
        "title": "Select Backward Sexp Or Up",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectForwardSexpOrUp",
        "title": "Select Forward Sexp Or Up",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectCloseList",
        "title": "Select Forward to List End/Close",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.selectOpenList",
        "title": "Select Backward to List Start/Open",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.rangeForDefun",
        "title": "Select Current Top Level (aka defun) Form",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.sexpRangeExpansion",
        "title": "Expand Selection",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.sexpRangeContraction",
        "title": "Shrink Selection",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.slurpSexpForward",
        "title": "Slurp Sexp Forward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.slurpSexpBackward",
        "title": "Slurp Sexp Backward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.barfSexpForward",
        "title": "Barf Sexp Forward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.barfSexpBackward",
        "title": "Barf Sexp Backward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.spliceSexp",
        "title": "Splice Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.splitSexp",
        "title": "Split Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.joinSexp",
        "title": "Join Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.raiseSexp",
        "title": "Raise Sexp",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.transpose",
        "title": "Transpose (Swap) the two Sexps Around the Cursor",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.dragSexprBackward",
        "title": "Drag Sexp Backward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.dragSexprForward",
        "title": "Drag Sexp Forward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.dragSexprBackwardUp",
        "title": "Drag Sexp Backward Up",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.dragSexprForwardDown",
        "title": "Drag Sexp Forward Down",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.dragSexprForwardUp",
        "title": "Drag Sexp Forward Up",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.dragSexprBackwardDown",
        "title": "Drag Sexp Backward Down",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.convolute",
        "title": "Convolute Sexp ¯\\_(ツ)_/¯",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.killRight",
        "title": "Kill/Delete Right",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.killSexpForward",
        "title": "Kill/Delete Sexp Forward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.killSexpBackward",
        "title": "Kill/Delete Sexp Backward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.killListForward",
        "title": "Kill/Delete Forward to End of List",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.killListBackward",
        "title": "Kill/Delete Backward to Start of List",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.spliceSexpKillForward",
        "title": "Splice & Kill/Delete Forward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.spliceSexpKillBackward",
        "title": "Splice & Kill/Delete Backward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.deleteForward",
        "title": "Delete Forward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.deleteBackward",
        "title": "Delete Backward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.forceDeleteForward",
        "title": "Force Delete Forward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.forceDeleteBackward",
        "title": "Force Delete Backward",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.wrapAroundParens",
        "title": "Wrap Around ()",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.wrapAroundSquare",
        "title": "Wrap Around []",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.wrapAroundCurly",
        "title": "Wrap Around {}",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.wrapAroundQuote",
        "title": "Wrap Around \"\"",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.rewrapParens",
        "title": "Rewrap ()",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.rewrapSquare",
        "title": "Rewrap []",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.rewrapCurly",
        "title": "Rewrap {}",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva Paredit",
        "command": "paredit.rewrapQuote",
        "title": "Rewrap \"\"",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva-fmt.formatCurrentForm",
        "title": "Format Current Form",
        "category": "Calva Format",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva-fmt.alignCurrentForm",
        "title": "Format and Align Current Form (recursively, experimental)",
        "category": "Calva Format",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva-fmt.inferParens",
        "title": "Infer Parens (from the indentation)",
        "category": "Calva Format",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva-fmt.tabIndent",
        "title": "Indent Line",
        "category": "Calva Format",
        "enablement": "editorLangId == clojure"
      },
      {
        "command": "calva-fmt.tabDedent",
        "title": "Dedent Line",
        "category": "Calva Format",
        "enablement": "editorLangId == clojure"
      },
      {
        "category": "Calva",
        "command": "calva.showOutputWindow",
        "title": "Show Output/REPL Window",
        "enablement": "calva:connected"
      },
      {
        "category": "Calva",
        "command": "calva.showFileForOutputWindowNS",
        "title": "Show File for the Current Output/REPL Window Namespace",
        "enablement": "calva:connected"
      },
      {
        "command": "calva.setOutputWindowNamespace",
        "title": "Switch Namespace in Output/REPL Window to Current Namespace",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.sendCurrentFormToOutputWindow",
        "title": "Send Current Form to Output/REPL Window",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.sendCurrentTopLevelFormToOutputWindow",
        "title": "Send Current Top Level Form to Output/REPL Window",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.showPreviousReplHistoryEntry",
        "title": "Show Previous REPL History Entry",
        "enablement": "calva:connected && calva:outputWindowActive && calva:replHistoryCommandsActive",
        "category": "Calva"
      },
      {
        "command": "calva.showNextReplHistoryEntry",
        "title": "Show Next REPL History Entry",
        "enablement": "calva:connected && calva:outputWindowActive && calva:replHistoryCommandsActive",
        "category": "Calva"
      },
      {
        "command": "calva.clearReplHistory",
        "title": "Clear REPL History",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.printClojureDocsToOutputWindow",
        "title": "Print clojuredocs.org examples to OutputWindow",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.printClojureDocsToRichComment",
        "title": "Print clojuredocs.org examples to Rich Comment",
        "enablement": "calva:connected",
        "category": "Calva"
      },
      {
        "command": "calva.refactor.cleanNs",
        "title": "Clean NS Form",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.addMissingLibspec",
        "title": "Add Missing Require",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.cyclePrivacy",
        "title": "Cycle/Toggle Privacy",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.expandLet",
        "title": "Expand Let",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.inlineSymbol",
        "title": "Inline Symbol",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.threadFirst",
        "title": "Thread First",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.threadFirstAll",
        "title": "Thread First All",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.threadLast",
        "title": "Thread Last",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.threadLastAll",
        "title": "Thread Last All",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.unwindAll",
        "title": "Unwind All",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.unwindThread",
        "title": "Unwind Thread",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.introduceLet",
        "title": "Introduce let",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.moveToLet",
        "title": "Move to Previous let Box",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.refactor.extractFunction",
        "title": "Extract to New Function",
        "category": "Calva Refactor",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "command": "calva.diagnostics.clojureLspServerInfo",
        "title": "Clojure-lsp Server Info",
        "category": "Calva Diagnostics",
        "enablement": "editorLangId == clojure && clojureLsp:active"
      },
      {
        "category": "Calva",
        "command": "calva.toggleBetweenImplAndTest",
        "title": "Toggle between implementation and test"
      },
      {
        "category": "Calva",
        "command": "paredit.addRichComment",
        "title": "Add Rich Comment",
        "enablement": "editorLangId == clojure"
      }
    ],
    "keybindings": [
      {
        "command": "calva.debug.instrument",
        "key": "ctrl+alt+c i",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected"
      },
      {
        "command": "calva.jackIn",
        "key": "ctrl+alt+c ctrl+alt+j",
        "when": "calva:keybindingsEnabled"
      },
      {
        "command": "calva.connect",
        "key": "ctrl+alt+c ctrl+alt+c",
        "when": "calva:keybindingsEnabled"
      },
      {
        "command": "calva.startOrConnectRepl",
        "key": "ctrl+alt+c ctrl+alt+r"
      },
      {
        "command": "calva.connectNonProjectREPL",
        "key": "ctrl+alt+c alt+c",
        "when": "calva:keybindingsEnabled"
      },
      {
        "command": "calva.toggleCLJCSession",
        "key": "ctrl+alt+c ctrl+alt+s",
        "when": "calva:keybindingsEnabled"
      },
      {
        "command": "calva.switchCljsBuild",
        "key": "ctrl+alt+c ctrl+alt+b",
        "when": "calva:keybindingsEnabled"
      },
      {
        "command": "calva.selectCurrentForm",
        "key": "ctrl+alt+c ctrl+s",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.clearInlineResults",
        "key": "escape",
        "when": "calva:keybindingsEnabled && editorTextFocus && !editorHasMultipleSelections && !editorHasSelection && !editorReadOnly && !hasOtherSuggestions && !parameterHintsVisible && !selectionAnchorSet && !suggestWidgetVisible && editorLangId == clojure"
      },
      {
        "command": "calva.evaluateSelection",
        "key": "ctrl+enter",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !suggestWidgetVisible"
      },
      {
        "command": "calva.evaluateEnclosingForm",
        "key": "ctrl+shift+enter",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.evaluateToCursor",
        "key": "ctrl+alt+enter",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.evaluateTopLevelFormToCursor",
        "key": "shift+alt+enter",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.evaluateStartOfFileToCursor",
        "key": "ctrl+shift+alt+enter",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.tapSelection",
        "key": "ctrl+shift+t t",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.tapCurrentTopLevelForm",
        "key": "ctrl+shift+t space",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.interruptAllEvaluations",
        "key": "ctrl+alt+c ctrl+alt+d",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.evaluateCurrentTopLevelForm",
        "key": "alt+enter",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.evaluateOutputWindowForm",
        "key": "enter",
        "when": "calva:keybindingsEnabled && calva:outputWindowActive && calva:outputWindowSubmitOnEnter && editorTextFocus"
      },
      {
        "command": "calva.evaluateSelectionReplace",
        "key": "ctrl+alt+c r",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.evaluateSelectionAsComment",
        "key": "ctrl+alt+c c",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.evaluateTopLevelFormAsComment",
        "key": "ctrl+alt+c ctrl+space",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.printLastStacktrace",
        "key": "ctrl+alt+c ctrl+alt+p",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus"
      },
      {
        "command": "calva.copyLastResults",
        "key": "ctrl+alt+c ctrl+c",
        "when": "calva:connected && calva:keybindingsEnabled && editorLangId == clojure"
      },
      {
        "command": "calva.loadFile",
        "key": "ctrl+alt+c enter",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.togglePrettyPrint",
        "key": "ctrl+alt+c p",
        "when": "editorLangId == clojure && calva:keybindingsEnabled"
      },
      {
        "command": "calva.toggleEvaluationSendCodeToOutputWindow",
        "key": "ctrl+alt+o s",
        "when": "editorLangId == clojure && calva:keybindingsEnabled"
      },
      {
        "command": "calva.requireREPLUtilities",
        "key": "ctrl+alt+c ctrl+u",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runNamespaceTests",
        "key": "ctrl+alt+c t",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runAllTests",
        "key": "ctrl+alt+c shift+t",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.rerunTests",
        "key": "ctrl+alt+c ctrl+t",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runTestUnderCursor",
        "key": "ctrl+alt+c ctrl+alt+t",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "paredit.togglemode",
        "key": "ctrl+alt+p ctrl+alt+m",
        "when": "editorLangId == clojure calva:keybindingsEnabled && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.backwardSexp",
        "mac": "ctrl+left",
        "win": "alt+left",
        "linux": "alt+left",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && !config.calva.paredit.hijackVSCodeDefaults && !calva:cursorInComment || calva:cursorBeforeComment"
      },
      {
        "command": "paredit.backwardSexp",
        "mac": "alt+left",
        "win": "ctrl+left",
        "linux": "ctrl+left",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && config.calva.paredit.hijackVSCodeDefaults && !calva:cursorInComment || calva:cursorBeforeComment"
      },
      {
        "command": "paredit.forwardSexp",
        "mac": "ctrl+right",
        "win": "alt+right",
        "linux": "alt+right",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && !config.calva.paredit.hijackVSCodeDefaults && !calva:cursorInComment || calva:cursorAfterComment"
      },
      {
        "command": "paredit.forwardSexp",
        "mac": "alt+right",
        "win": "ctrl+right",
        "linux": "ctrl+right",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && config.calva.paredit.hijackVSCodeDefaults && !calva:cursorInComment || calva:cursorAfterComment"
      },
      {
        "command": "paredit.forwardDownSexp",
        "key": "ctrl+down",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.backwardDownSexp",
        "key": "ctrl+alt+up",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.forwardUpSexp",
        "key": "ctrl+alt+down",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.backwardUpSexp",
        "key": "ctrl+up",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.closeList",
        "key": "ctrl+end",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.openList",
        "key": "ctrl+home",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectForwardSexp",
        "mac": "shift+alt+right",
        "win": "shift+ctrl+right",
        "linux": "shift+ctrl+right",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectRight",
        "mac": "ctrl+shift+k",
        "win": "ctrl+k ctrl+shift+k",
        "linux": "ctrl+k ctrl+shift+k",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !selectionAnchorSet && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectBackwardSexp",
        "mac": "shift+alt+left",
        "win": "shift+ctrl+left",
        "linux": "shift+ctrl+left",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectForwardDownSexp",
        "key": "ctrl+shift+down",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectBackwardDownSexp",
        "key": "ctrl+shift+alt+up",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectForwardUpSexp",
        "key": "ctrl+shift+alt+down",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectBackwardUpSexp",
        "key": "ctrl+shift+up",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectCloseList",
        "key": "ctrl+shift+end",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.selectOpenList",
        "key": "ctrl+shift+home",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.rangeForDefun",
        "key": "ctrl+alt+w space",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.sexpRangeExpansion",
        "mac": "ctrl+w",
        "win": "shift+alt+right",
        "linux": "shift+alt+right",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && !calva:cursorInComment"
      },
      {
        "command": "paredit.sexpRangeContraction",
        "mac": "ctrl+shift+w",
        "win": "shift+alt+left",
        "linux": "shift+alt+left",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && !calva:cursorInComment"
      },
      {
        "command": "paredit.slurpSexpForward",
        "key": "ctrl+alt+right",
        "linux": "ctrl+alt+.",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.slurpSexpBackward",
        "key": "ctrl+alt+shift+left",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.barfSexpForward",
        "key": "ctrl+alt+left",
        "linux": "ctrl+alt+,",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.barfSexpBackward",
        "key": "ctrl+alt+shift+right",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.spliceSexp",
        "key": "ctrl+alt+s",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.splitSexp",
        "key": "ctrl+shift+s",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.joinSexp",
        "key": "ctrl+shift+j",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.raiseSexp",
        "key": "ctrl+alt+p ctrl+alt+r",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.transpose",
        "key": "ctrl+alt+t",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.dragSexprBackward",
        "key": "ctrl+shift+alt+b",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && !calva:cursorInComment"
      },
      {
        "command": "paredit.dragSexprForward",
        "key": "ctrl+shift+alt+f",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/ && !calva:cursorInComment"
      },
      {
        "command": "paredit.dragSexprBackward",
        "key": "alt+up",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /strict/ && config.calva.paredit.hijackVSCodeDefaults && !calva:cursorInComment"
      },
      {
        "command": "paredit.dragSexprForward",
        "key": "alt+down",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /strict/ && config.calva.paredit.hijackVSCodeDefaults && !calva:cursorInComment"
      },
      {
        "command": "paredit.dragSexprBackwardUp",
        "key": "ctrl+shift+alt+u",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.dragSexprForwardDown",
        "key": "ctrl+shift+alt+d",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.dragSexprForwardUp",
        "key": "ctrl+shift+alt+k",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.dragSexprBackwardDown",
        "key": "ctrl+shift+alt+j",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.convolute",
        "key": "ctrl+shift+c",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.killRight",
        "mac": "ctrl+k",
        "win": "ctrl+k ctrl+k",
        "linux": "ctrl+k ctrl+k",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !selectionAnchorSet && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.killSexpForward",
        "key": "ctrl+shift+delete",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.killSexpBackward",
        "key": "ctrl+alt+backspace",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.killListForward",
        "key": "ctrl+delete",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.killListBackward",
        "key": "ctrl+backspace",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.spliceSexpKillForward",
        "key": "ctrl+alt+shift+delete",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.spliceSexpKillBackward",
        "key": "ctrl+alt+shift+backspace",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.wrapAroundParens",
        "key": "ctrl+alt+shift+p",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.wrapAroundSquare",
        "key": "ctrl+alt+shift+s",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.wrapAroundCurly",
        "key": "ctrl+alt+shift+c",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.wrapAroundQuote",
        "key": "ctrl+alt+shift+q",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.rewrapParens",
        "key": "ctrl+alt+r ctrl+alt+p",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.rewrapSquare",
        "key": "ctrl+alt+r ctrl+alt+s",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.rewrapCurly",
        "key": "ctrl+alt+r ctrl+alt+c",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.rewrapQuote",
        "key": "ctrl+alt+r ctrl+alt+q",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap =~ /original|strict/"
      },
      {
        "command": "paredit.deleteForward",
        "key": "delete",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap == strict && !editorReadOnly && !editorHasMultipleSelections && !calva:cursorInComment"
      },
      {
        "command": "paredit.deleteBackward",
        "key": "backspace",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap == strict && !editorReadOnly && !editorHasMultipleSelections && !calva:cursorInComment"
      },
      {
        "command": "paredit.forceDeleteForward",
        "key": "alt+delete",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap == strict && !editorReadOnly && !editorHasMultipleSelections"
      },
      {
        "command": "paredit.forceDeleteBackward",
        "key": "alt+backspace",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && paredit:keyMap == strict && !editorReadOnly && !editorHasMultipleSelections"
      },
      {
        "command": "calva-fmt.formatCurrentForm",
        "key": "tab",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !editorReadOnly && !inSnippetMode && !suggestWidgetVisible && !hasOtherSuggestions && !inSnippetMode"
      },
      {
        "command": "calva-fmt.alignCurrentForm",
        "key": "ctrl+alt+l",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !editorReadOnly && !suggestWidgetVisible && !hasOtherSuggestions"
      },
      {
        "command": "calva-fmt.inferParens",
        "key": "ctrl+alt+p i",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !editorReadOnly && !suggestWidgetVisible && !hasOtherSuggestions"
      },
      {
        "command": "calva-fmt.tabIndent",
        "key": "ctrl+i",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !editorReadOnly && !suggestWidgetVisible && !hasOtherSuggestions"
      },
      {
        "command": "calva-fmt.tabDedent",
        "key": "shift+tab",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && editorTextFocus && !editorReadOnly && !suggestWidgetVisible && !hasOtherSuggestions"
      },
      {
        "command": "calva.showOutputWindow",
        "key": "ctrl+alt+o o",
        "when": "calva:keybindingsEnabled && calva:connected && !calva:outputWindowActive"
      },
      {
        "command": "calva.showFileForOutputWindowNS",
        "key": "ctrl+alt+o o",
        "when": "calva:keybindingsEnabled && calva:connected && calva:outputWindowActive"
      },
      {
        "command": "calva.setOutputWindowNamespace",
        "key": "ctrl+alt+c n",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected && !calva:outputWindowActive"
      },
      {
        "command": "calva.sendCurrentFormToOutputWindow",
        "key": "ctrl+alt+c ctrl+alt+e",
        "win": "ctrl+alt+c ctrl+alt+v",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected && !calva:outputWindowActive"
      },
      {
        "command": "calva.sendCurrentTopLevelFormToOutputWindow",
        "key": "ctrl+alt+c ctrl+alt+space",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected && !calva:outputWindowActive"
      },
      {
        "command": "calva.showPreviousReplHistoryEntry",
        "key": "alt+up",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected && calva:outputWindowActive"
      },
      {
        "command": "calva.showNextReplHistoryEntry",
        "key": "alt+down",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected && calva:outputWindowActive"
      },
      {
        "command": "calva.printClojureDocsToOutputWindow",
        "key": "ctrl+alt+o d",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected"
      },
      {
        "command": "calva.printClojureDocsToRichComment",
        "key": "ctrl+alt+r d",
        "when": "calva:keybindingsEnabled && editorLangId == clojure && calva:connected"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space enter",
        "args": "enter",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space ,",
        "args": ",",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space .",
        "args": ".",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space -",
        "args": "-",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space backspace",
        "args": "backspace",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space left",
        "args": "left",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space right",
        "args": "right",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space up",
        "args": "up",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space down",
        "args": "down",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space tab",
        "args": "tab",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 0",
        "args": "0",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 1",
        "args": "1",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 2",
        "args": "2",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 3",
        "args": "3",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 4",
        "args": "4",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 5",
        "args": "5",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 6",
        "args": "6",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 7",
        "args": "7",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 8",
        "args": "8",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space 9",
        "args": "9",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space a",
        "args": "a",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space b",
        "args": "b",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space c",
        "args": "c",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space d",
        "args": "d",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space e",
        "args": "e",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space f",
        "args": "f",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space g",
        "args": "g",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space h",
        "args": "h",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space i",
        "args": "i",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space j",
        "args": "j",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space k",
        "args": "k",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space l",
        "args": "l",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space m",
        "args": "m",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space n",
        "args": "n",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space o",
        "args": "o",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space p",
        "args": "p",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space q",
        "args": "q",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space r",
        "args": "r",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space s",
        "args": "s",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space t",
        "args": "t",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space u",
        "args": "u",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space v",
        "args": "v",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space w",
        "args": "w",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space x",
        "args": "x",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space y",
        "args": "y",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space z",
        "args": "z",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.runCustomREPLCommand",
        "key": "ctrl+alt+space space",
        "when": "editorLangId == clojure && calva:connected && calva:keybindingsEnabled"
      },
      {
        "command": "calva.toggleBetweenImplAndTest",
        "when": "calva:keybindingsEnabled"
      },
      {
        "command": "paredit.addRichComment",
        "key": "ctrl+alt+r c",
        "when": "editorLangId == clojure && calva:keybindingsEnabled"
      }
    ],
    "menus": {
      "commandPalette": [
        {
          "command": "calva.startOrConnectRepl",
          "when": "true"
        },
        {
          "command": "calva.debug.instrument",
          "when": "editorLangId == clojure && calva:connected"
        },
        {
          "command": "calva.showPreviousReplHistoryEntry",
          "when": "calva:connected && calva:outputWindowActive"
        },
        {
          "command": "calva.showNextReplHistoryEntry",
          "when": "calva:connected && calva:outputWindowActive"
        },
        {
          "command": "calva.showOutputWindow",
          "when": "!calva:outputWindowActive"
        },
        {
          "command": "calva.showFileForOutputWindowNS"
        },
        {
          "command": "calva.toggleBetweenImplAndTest",
          "when": "editorLangId == clojure"
        }
      ],
      "editor/title": [
        {
          "enablement": "editorLangId == clojure  && calva:connected",
          "command": "calva.loadFile",
          "group": "calva/b-eval"
        },
        {
          "enablement": "editorLangId == clojure && calva:connected",
          "command": "calva.setOutputWindowNamespace",
          "group": "calva/b-eval"
        }
      ],
      "editor/context": [
        {
          "when": "editorLangId == clojure",
          "enablement": "!calva:connected",
          "command": "calva.startOrConnectRepl",
          "group": "calva/x-connect"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.disconnect",
          "group": "calva/x-connect"
        },
        {
          "when": "editorLangId == clojure",
          "command": "calva.selectCurrentForm",
          "group": "calva/a-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.loadFile",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.evaluateSelection",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.evaluateCurrentTopLevelForm",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.evaluateSelectionAsComment",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.evaluateTopLevelFormAsComment",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.interruptAllEvaluations",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "command": "calva.togglePrettyPrint",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "command": "calva.toggleEvaluationSendCodeToOutputWindow",
          "group": "calva/b-eval"
        },
        {
          "command": "calva.debug.instrument",
          "enablement": "editorLangId == clojure && calva:connected",
          "when": "editorLangId == clojure && calva:showReplUi",
          "group": "calva/b-eval"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.runAllTests",
          "group": "calva/d-test"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.runNamespaceTests",
          "group": "calva/d-test"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.rerunTests",
          "group": "calva/d-test"
        },
        {
          "when": "editorLangId == clojure && calva:showReplUi",
          "enablement": "calva:connected",
          "command": "calva.runTestUnderCursor",
          "group": "calva/d-test"
        }
      ]
    }
  },
  "scripts": {
    "watch-docs": "mkdocs serve",
    "clean": "rimraf ./out && rimraf ./tsconfig.tsbuildinfo && rimraf ./cljs-out",
    "update-grammar": "node ./src/calva-fmt/update-grammar.js ./src/calva-fmt/atom-language-clojure/grammars/clojure.cson clojure.tmLanguage.json",
    "precompile": "npm i && npm run clean && npm run update-grammar",
    "compile-cljs": "npx shadow-cljs compile :calva-lib :test",
    "compile-ts": "npx tsc --project ./tsconfig.json",
    "compile": "npm run compile-cljs && npm run compile-ts",
    "watch-ts": "npx tsc --watch --project ./tsconfig.json",
    "watch-cljs": "npx shadow-cljs watch :calva-lib :test",
    "watch": "npm run watch-cljs",
    "watch-with-strict-nulls": "npx tsc --watch --project ./tsconfig.json --strictNullChecks",
    "release-cljs": "npx shadow-cljs release :calva-lib :test",
    "release": "npm i && npm run clean && npm run update-grammar && npm run release-cljs && webpack --mode production",
    "compile-test": "tsc -p ./",
    "postrelease": "",
    "vscode:prepublish": "npm run release",
    "bump-version": "npm set git-tag-version false && npm version patch",
    "calva-lib-test": "node ./out/cljs-lib/test/cljs-lib-tests.js",
    "integration-test": "node ./out/extension-test/integration/runTests.js",
    "unit-test": "npx mocha --require ts-node/register 'src/extension-test/unit/**/*-test.ts'",
    "unit-test-watch": "npx mocha --watch --require ts-node/register --watch-extensions ts --watch-files src 'src/extension-test/unit/**/*-test.ts'",
    "publish": "bb publish.clj",
    "prettier-format": "npx prettier --write './**/*.{ts,js,json}'",
    "prettier-check": "npx prettier --check './**/*.{ts,js,json}'",
    "prettier-check-watch": "npx onchange './**/*.{ts,js,json}' -- prettier --check {{changed}}",
    "prettier-format-watch": "npx onchange './**/*.{ts,js,json}' -- prettier --write {{changed}}",
    "eslint": "npx eslint . --ext .js,.jsx,.ts,.tsx",
    "eslint-watch": "npx esw . --ext .js,.jsx,.ts,.tsx --watch"
  },
  "dependencies": {
    "@types/escape-html": "0.0.20",
    "@types/node": "^16.11.26",
    "@types/universal-analytics": "^0.4.2",
    "@types/uuid": "^8.3.1",
    "acorn": "^6.4.1",
    "ansi-to-html": "^0.6.13",
    "escape-html": "^1.0.3",
    "extract-zip": "^2.0.1",
    "find": "0.2.9",
    "follow-redirects": "^1.14.8",
    "get-port": "^5.1.1",
    "immutable": "3.8.1",
    "immutable-cursor": "2.0.1",
    "jszip": "3.7.0",
    "lodash": "^4.17.19",
    "lodash.isequal": "4.5.0",
    "net": "1.0.2",
    "open": "^6.3.0",
    "parinfer": "^3.12.0",
    "tree-kill": "^1.2.2",
    "universal-analytics": "^0.5.3",
    "uuidv4": "6.2.12",
    "vscode-debugadapter": "1.38.0",
    "vscode-extension-telemetry": "0.0.15",
    "vscode-languageclient": "^7.0.0",
    "vsls": "^1.0.4753"
  },
  "devDependencies": {
    "@types/chai": "^4.2.6",
    "@types/follow-redirects": "^1.13.0",
    "@types/glob": "^7.1.1",
    "@types/lodash": "^4.14.167",
    "@types/mocha": "^9.1.0",
    "@types/vscode": "^1.45.0",
    "@typescript-eslint/eslint-plugin": "^5.11.0",
    "@typescript-eslint/parser": "^5.11.0",
    "chai": "^4.2.0",
    "concurrently": "^6.3.0",
    "cson-parser": "^4.0.3",
    "eslint": "^8.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-import": "^2.25.4",
    "eslint-watch": "^8.0.0",
    "fast-check": "^1.22.2",
    "glob": "^7.1.6",
    "jest": "^27.2.5",
    "json": "^10.0.0",
    "minimist": "^1.2.6",
    "mocha": "^9.2.2",
    "mocha-junit-reporter": "^2.0.2",
    "mocha-multi-reporters": "^1.5.1",
    "node-gyp": "^8.4.1",
    "nodemon": "^2.0.3",
    "ovsx": "^0.3.0",
    "prettier": "2.5.1",
    "rimraf": "^2.7.1",
    "shadow-cljs": "^2.11.18",
    "source-map-support": "^0.5.16",
    "style-loader": "^0.23.1",
    "tar": "^4.4.18",
    "ts-loader": "^8.0.18",
    "ts-node": "^10.3.0",
    "typescript": "^3.9.10",
    "url-loader": "^4.1.1",
    "vsce": "^2.6.7",
    "vscode-test": "^1.3.0",
    "webpack": "^5.27.1",
    "webpack-cli": "^4.5.0"
  }
}
