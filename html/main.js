/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./webview-src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../scryetek-editor/js/clojure-lexer.js":
/*!***************************************************!*\
  !*** C:/code/scryetek-editor/js/clojure-lexer.js ***!
  \***************************************************/
/*! exports provided: canonicalParens, validPair, Scanner */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canonicalParens\", function() { return canonicalParens; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validPair\", function() { return validPair; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scanner\", function() { return Scanner; });\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer */ \"../../../scryetek-editor/js/lexer.js\");\n\r\n/** The 'toplevel' lexical grammar. This grammar contains all normal tokens. Multi-line strings are identified as\r\n * \"str-start\", which trigger the lexer to switch to the 'multstring' lexical grammar.\r\n */\r\nlet toplevel = new _lexer__WEBPACK_IMPORTED_MODULE_0__[\"LexicalGrammar\"]();\r\n/** Maps open and close parentheses to their class. */\r\nconst canonicalParens = {\r\n    '#?(': '()',\r\n    '#?@(': '()',\r\n    '#(': '()',\r\n    '(': '()',\r\n    ')': '()',\r\n    '#{': '{}',\r\n    '{': '{}',\r\n    '}': '{}',\r\n    '[': '[]',\r\n    ']': '[]'\r\n};\r\n/** Returns true if open and close are compatible parentheses */\r\nfunction validPair(open, close) {\r\n    return canonicalParens[open] == canonicalParens[close];\r\n}\r\n// whitespace\r\ntoplevel.terminal(/[\\s,]+/, (l, m) => ({ type: \"ws\" }));\r\n// comments\r\ntoplevel.terminal(/;.*/, (l, m) => ({ type: \"comment\" }));\r\n// open parens\r\ntoplevel.terminal(/\\(|\\[|\\{|#\\(|#\\?\\(|#\\{|#\\?@\\(/, (l, m) => ({ type: \"open\" }));\r\n// close parens\r\ntoplevel.terminal(/\\)|\\]|\\}/, (l, m) => ({ type: \"close\" }));\r\n// punctuators\r\ntoplevel.terminal(/~@|~|'|#'|#:|#_|\\^|`|#|\\^:/, (l, m) => ({ type: \"punc\" }));\r\ntoplevel.terminal(/true|false|nil/, (l, m) => ({ type: \"lit\" }));\r\ntoplevel.terminal(/[0-9]+[rR][0-9a-zA-Z]+/, (l, m) => ({ type: \"lit\" }));\r\ntoplevel.terminal(/[-+]?[0-9]+(\\.[0-9]+)?([eE][-+]?[0-9]+)?/, (l, m) => ({ type: \"lit\" }));\r\ntoplevel.terminal(/:[^()[\\]\\{\\}#,~@'`^\\\"\\s;]*/, (l, m) => ({ type: \"kw\" }));\r\n// this is a REALLY lose symbol definition, but similar to how clojure really collects it. numbers/true/nil are all \r\ntoplevel.terminal(/[^()[\\]\\{\\}#,~@'`^\\\"\\s:;][^()[\\]\\{\\}#,~@'`^\\\"\\s;]*/, (l, m) => ({ type: \"id\" }));\r\n// complete string on a single line\r\ntoplevel.terminal(/\"([^\"\\\\]|\\\\.)*\"/, (l, m) => ({ type: \"str\" }));\r\ntoplevel.terminal(/\"([^\"\\\\]|\\\\.)*/, (l, m) => ({ type: \"str-start\" }));\r\ntoplevel.terminal(/./, (l, m) => ({ type: \"junk\" }));\r\n/** This is the multi-line string grammar. It spits out 'str-end' once it is time to switch back to the 'toplevel' grammar, and 'str-inside' if the string continues. */\r\nlet multstring = new _lexer__WEBPACK_IMPORTED_MODULE_0__[\"LexicalGrammar\"]();\r\n// end a multiline string\r\nmultstring.terminal(/([^\"\\\\]|\\\\.)*\"/, (l, m) => ({ type: \"str-end\" }));\r\n// still within a multiline string\r\nmultstring.terminal(/([^\"\\\\]|\\\\.)*/, (l, m) => ({ type: \"str-inside\" }));\r\n/**\r\n * A Clojure(Script) lexical analyser.\r\n * Takes a line of text and a start state, and returns an array of Token, updating its internal state.\r\n */\r\nclass Scanner {\r\n    constructor() {\r\n        this.state = { inString: false };\r\n    }\r\n    processLine(line, state = this.state) {\r\n        let tks = [];\r\n        this.state = state;\r\n        let lex = (this.state.inString ? multstring : toplevel).lex(line);\r\n        let tk;\r\n        do {\r\n            tk = lex.scan();\r\n            if (tk) {\r\n                let oldpos = lex.position;\r\n                switch (tk.type) {\r\n                    case \"str-end\": // multiline string ended, switch back to toplevel\r\n                        this.state = Object.assign({}, this.state, { inString: false });\r\n                        lex = toplevel.lex(line);\r\n                        lex.position = oldpos;\r\n                        break;\r\n                    case \"str-start\": // multiline string started, switch to multstring.\r\n                        this.state = Object.assign({}, this.state, { inString: true });\r\n                        lex = multstring.lex(line);\r\n                        lex.position = oldpos;\r\n                        break;\r\n                }\r\n                tks.push(Object.assign({}, tk, { state: this.state }));\r\n            }\r\n        } while (tk);\r\n        // insert a sentinel EOL value, this allows us to simplify TokenCaret's implementation.\r\n        tks.push({ type: \"eol\", raw: \"\\n\", offset: line.length, state: this.state });\r\n        return tks;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/clojure-lexer.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/hotkeys.js":
/*!*********************************************!*\
  !*** C:/code/scryetek-editor/js/hotkeys.js ***!
  \*********************************************/
/*! exports provided: ALT, CTRL, SHIFT, META, parseHotKey, HotKey, HotKeyTable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ALT\", function() { return ALT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CTRL\", function() { return CTRL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHIFT\", function() { return SHIFT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"META\", function() { return META; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseHotKey\", function() { return parseHotKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HotKey\", function() { return HotKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HotKeyTable\", function() { return HotKeyTable; });\nconst ALT = 1;\r\nconst CTRL = 2;\r\nconst SHIFT = 4;\r\nconst META = 8;\r\nconst isMac = navigator.platform.match(/Mac(Intel|PPC|68k)/i); // somewhat optimistic this would run on MacOS8 but hey ;)\r\nlet keyToId = {};\r\nlet idToKey = {};\r\nfunction key(name, id) {\r\n    keyToId[name.toLowerCase()] = id;\r\n    idToKey[id] = name;\r\n}\r\nkey(\"Backspace\", 8);\r\nkey(\"Space\", 0x20);\r\nkey(\"Tab\", 9);\r\nkey(\"Return\", 13);\r\nkey(\"End\", 35);\r\nkey(\"/\", 191);\r\nkey(\"[\", 219);\r\nkey(\"Home\", 36);\r\nkey(\"LeftArrow\", 37);\r\nkey(\"UpArrow\", 38);\r\nkey(\"RightArrow\", 39);\r\nkey(\"DownArrow\", 40);\r\nkey(\"Delete\", 46);\r\nfunction parseHotKey(key, command) {\r\n    let parts = key.split(\"+\").map(x => x.trim().toLowerCase());\r\n    let i = 0;\r\n    let modifiers = 0;\r\n    outer: for (; i < parts.length; i++) {\r\n        switch (parts[i]) {\r\n            case \"alt\":\r\n                modifiers |= ALT;\r\n                break;\r\n            case \"ctrl\":\r\n                modifiers |= CTRL;\r\n                break;\r\n            case \"shift\":\r\n                modifiers |= SHIFT;\r\n                break;\r\n            case \"meta\":\r\n                modifiers |= META;\r\n                break;\r\n            case \"cmd\":\r\n                modifiers |= (isMac ? META : CTRL);\r\n                break;\r\n            default:\r\n                break outer;\r\n        }\r\n    }\r\n    if (i == parts.length)\r\n        throw new Error(\"No key after modifiers\");\r\n    if (i != parts.length - 1)\r\n        throw new Error(\"Too many keys after modifiers\");\r\n    let mainKey = parts[parts.length - 1];\r\n    if (mainKey.length == 1) {\r\n        let key = keyToId[mainKey];\r\n        if (key === undefined)\r\n            return new HotKey(modifiers, mainKey.toUpperCase().charCodeAt(0), command);\r\n        return new HotKey(modifiers, key, command);\r\n    }\r\n    else {\r\n        let key = keyToId[mainKey];\r\n        if (key === undefined)\r\n            throw new Error(\"Unknown key: \" + mainKey);\r\n        return new HotKey(modifiers, key, command);\r\n    }\r\n}\r\nclass HotKey {\r\n    constructor(modifiers, key, command) {\r\n        this.modifiers = modifiers;\r\n        this.key = key;\r\n        this.command = command;\r\n    }\r\n    match(e) {\r\n        let mods = 0;\r\n        if (e.altKey)\r\n            mods |= ALT;\r\n        if (e.shiftKey)\r\n            mods |= SHIFT;\r\n        if (e.ctrlKey)\r\n            mods |= CTRL;\r\n        if (e.metaKey)\r\n            mods |= META;\r\n        return this.modifiers == mods && this.key == e.keyCode;\r\n    }\r\n}\r\nclass HotKeyTable {\r\n    constructor(keys) {\r\n        this.table = [];\r\n        for (let key in keys)\r\n            this.table.push(parseHotKey(key, keys[key]));\r\n    }\r\n    execute(obj, e) {\r\n        for (let key of this.table) {\r\n            if (key.match(e)) {\r\n                obj.commands[key.command]();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/hotkeys.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/indent.js":
/*!********************************************!*\
  !*** C:/code/scryetek-editor/js/indent.js ***!
  \********************************************/
/*! exports provided: collectIndents, getIndent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"collectIndents\", function() { return collectIndents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIndent\", function() { return getIndent; });\nconst whitespace = new Set([\"ws\", \"comment\", \"eol\"]);\r\n/** Rules shamelessly copied from cljfmt. */\r\nlet indentRules = {\r\n    \"alt!\": [[\"block\", 0]],\r\n    \"alt!!\": [[\"block\", 0]],\r\n    \"are\": [[\"block\", 2]],\r\n    \"as->\": [[\"block\", 2]],\r\n    \"binding\": [[\"block\", 1]],\r\n    \"bound-fn\": [[\"inner\", 1]],\r\n    \"case\": [[\"block\", 1]],\r\n    \"catch\": [[\"block\", 2]],\r\n    \"comment\": [[\"block\", 0]],\r\n    \"cond\": [[\"block\", 0]],\r\n    \"condp\": [[\"block\", 2]],\r\n    \"cond->\": [[\"block\", 1]],\r\n    \"cond->>\": [[\"block\", 1]],\r\n    \"def\": [[\"inner\", 0]],\r\n    \"defmacro\": [[\"inner\", 0]],\r\n    \"defmethod\": [[\"inner\", 0]],\r\n    \"defmulti\": [[\"inner\", 0]],\r\n    \"defn\": [[\"inner\", 0]],\r\n    \"defn-\": [[\"inner\", 0]],\r\n    \"defonce\": [[\"inner\", 0]],\r\n    \"defprotocol\": [[\"block\", 1], [\"inner\", 1]],\r\n    \"defrecord\": [[\"block\", 2], [\"inner\", 1]],\r\n    \"defstruct\": [[\"block\", 1]],\r\n    \"deftest\": [[\"inner\", 0]],\r\n    \"deftype\": [[\"block\", 2], [\"inner\", 1]],\r\n    \"do\": [[\"block\", 0]],\r\n    \"doseq\": [[\"block\", 1]],\r\n    \"dotimes\": [[\"block\", 1]],\r\n    \"doto\": [[\"block\", 1]],\r\n    \"extend\": [[\"block\", 1]],\r\n    \"extend-protocol\": [[\"block\", 1], [\"inner\", 1]],\r\n    \"extend-type\": [[\"block\", 1], [\"inner\", 1]],\r\n    \"fdef\": [[\"inner\", 0]],\r\n    \"finally\": [[\"block\", 0]],\r\n    \"fn\": [[\"inner\", 0]],\r\n    \"for\": [[\"block\", 1]],\r\n    \"future\": [[\"block\", 0]],\r\n    \"go\": [[\"block\", 0]],\r\n    \"go-loop\": [[\"block\", 1]],\r\n    \"if\": [[\"block\", 1]],\r\n    \"if-let\": [[\"block\", 1]],\r\n    \"if-not\": [[\"block\", 1]],\r\n    \"if-some\": [[\"block\", 1]],\r\n    \"let\": [[\"block\", 1]],\r\n    \"letfn\": [[\"block\", 1], [\"inner\", 2, 0]],\r\n    \"locking\": [[\"block\", 1]],\r\n    \"loop\": [[\"block\", 1]],\r\n    \"match\": [[\"block\", 1]],\r\n    \"ns\": [[\"block\", 1]],\r\n    \"proxy\": [[\"block\", 2], [\"inner\", 1]],\r\n    \"reify\": [[\"inner\", 0], [\"inner\", 1]],\r\n    \"struct-map\": [[\"block\", 1]],\r\n    \"testing\": [[\"block\", 1]],\r\n    \"thread\": [[\"block\", 0]],\r\n    \"try\": [[\"block\", 0]],\r\n    \"use-fixtures\": [[\"inner\", 0]],\r\n    \"when\": [[\"block\", 1]],\r\n    \"when-first\": [[\"block\", 1]],\r\n    \"when-let\": [[\"block\", 1]],\r\n    \"when-not\": [[\"block\", 1]],\r\n    \"when-some\": [[\"block\", 1]],\r\n    \"while\": [[\"block\", 1]],\r\n    \"with-local-vars\": [[\"block\", 1]],\r\n    \"with-open\": [[\"block\", 1]],\r\n    \"with-out-str\": [[\"block\", 0]],\r\n    \"with-precision\": [[\"block\", 1]],\r\n    \"with-redefs\": [[\"block\", 1]],\r\n};\r\n/**\r\n * If a token's raw string is in this set, then it counts as an 'open list'. An open list that starts with a symbol\r\n * is something that could be\r\n * considered code, so special formatting rules apply.\r\n */\r\nconst OPEN_LIST = new Set([\"#(\", \"#?(\", \"(\", \"#?@(\"]);\r\n/**\r\n * Analyses the text before position in the document, and returns a list of enclosing expression information with\r\n * various indent information, for use with getIndent()\r\n *\r\n * @param document The document to analyse\r\n * @param position The position (as [row, col] into the document to analyse from)\r\n * @param maxDepth The maximum depth upwards from the expression to search.\r\n * @param maxLines The maximum number of lines above the position to search until we bail with an imprecise answer.\r\n */\r\nfunction collectIndents(document, offset, maxDepth = 3, maxLines = 20) {\r\n    let cursor = document.getTokenCursor(offset);\r\n    cursor.backwardWhitespace();\r\n    let argPos = 0;\r\n    let startLine = cursor.line;\r\n    let exprsOnLine = 0;\r\n    let lastLine = cursor.line;\r\n    let lastIndent = 0;\r\n    let indents = [];\r\n    do {\r\n        if (!cursor.backwardSexp()) {\r\n            // this needs some work..\r\n            let prevToken = cursor.getPrevToken();\r\n            if (prevToken.type == 'open' && prevToken.offset <= 1) {\r\n                maxDepth = 0; // treat an sexpr starting on line 0 sensibly.\r\n            }\r\n            // skip past the first item and record the indent of the first item on the same line if there is one.\r\n            let nextCursor = cursor.clone();\r\n            nextCursor.forwardSexp();\r\n            nextCursor.forwardWhitespace();\r\n            // iff the first item of this list is a an identifier, and the second item is on the same line, indent to that second item. otherwise indent to the open paren.\r\n            let firstItemIdent = cursor.getToken().type == \"id\" && nextCursor.line == cursor.line && !nextCursor.atEnd() && OPEN_LIST.has(prevToken.raw) ? nextCursor.rowCol[1] : cursor.rowCol[1];\r\n            let token = cursor.getToken().raw;\r\n            let startIndent = cursor.rowCol[1];\r\n            if (!cursor.backwardUpList())\r\n                break;\r\n            let indentRule = indentRules[token] || [];\r\n            indents.unshift({ first: token, rules: indentRule, argPos, exprsOnLine, startIndent, firstItemIdent });\r\n            argPos = 0;\r\n            exprsOnLine = 1;\r\n        }\r\n        if (cursor.line != lastLine) {\r\n            let head = cursor.clone();\r\n            head.forwardSexp();\r\n            head.forwardWhitespace();\r\n            if (!head.atEnd()) {\r\n                lastIndent = head.rowCol[1];\r\n                exprsOnLine = 0;\r\n                lastLine = cursor.line;\r\n            }\r\n        }\r\n        if (whitespace.has(cursor.getPrevToken().type)) {\r\n            argPos++;\r\n            exprsOnLine++;\r\n        }\r\n    } while (!cursor.atStart() && Math.abs(startLine - cursor.line) < maxLines && indents.length < maxDepth);\r\n    if (!indents.length)\r\n        indents.push({ argPos: 0, first: null, rules: [], exprsOnLine: 0, startIndent: lastIndent >= 0 ? lastIndent : 0, firstItemIdent: lastIndent >= 0 ? lastIndent : 0 });\r\n    return indents;\r\n}\r\n/** Returns the expected newline indent for the given position, in characters. */\r\nfunction getIndent(document, offset) {\r\n    let state = collectIndents(document, offset);\r\n    // now find applicable indent rules\r\n    let indent = -1;\r\n    let thisBlock = state[state.length - 1];\r\n    if (!state.length)\r\n        return 0;\r\n    for (let pos = state.length - 1; pos >= 0; pos--) {\r\n        for (let rule of state[pos].rules) {\r\n            if (rule[0] == \"inner\") {\r\n                if (pos + rule[1] == state.length - 1) {\r\n                    if (rule.length == 3) {\r\n                        if (rule[2] > thisBlock.argPos)\r\n                            indent = thisBlock.startIndent + 1;\r\n                    }\r\n                    else\r\n                        indent = thisBlock.startIndent + 1;\r\n                }\r\n            }\r\n            else if (rule[0] == \"block\" && pos == state.length - 1) {\r\n                if (thisBlock.exprsOnLine <= rule[1]) {\r\n                    if (thisBlock.argPos >= rule[1])\r\n                        indent = thisBlock.startIndent + 1;\r\n                }\r\n                else {\r\n                    indent = thisBlock.firstItemIdent;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (indent == -1) {\r\n        // no indentation styles applied, so use default style.\r\n        if (thisBlock.exprsOnLine > 0)\r\n            indent = thisBlock.firstItemIdent;\r\n        else\r\n            indent = thisBlock.startIndent;\r\n    }\r\n    return indent;\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/indent.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/index.js":
/*!*******************************************!*\
  !*** C:/code/scryetek-editor/js/index.js ***!
  \*******************************************/
/*! exports provided: ReplConsole, ALT, CTRL, SHIFT, META, parseHotKey, HotKey, HotKeyTable, ReplReadline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _repl_console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./repl-console */ \"../../../scryetek-editor/js/repl-console.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ReplConsole\", function() { return _repl_console__WEBPACK_IMPORTED_MODULE_0__[\"ReplConsole\"]; });\n\n/* harmony import */ var _hotkeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hotkeys */ \"../../../scryetek-editor/js/hotkeys.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ALT\", function() { return _hotkeys__WEBPACK_IMPORTED_MODULE_1__[\"ALT\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CTRL\", function() { return _hotkeys__WEBPACK_IMPORTED_MODULE_1__[\"CTRL\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SHIFT\", function() { return _hotkeys__WEBPACK_IMPORTED_MODULE_1__[\"SHIFT\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"META\", function() { return _hotkeys__WEBPACK_IMPORTED_MODULE_1__[\"META\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parseHotKey\", function() { return _hotkeys__WEBPACK_IMPORTED_MODULE_1__[\"parseHotKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HotKey\", function() { return _hotkeys__WEBPACK_IMPORTED_MODULE_1__[\"HotKey\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HotKeyTable\", function() { return _hotkeys__WEBPACK_IMPORTED_MODULE_1__[\"HotKeyTable\"]; });\n\n/* harmony import */ var _readline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./readline */ \"../../../scryetek-editor/js/readline.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ReplReadline\", function() { return _readline__WEBPACK_IMPORTED_MODULE_2__[\"ReplReadline\"]; });\n\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/index.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/lexer.js":
/*!*******************************************!*\
  !*** C:/code/scryetek-editor/js/lexer.js ***!
  \*******************************************/
/*! exports provided: Lexer, LexicalGrammar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LexicalGrammar\", function() { return LexicalGrammar; });\n/**\r\n * A Lexical analyser\r\n * @module lexer\r\n */\r\n/**\r\n * A Lexer instance, parsing a given file.  Usually you should use a LexicalGrammar to\r\n * create one of these.\r\n *\r\n * @class\r\n * @param {string} source the source code to parse\r\n * @param rules the rules of this lexer.\r\n */\r\nclass Lexer {\r\n    constructor(source, rules) {\r\n        this.source = source;\r\n        this.rules = rules;\r\n        this.position = 0;\r\n    }\r\n    /** Returns the next token in this lexer, or null if at the end. If the match fails, throws an Error. */\r\n    scan() {\r\n        var token = null;\r\n        var length = 0;\r\n        this.rules.forEach(rule => {\r\n            rule.r.lastIndex = this.position;\r\n            var x = rule.r.exec(this.source);\r\n            if (x && x[0].length > length && this.position + x[0].length == rule.r.lastIndex) {\r\n                token = rule.fn(this, x);\r\n                token.offset = this.position;\r\n                token.raw = x[0];\r\n                length = x[0].length;\r\n            }\r\n        });\r\n        this.position += length;\r\n        if (token == null) {\r\n            if (this.position == this.source.length)\r\n                return null;\r\n            throw new Error(\"Unexpected character at \" + this.position + \": \" + JSON.stringify(this.source));\r\n        }\r\n        return token;\r\n    }\r\n}\r\n/**\r\n * A lexical grammar- factory for lexer instances.\r\n * @class\r\n */\r\nclass LexicalGrammar {\r\n    constructor() {\r\n        this.rules = [];\r\n    }\r\n    /**\r\n     * Defines a terminal with the given pattern and constructor.\r\n     * @param {string | RegExp} pattern the pattern this terminal must match.\r\n     * @param {function(Array<string>): Object} fn returns a lexical token representing\r\n     *        this terminal.  An additional \"offset\" property containing the token source position\r\n     *        will also be added, as well as a \"raw\" property, containing the raw string match.\r\n     */\r\n    terminal(pattern, fn) {\r\n        this.rules.push({\r\n            // This is b/c the RegExp constructor seems to not like our union type (unknown reasons why)\r\n            r: pattern instanceof RegExp ? new RegExp(pattern, \"g\") : new RegExp(pattern, \"g\"),\r\n            fn: fn\r\n        });\r\n    }\r\n    /**\r\n     * Create a Lexer for the given input.\r\n     */\r\n    lex(source) {\r\n        return new Lexer(source, this.rules);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/lexer.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/model.js":
/*!*******************************************!*\
  !*** C:/code/scryetek-editor/js/model.js ***!
  \*******************************************/
/*! exports provided: TextLine, LineInputModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextLine\", function() { return TextLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineInputModel\", function() { return LineInputModel; });\n/* harmony import */ var _clojure_lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clojure-lexer */ \"../../../scryetek-editor/js/clojure-lexer.js\");\n/* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./undo */ \"../../../scryetek-editor/js/undo.js\");\n\r\n\r\nconst scanner = new _clojure_lexer__WEBPACK_IMPORTED_MODULE_0__[\"Scanner\"]();\r\n/** A cheesy deep-equal function for matching scanner states. Good enough to compare plain old js objects. */\r\nfunction equal(x, y) {\r\n    if (x == y)\r\n        return true;\r\n    if (x instanceof Array && y instanceof Array) {\r\n        if (x.length == y.length) {\r\n            for (let i = 0; i < x.length; i++)\r\n                if (!equal(x[i], y[i]))\r\n                    return false;\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    else if (!(x instanceof Array) && !(y instanceof Array) && x instanceof Object && y instanceof Object) {\r\n        for (let f in x)\r\n            if (!equal(x[f], y[f]))\r\n                return false;\r\n        for (let f in y)\r\n            if (!x.hasOwnProperty(f))\r\n                return false;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nclass TextLine {\r\n    constructor(text, startState) {\r\n        this.startState = startState;\r\n        this.tokens = [];\r\n        this.text = text;\r\n        this.tokens = scanner.processLine(text);\r\n        this.endState = Object.assign({}, scanner.state);\r\n    }\r\n    processLine(oldState) {\r\n        this.startState = Object.assign({}, oldState);\r\n        this.tokens = scanner.processLine(this.text, oldState);\r\n        this.endState = Object.assign({}, scanner.state);\r\n    }\r\n}\r\n/** The underlying model for the REPL readline. */\r\nclass LineInputModel {\r\n    constructor() {\r\n        /** The input lines. */\r\n        this.lines = [new TextLine(\"\", this.getStateForLine(0))];\r\n        /** Lines whose text has changed. */\r\n        this.changedLines = new Set();\r\n        /** Lines which must be inserted. */\r\n        this.insertedLines = new Set();\r\n        /** Lines which must be deleted. */\r\n        this.deletedLines = new Set();\r\n        /** Handles undo/redo support */\r\n        this.undoManager = new _undo__WEBPACK_IMPORTED_MODULE_1__[\"UndoManager\"]();\r\n        /** When set, insertString and deleteRange will be added to the undo history. */\r\n        this.recordingUndo = false;\r\n        /** Lines which must be re-lexed. */\r\n        this.dirtyLines = [];\r\n    }\r\n    updateLines(start, deleted, inserted) {\r\n        let delta = inserted - deleted;\r\n        this.dirtyLines = this.dirtyLines.filter(x => x < start || x >= start + deleted)\r\n            .map(x => x >= start ? x + delta : x);\r\n        this.changedLines = new Set(Array.from(this.changedLines).map(x => {\r\n            if (x > start && x < start + deleted)\r\n                return null;\r\n            if (x >= start)\r\n                return x + delta;\r\n            return x;\r\n        }).filter(x => x !== null));\r\n        this.insertedLines = new Set(Array.from(this.insertedLines).map((x) => {\r\n            let [a, b] = x;\r\n            if (a > start && a < start + deleted)\r\n                return null;\r\n            if (a >= start)\r\n                return [a + delta, b];\r\n            return [a, b];\r\n        }).filter(x => x !== null));\r\n        this.deletedLines = new Set(Array.from(this.deletedLines).map((x) => {\r\n            let [a, b] = x;\r\n            if (a > start && a < start + deleted)\r\n                return null;\r\n            if (a >= start)\r\n                return [a + delta, b];\r\n            return [a, b];\r\n        }).filter(x => x !== null));\r\n    }\r\n    deleteLines(start, count) {\r\n        if (count == 0)\r\n            return;\r\n        this.updateLines(start, count, 0);\r\n        this.deletedLines.add([start, count]);\r\n    }\r\n    insertLines(start, count) {\r\n        this.updateLines(start, 0, count);\r\n        this.insertedLines.add([start, count]);\r\n    }\r\n    /**\r\n     * Mark a line as needing to be re-lexed.\r\n     *\r\n     * @param idx the index of the line which needs re-lexing (0-based)\r\n    */\r\n    markDirty(idx) {\r\n        if (idx >= 0 && idx < this.lines.length && this.dirtyLines.indexOf(idx) == -1)\r\n            this.dirtyLines.push(idx);\r\n    }\r\n    /**\r\n     * Re-lexes all lines marked dirty, cascading onto the lines below if the end state for this line has\r\n     * changed.\r\n     */\r\n    flushChanges() {\r\n        if (!this.dirtyLines.length)\r\n            return;\r\n        let seen = new Set();\r\n        this.dirtyLines.sort();\r\n        while (this.dirtyLines.length) {\r\n            let nextIdx = this.dirtyLines.shift();\r\n            if (seen.has(nextIdx))\r\n                continue; // already processed.\r\n            let prevState = this.getStateForLine(nextIdx);\r\n            do {\r\n                seen.add(nextIdx);\r\n                this.changedLines.add(nextIdx);\r\n                this.lines[nextIdx].processLine(prevState);\r\n                prevState = this.lines[nextIdx].endState;\r\n            } while (this.lines[++nextIdx] && !(equal(this.lines[nextIdx].startState, prevState)));\r\n        }\r\n    }\r\n    /**\r\n     * Returns the character offset in the model to the start of a given line.\r\n     *\r\n     * @param line the line who's offset will be returned.\r\n     */\r\n    getOffsetForLine(line) {\r\n        let max = 0;\r\n        for (let i = 0; i < line; i++)\r\n            max += this.lines[i].text.length + 1;\r\n        return max;\r\n    }\r\n    /**\r\n     * Returns the text between start and end as a string. These may be in any order.\r\n     *\r\n     * @param start the start offset in the text range\r\n     * @param end the end offset in the text range\r\n     */\r\n    getText(start, end) {\r\n        if (start == end)\r\n            return \"\";\r\n        let st = this.getRowCol(Math.min(start, end));\r\n        let en = this.getRowCol(Math.max(start, end));\r\n        let lines = [];\r\n        if (st[0] == en[0])\r\n            lines[0] = this.lines[st[0]].text.substring(st[1], en[1]);\r\n        else\r\n            lines[0] = this.lines[st[0]].text.substring(st[1]);\r\n        for (let i = st[0] + 1; i < en[0]; i++)\r\n            lines.push(this.lines[i].text);\r\n        if (st[0] != en[0])\r\n            lines.push(this.lines[en[0]].text.substring(0, en[1]));\r\n        return lines.join('\\n');\r\n    }\r\n    /**\r\n     * Returns the row and column for a given text offset in this model.\r\n     */\r\n    getRowCol(offset) {\r\n        for (let i = 0; i < this.lines.length; i++) {\r\n            if (offset > this.lines[i].text.length)\r\n                offset -= this.lines[i].text.length + 1;\r\n            else\r\n                return [i, offset];\r\n        }\r\n        return [this.lines.length - 1, this.lines[this.lines.length - 1].text.length];\r\n    }\r\n    /**\r\n     * Returns the initial lexer state for a given line.\r\n     * Line 0 is always { inString: false }, all lines below are equivalent to their previous line's startState.\r\n     *\r\n     * @param line the line to retrieve the lexer state.\r\n     */\r\n    getStateForLine(line) {\r\n        return line == 0 ? { inString: false, } : Object.assign({}, this.lines[line - 1].endState);\r\n    }\r\n    /**\r\n     * Changes the model. Deletes any text between `start` and `end`, and the inserts `text`.\r\n     *\r\n     * If provided, `oldSelection` and `newSelection` are used to manage the cursor positioning for undo support.\r\n     *\r\n     * @param start the start offset in the range to delete\r\n     * @param end the end offset in the range to delete\r\n     * @param text the new text to insert\r\n     * @param oldSelection the old selection\r\n     * @param newSelection the new selection\r\n     */\r\n    changeRange(start, end, text, oldSelection, newSelection) {\r\n        let deletedText = this.recordingUndo ? this.getText(start, end) : \"\";\r\n        let [startLine, startCol] = this.getRowCol(start);\r\n        let [endLine, endCol] = this.getRowCol(end);\r\n        // extract the lines we will replace\r\n        let replaceLines = text.split(/\\r\\n|\\n/);\r\n        // the left side of the line unaffected by the edit.\r\n        let left = this.lines[startLine].text.substr(0, startCol);\r\n        // the right side of the line unaffected by the edit.\r\n        let right = this.lines[endLine].text.substr(endCol);\r\n        let items = [];\r\n        // initialize the lexer state - the first line is definitely not in a string, otherwise copy the\r\n        // end state of the previous line before the edit\r\n        let state = this.getStateForLine(startLine);\r\n        if (startLine != endLine)\r\n            this.deleteLines(startLine + 1, endLine - startLine - (replaceLines.length - 1));\r\n        if (replaceLines.length == 1) {\r\n            // trivial single line edit\r\n            items.push(new TextLine(left + replaceLines[0] + right, state));\r\n            this.changedLines.add(startLine);\r\n        }\r\n        else {\r\n            // multi line edit.\r\n            items.push(new TextLine(left + replaceLines[0], state));\r\n            for (let i = 1; i < replaceLines.length - 1; i++)\r\n                items.push(new TextLine(replaceLines[i], scanner.state));\r\n            items.push(new TextLine(replaceLines[replaceLines.length - 1] + right, scanner.state));\r\n            this.insertLines(startLine + 1, replaceLines.length - 1 - (endLine - startLine));\r\n            for (let i = 1; i < items.length; i++)\r\n                this.changedLines.add(startLine + i);\r\n            this.markDirty(startLine + 1);\r\n        }\r\n        // now splice in our edited lines\r\n        this.lines.splice(startLine, endLine - startLine + 1, ...items);\r\n        this.markDirty(startLine);\r\n        if (this.recordingUndo) {\r\n            this.undoManager.addUndoStep(new EditorUndoStep(\"Edit\", start, text, deletedText, oldSelection, newSelection));\r\n        }\r\n    }\r\n    /**\r\n     * Inserts a string at the given position in the document.\r\n     *\r\n     * If recordingUndo is set, an UndoStep is inserted into the undoManager, which will record the original\r\n     * cursor position.\r\n     *\r\n     * @param offset the offset to insert at\r\n     * @param text the text to insert\r\n     * @param oldCursor the [row,col] of the cursor at the start of the operation\r\n     */\r\n    insertString(offset, text, oldSelection, newSelection) {\r\n        this.changeRange(offset, offset, text, oldSelection, newSelection);\r\n        return text.length;\r\n    }\r\n    /**\r\n     * Deletes count characters starting at offset from the document.\r\n     * If recordingUndo is set, adds an undoStep, using oldCursor and newCursor.\r\n     *\r\n     * @param offset the offset to delete from\r\n     * @param count the number of characters to delete\r\n     * @param oldCursor the cursor at the start of the operation\r\n     * @param newCursor the cursor at the end of the operation\r\n     */\r\n    deleteRange(offset, count, oldSelection, newSelection) {\r\n        this.changeRange(offset, offset + count, \"\", oldSelection, newSelection);\r\n    }\r\n    /** Return the offset of the last character in this model. */\r\n    get maxOffset() {\r\n        let max = 0;\r\n        for (let i = 0; i < this.lines.length; i++)\r\n            max += this.lines[i].text.length + 1;\r\n        return max - 1;\r\n    }\r\n}\r\n/**\r\n * An Editor UndoStep.\r\n *\r\n * All Editor Undo steps contain the position of the cursor before and after the edit.\r\n */\r\nclass EditorUndoStep extends _undo__WEBPACK_IMPORTED_MODULE_1__[\"UndoStep\"] {\r\n    constructor(name, start, insertedText, deletedText, oldSelection, newSelection) {\r\n        super();\r\n        this.name = name;\r\n        this.start = start;\r\n        this.insertedText = insertedText;\r\n        this.deletedText = deletedText;\r\n        this.oldSelection = oldSelection;\r\n        this.newSelection = newSelection;\r\n    }\r\n    undo(c) {\r\n        c.model.changeRange(this.start, this.start + this.insertedText.length, this.deletedText);\r\n        if (this.oldSelection)\r\n            [c.selectionStart, c.selectionEnd] = this.oldSelection;\r\n    }\r\n    redo(c) {\r\n        c.model.changeRange(this.start, this.start + this.deletedText.length, this.insertedText);\r\n        if (this.newSelection)\r\n            [c.selectionStart, c.selectionEnd] = this.newSelection;\r\n    }\r\n    coalesce(step) {\r\n        if (this.deletedText === \"\" && step.deletedText === \"\" && this.insertedText !== \"\" && step.insertedText !== \"\") {\r\n            if (this.start + this.insertedText.length == step.start) {\r\n                this.insertedText += step.insertedText;\r\n                this.newSelection = step.newSelection;\r\n                return true;\r\n            }\r\n        }\r\n        else if (this.deletedText !== \"\" && step.deletedText !== \"\" && this.insertedText === \"\" && step.insertedText === \"\") {\r\n            // repeated delete key\r\n            if (this.start == step.start) {\r\n                this.deletedText += step.deletedText;\r\n                this.newSelection = step.newSelection;\r\n                return true;\r\n            }\r\n            // repeated backspace key\r\n            if (this.start - step.deletedText.length == step.start) {\r\n                this.start = step.start;\r\n                this.deletedText = step.deletedText + this.deletedText;\r\n                this.newSelection = step.newSelection;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/model.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/paredit.js":
/*!*********************************************!*\
  !*** C:/code/scryetek-editor/js/paredit.js ***!
  \*********************************************/
/*! exports provided: wrapSexpr, splitSexp, joinSexp, spliceSexp, killBackwardList, killForwardList, spliceSexpKillingBackward, spliceSexpKillingForward, forwardSlurpSexp, backwardSlurpSexp, forwardBarfSexp, backwardBarfSexp, open, close, backspace, deleteForward, stringQuote, growSelection, shrinkSelection, raiseSexp, convolute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrapSexpr\", function() { return wrapSexpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitSexp\", function() { return splitSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"joinSexp\", function() { return joinSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"spliceSexp\", function() { return spliceSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"killBackwardList\", function() { return killBackwardList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"killForwardList\", function() { return killForwardList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"spliceSexpKillingBackward\", function() { return spliceSexpKillingBackward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"spliceSexpKillingForward\", function() { return spliceSexpKillingForward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardSlurpSexp\", function() { return forwardSlurpSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backwardSlurpSexp\", function() { return backwardSlurpSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardBarfSexp\", function() { return forwardBarfSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backwardBarfSexp\", function() { return backwardBarfSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"open\", function() { return open; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"close\", function() { return close; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backspace\", function() { return backspace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deleteForward\", function() { return deleteForward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringQuote\", function() { return stringQuote; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"growSelection\", function() { return growSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shrinkSelection\", function() { return shrinkSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"raiseSexp\", function() { return raiseSexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convolute\", function() { return convolute; });\n/* harmony import */ var _clojure_lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clojure-lexer */ \"../../../scryetek-editor/js/clojure-lexer.js\");\n\r\nfunction wrapSexpr(doc, open, close, start = doc.selectionStart, end = doc.selectionEnd) {\r\n    let st = Math.min(start, end);\r\n    let en = Math.max(start, end);\r\n    let cursor = doc.getTokenCursor(en);\r\n    if (cursor.withinString())\r\n        throw new Error(\"Invalid context for paredit.wrapSexp\");\r\n    if (st == end) {\r\n        cursor.forwardSexp();\r\n        en = cursor.offsetStart;\r\n        // NOTE: emacs leaves the selection as is, but it has no relation to what was selected after the transform.\r\n        //       I have opted to clear it here.\r\n        doc.selectionStart = doc.selectionEnd = en;\r\n    }\r\n    doc.model.insertString(en, close);\r\n    doc.model.insertString(st, open);\r\n}\r\nfunction splitSexp(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    if (cursor.withinString()) {\r\n        if (doc.model.getText(start - 1, start + 1) == '\\\\\"') {\r\n            doc.model.changeRange(start + 1, start + 1, \"\\\" \\\"\");\r\n            doc.selectionStart = doc.selectionEnd = start + 2;\r\n        }\r\n        else {\r\n            doc.model.changeRange(start, start, \"\\\" \\\"\");\r\n            doc.selectionStart = doc.selectionEnd = start + 1;\r\n        }\r\n        return;\r\n    }\r\n    cursor.backwardWhitespace();\r\n    start = cursor.offsetStart;\r\n    let ws = cursor.clone();\r\n    ws.forwardWhitespace();\r\n    if (cursor.backwardList()) {\r\n        let open = cursor.getPrevToken().raw;\r\n        if (cursor.forwardList()) {\r\n            let close = cursor.getToken().raw;\r\n            doc.model.changeRange(start, ws.offsetStart, close + \" \" + open);\r\n            doc.selectionStart = doc.selectionEnd = start + 1;\r\n        }\r\n    }\r\n}\r\nfunction joinSexp(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    cursor.backwardWhitespace();\r\n    let open = cursor.getPrevToken();\r\n    let beginning = cursor.offsetStart;\r\n    if (cursor.withinString())\r\n        throw new Error(\"Invalid context for paredit.joinSexp\");\r\n    if (open.type == \"str-end\" || open.type == \"str\") {\r\n        cursor.forwardWhitespace();\r\n        let close = cursor.getToken();\r\n        let end = cursor.offsetStart;\r\n        if ((close.type == \"str\" || close.type == \"str-start\")) {\r\n            doc.model.changeRange(beginning - 1, end + 1, \"\");\r\n            doc.selectionStart = doc.selectionEnd = beginning - 1;\r\n        }\r\n    }\r\n    else if (open.type == \"close\") {\r\n        cursor.forwardWhitespace();\r\n        let close = cursor.getToken();\r\n        let end = cursor.offsetStart;\r\n        if (close.type == \"open\" && Object(_clojure_lexer__WEBPACK_IMPORTED_MODULE_0__[\"validPair\"])(open.raw, close.raw)) {\r\n            doc.model.changeRange(beginning - 1, end + 1, \" \");\r\n            doc.selectionStart = doc.selectionEnd = beginning;\r\n        }\r\n    }\r\n}\r\nfunction spliceSexp(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    // NOTE: this should unwrap the string, not throw.\r\n    if (cursor.withinString())\r\n        throw new Error(\"Invalid context for paredit.spliceSexp\");\r\n    cursor.backwardList();\r\n    let open = cursor.getPrevToken();\r\n    let beginning = cursor.offsetStart;\r\n    if (open.type == \"open\") {\r\n        cursor.forwardList();\r\n        let close = cursor.getToken();\r\n        let end = cursor.offsetStart;\r\n        if (close.type == \"close\" && Object(_clojure_lexer__WEBPACK_IMPORTED_MODULE_0__[\"validPair\"])(open.raw, close.raw)) {\r\n            doc.model.changeRange(end, end + 1, \"\");\r\n            doc.model.changeRange(beginning - 1, beginning, \"\");\r\n            doc.selectionStart = doc.selectionEnd = start - 1;\r\n        }\r\n    }\r\n}\r\nfunction killBackwardList(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    // NOTE: this should unwrap the string, not throw.\r\n    if (cursor.withinString())\r\n        throw new Error(\"Invalid context for paredit.killBackwardList\");\r\n    cursor.backwardList();\r\n    doc.model.changeRange(cursor.offsetStart, start, \"\");\r\n    return doc.selectionStart = doc.selectionEnd = cursor.offsetStart;\r\n}\r\nfunction killForwardList(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    let inComment = (cursor.getToken().type == \"comment\" && start > cursor.offsetStart) || cursor.getPrevToken().type == \"comment\";\r\n    // NOTE: this should unwrap the string, not throw.\r\n    if (cursor.withinString())\r\n        throw new Error(\"Invalid context for paredit.killForwardList\");\r\n    cursor.forwardList();\r\n    doc.model.changeRange(start, cursor.offsetStart, inComment ? \"\\n\" : \"\");\r\n    return doc.selectionStart = doc.selectionEnd = start;\r\n}\r\nfunction spliceSexpKillingBackward(doc, start = doc.selectionEnd) {\r\n    spliceSexp(doc, killBackwardList(doc, start));\r\n}\r\nfunction spliceSexpKillingForward(doc, start = doc.selectionEnd) {\r\n    spliceSexp(doc, killForwardList(doc, start));\r\n}\r\nfunction forwardSlurpSexp(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    cursor.forwardList();\r\n    if (cursor.getToken().type == \"close\") {\r\n        let offset = cursor.offsetStart;\r\n        let close = cursor.getToken().raw;\r\n        cursor.next();\r\n        cursor.forwardSexp(true);\r\n        cursor.backwardWhitespace(false);\r\n        doc.model.changeRange(cursor.offsetStart, cursor.offsetStart, close);\r\n        doc.model.changeRange(offset, offset + 1, \"\");\r\n    }\r\n}\r\nfunction backwardSlurpSexp(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    cursor.backwardList();\r\n    let tk = cursor.getPrevToken();\r\n    if (tk.type == \"open\") {\r\n        let offset = cursor.clone().previous().offsetStart;\r\n        let close = cursor.getPrevToken().raw;\r\n        cursor.previous();\r\n        cursor.backwardSexp(true);\r\n        cursor.forwardWhitespace(false);\r\n        doc.model.changeRange(offset, offset + tk.raw.length, \"\");\r\n        doc.model.changeRange(cursor.offsetStart, cursor.offsetStart, close);\r\n    }\r\n}\r\nfunction forwardBarfSexp(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    cursor.forwardList();\r\n    if (cursor.getToken().type == \"close\") {\r\n        let offset = cursor.offsetStart;\r\n        let close = cursor.getToken().raw;\r\n        cursor.backwardSexp(true);\r\n        cursor.backwardWhitespace();\r\n        doc.model.changeRange(offset, offset + 1, \"\");\r\n        doc.model.changeRange(cursor.offsetStart, cursor.offsetStart, close);\r\n    }\r\n}\r\nfunction backwardBarfSexp(doc, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor(start);\r\n    cursor.backwardList();\r\n    let tk = cursor.getPrevToken();\r\n    if (tk.type == \"open\") {\r\n        cursor.previous();\r\n        let offset = cursor.offsetStart;\r\n        let close = cursor.getToken().raw;\r\n        cursor.next();\r\n        cursor.forwardSexp(true);\r\n        cursor.forwardWhitespace(false);\r\n        doc.model.changeRange(cursor.offsetStart, cursor.offsetStart, close);\r\n        doc.model.changeRange(offset, offset + tk.raw.length, \"\");\r\n    }\r\n}\r\nfunction open(doc, pair, start = doc.selectionEnd) {\r\n    doc.insertString(pair);\r\n    doc.selectionStart = doc.selectionEnd = start + 1;\r\n}\r\nfunction close(doc, close, start = doc.selectionEnd) {\r\n    let cursor = doc.getTokenCursor();\r\n    cursor.forwardWhitespace(false);\r\n    if (cursor.getToken().raw == close) {\r\n        doc.model.changeRange(start, cursor.offsetStart, \"\");\r\n        doc.selectionStart = doc.selectionEnd = start + 1;\r\n    }\r\n    else {\r\n        // one of two things are possible:\r\n        if (cursor.forwardList()) {\r\n            //   we are in a matched list, just jump to the end of it.\r\n            doc.selectionStart = doc.selectionEnd = cursor.offsetEnd;\r\n        }\r\n        else {\r\n            while (cursor.forwardSexp()) { }\r\n            doc.model.changeRange(cursor.offsetEnd, cursor.offsetEnd, close);\r\n            doc.selectionStart = doc.selectionEnd = cursor.offsetEnd + 1;\r\n        }\r\n    }\r\n}\r\nconst parenPair = new Set([\"()\", \"[]\", \"{}\", '\"\"', '\\\\\"']);\r\nconst openParen = new Set([\"(\", \"[\", \"{\", '\"']);\r\nconst closeParen = new Set([\")\", \"]\", \"}\", '\"']);\r\nfunction backspace(doc, start = doc.selectionStart, end = doc.selectionEnd) {\r\n    if (start != end) {\r\n        doc.backspace();\r\n    }\r\n    else {\r\n        if (doc.model.getText(start - 3, start) == '\\\\\"\"') {\r\n            doc.selectionStart = doc.selectionEnd = start - 1;\r\n        }\r\n        else if (doc.model.getText(start - 2, start - 1) == '\\\\') {\r\n            doc.model.deleteRange(start - 2, 2);\r\n            doc.selectionStart = doc.selectionEnd = start - 2;\r\n        }\r\n        else if (parenPair.has(doc.model.getText(start - 1, start + 1))) {\r\n            doc.model.deleteRange(start - 1, 2);\r\n            doc.selectionStart = doc.selectionEnd = start - 1;\r\n        }\r\n        else if (closeParen.has(doc.model.getText(start - 1, start)) || openParen.has(doc.model.getText(start - 1, start))) {\r\n            doc.selectionStart = doc.selectionEnd = start - 1;\r\n        }\r\n        else if (openParen.has(doc.model.getText(start - 1, start + 1)) || closeParen.has(doc.model.getText(start - 1, start))) {\r\n            doc.model.deleteRange(start - 1, 2);\r\n            doc.selectionStart = doc.selectionEnd = start - 1;\r\n        }\r\n        else\r\n            doc.backspace();\r\n    }\r\n}\r\nfunction deleteForward(doc, start = doc.selectionStart, end = doc.selectionEnd) {\r\n    if (start != end) {\r\n        doc.delete();\r\n    }\r\n    else {\r\n        if (parenPair.has(doc.model.getText(start, start + 2))) {\r\n            doc.model.deleteRange(start, 2);\r\n        }\r\n        else if (parenPair.has(doc.model.getText(start - 1, start + 1))) {\r\n            doc.model.deleteRange(start - 1, 2);\r\n            doc.selectionStart = doc.selectionEnd = start - 1;\r\n        }\r\n        else if (openParen.has(doc.model.getText(start, start + 1)) || closeParen.has(doc.model.getText(start, start + 1))) {\r\n            doc.selectionStart = doc.selectionEnd = start + 1;\r\n        }\r\n        else\r\n            doc.delete();\r\n    }\r\n}\r\nfunction stringQuote(doc, start = doc.selectionStart, end = doc.selectionEnd) {\r\n    if (start != end) {\r\n        doc.insertString('\"');\r\n    }\r\n    else {\r\n        let cursor = doc.getTokenCursor(start);\r\n        if (cursor.withinString()) {\r\n            // inside a string, let's be clever\r\n            if (cursor.offsetEnd - 1 == start && cursor.getToken().type == \"str\" || cursor.getToken().type == \"str-end\") {\r\n                doc.selectionStart = doc.selectionEnd = start + 1;\r\n            }\r\n            else {\r\n                doc.model.changeRange(start, start, '\"');\r\n                doc.selectionStart = doc.selectionEnd = start + 1;\r\n            }\r\n        }\r\n        else {\r\n            doc.model.changeRange(start, start, '\"\"');\r\n            doc.selectionStart = doc.selectionEnd = start + 1;\r\n        }\r\n    }\r\n}\r\nfunction growSelection(doc, start = doc.selectionStart, end = doc.selectionEnd) {\r\n    let startC = doc.getTokenCursor(start);\r\n    let endC = doc.getTokenCursor(end);\r\n    if (startC.equals(endC) && !startC.withinWhitespace()) {\r\n        if (startC.getToken().type == \"close\") {\r\n            if (startC.getPrevToken().type == \"close\") {\r\n                startC.backwardList();\r\n                doc.growSelectionStack.push([doc.selectionStart = startC.offsetStart, doc.selectionEnd = endC.offsetStart]);\r\n            }\r\n            else {\r\n                endC = startC.previous();\r\n                doc.growSelectionStack.push([doc.selectionStart = startC.offsetStart, doc.selectionEnd = endC.offsetEnd]);\r\n            }\r\n        }\r\n        else if (startC.getToken().type == \"open\") {\r\n            endC.forwardList();\r\n            doc.growSelectionStack.push([doc.selectionStart = startC.offsetStart, doc.selectionEnd = endC.offsetStart]);\r\n        }\r\n        else {\r\n            doc.growSelectionStack.push([doc.selectionStart = startC.offsetStart, doc.selectionEnd = startC.offsetEnd]);\r\n        }\r\n    }\r\n    else {\r\n        if (startC.getPrevToken().type == \"open\" && endC.getToken().type == \"close\") {\r\n            startC.backwardList();\r\n            startC.backwardUpList();\r\n            endC.forwardList();\r\n            doc.growSelectionStack.push([doc.selectionStart = startC.offsetStart, doc.selectionEnd = endC.offsetEnd]);\r\n        }\r\n        else {\r\n            startC.backwardList();\r\n            endC.forwardList();\r\n            endC.previous();\r\n            doc.growSelectionStack.push([doc.selectionStart = startC.offsetStart, doc.selectionEnd = endC.offsetEnd]);\r\n        }\r\n    }\r\n}\r\nfunction shrinkSelection(doc) {\r\n    if (doc.growSelectionStack.length) {\r\n        let [start, end] = doc.growSelectionStack.pop();\r\n        if (start == doc.selectionStart && end == doc.selectionEnd && doc.growSelectionStack.length) {\r\n            [doc.selectionStart, doc.selectionEnd] = doc.growSelectionStack[doc.growSelectionStack.length - 1];\r\n        }\r\n        else {\r\n            doc.growSelectionStack = [];\r\n        }\r\n    }\r\n}\r\nfunction raiseSexp(doc, start = doc.selectionStart, end = doc.selectionEnd) {\r\n    if (start == end) {\r\n        let cursor = doc.getTokenCursor(end);\r\n        cursor.forwardWhitespace();\r\n        let endCursor = cursor.clone();\r\n        if (endCursor.forwardSexp()) {\r\n            let raised = doc.model.getText(cursor.offsetStart, endCursor.offsetStart);\r\n            cursor.backwardList();\r\n            endCursor.forwardList();\r\n            if (cursor.getPrevToken().type == \"open\") {\r\n                cursor.previous();\r\n                if (endCursor.getToken().type == \"close\") {\r\n                    doc.model.changeRange(cursor.offsetStart, endCursor.offsetEnd, raised);\r\n                    doc.selectionStart = doc.selectionEnd = cursor.offsetStart;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction convolute(doc, start = doc.selectionStart, end = doc.selectionEnd) {\r\n    if (start == end) {\r\n        let cursorStart = doc.getTokenCursor(end);\r\n        let cursorEnd = cursorStart.clone();\r\n        if (cursorStart.backwardList()) {\r\n            if (cursorEnd.forwardList()) {\r\n                let head = doc.model.getText(cursorStart.offsetStart, end);\r\n                if (cursorStart.getPrevToken().type == \"open\") {\r\n                    cursorStart.previous();\r\n                    let headStart = cursorStart.clone();\r\n                    if (headStart.backwardList() && headStart.backwardUpList()) {\r\n                        let headEnd = cursorStart.clone();\r\n                        if (headEnd.forwardList() && cursorEnd.getToken().type == \"close\") {\r\n                            doc.model.changeRange(headEnd.offsetEnd, headEnd.offsetEnd, \")\");\r\n                            doc.model.changeRange(cursorEnd.offsetStart, cursorEnd.offsetEnd, \"\");\r\n                            doc.model.changeRange(cursorStart.offsetStart, end, \"\");\r\n                            doc.model.changeRange(headStart.offsetStart, headStart.offsetStart, \"(\" + head);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/paredit.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/readline.js":
/*!**********************************************!*\
  !*** C:/code/scryetek-editor/js/readline.js ***!
  \**********************************************/
/*! exports provided: ReplReadline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReplReadline\", function() { return ReplReadline; });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ \"../../../scryetek-editor/js/model.js\");\n/* harmony import */ var _clojure_lexer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clojure-lexer */ \"../../../scryetek-editor/js/clojure-lexer.js\");\n/* harmony import */ var _token_cursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./token-cursor */ \"../../../scryetek-editor/js/token-cursor.js\");\n\r\n\r\n\r\n/** A cheesy utility canvas, used to measure the length of text. */\r\nconst canvas = document.createElement(\"canvas\");\r\nlet ctx = canvas.getContext(\"2d\");\r\n/** Returns the length of the string. */\r\nfunction measureText(str) {\r\n    return ctx.measureText(str).width;\r\n}\r\n/**\r\n * A syntax-highlighting text editor.\r\n */\r\nclass ReplReadline {\r\n    constructor(parent, prompt) {\r\n        this.parent = parent;\r\n        /** The offset of the start of the selection into the document. */\r\n        this._selectionStart = 0;\r\n        /** The offset of the end of the selection into the document. */\r\n        this._selectionEnd = 0;\r\n        /** The underlying tokenized source. */\r\n        this.model = new _model__WEBPACK_IMPORTED_MODULE_0__[\"LineInputModel\"]();\r\n        /** The HTMLDivElements in the rendered view for each line. */\r\n        this.inputLines = [];\r\n        /** The target column of the caret, for up/down movement. */\r\n        this.caretX = 0;\r\n        /** The start of the selection when we last updated the component's DOM. */\r\n        this.lastSelectionStart = 0;\r\n        /** The end of the selection when we last updated the component's DOM. */\r\n        this.lastSelectionEnd = 0;\r\n        /**\r\n         * True if we are rendering a matched parenthesis.\r\n         */\r\n        this.matchingParen = false;\r\n        this.mouseDrag = (e) => {\r\n            this.selectionEnd = this.pageToOffset(e.pageX, e.pageY);\r\n            this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n            this.repaint();\r\n        };\r\n        this.mouseUp = (e) => {\r\n            window.removeEventListener(\"mousemove\", this.mouseDrag);\r\n            window.removeEventListener(\"mouseup\", this.mouseUp);\r\n        };\r\n        this.mouseDown = (e) => {\r\n            e.preventDefault();\r\n            this.selectionStart = this.selectionEnd = this.pageToOffset(e.pageX, e.pageY);\r\n            this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n            this.repaint();\r\n            window.addEventListener(\"mousemove\", this.mouseDrag);\r\n            window.addEventListener(\"mouseup\", this.mouseUp);\r\n        };\r\n        this.growSelectionStack = [];\r\n        let wrap = this.elem = document.createElement(\"div\");\r\n        wrap.className = \"prompt-wrap\";\r\n        let promptElem = document.createElement(\"div\");\r\n        promptElem.className = \"prompt\";\r\n        promptElem.textContent = prompt;\r\n        this.mainElem = document.createElement(\"div\");\r\n        wrap.appendChild(promptElem);\r\n        wrap.appendChild(this.mainElem);\r\n        parent.appendChild(wrap);\r\n        this.mainElem.addEventListener(\"mousedown\", this.mouseDown);\r\n        this.caret = document.createElement(\"div\");\r\n        this.caret.className = \"caret\";\r\n        let line = this.makeLine();\r\n        this.inputLines.push(line);\r\n        this.mainElem.appendChild(line);\r\n        ctx.font = getComputedStyle(line).font + \"\";\r\n        this.caret.style.width = measureText(\"M\") + \"px\";\r\n        line.appendChild(this.caret);\r\n    }\r\n    /** Returns the offset of the start of the selection. */\r\n    get selectionStart() {\r\n        return this._selectionStart;\r\n    }\r\n    ;\r\n    /** Sets the start of the selection. */\r\n    set selectionStart(val) {\r\n        this._selectionStart = Math.min(this.model.maxOffset, Math.max(val, 0));\r\n    }\r\n    /** Returns the offset of the end of the selection. */\r\n    get selectionEnd() {\r\n        return this._selectionEnd;\r\n    }\r\n    ;\r\n    /** Sets the end of the selection. */\r\n    set selectionEnd(val) {\r\n        this._selectionEnd = Math.min(this.model.maxOffset, Math.max(val, 0));\r\n    }\r\n    /**\r\n     * Returns a TokenCursor into the document.\r\n     *\r\n     * @param row the line to position the cursor at.\r\n     * @param col the column to position the cursor at.\r\n     * @param previous if true, position the cursor at the previous token.\r\n     */\r\n    getTokenCursor(offset = this.selectionEnd, previous = false) {\r\n        let [row, col] = this.model.getRowCol(offset);\r\n        let line = this.model.lines[row];\r\n        let lastIndex = 0;\r\n        if (line) {\r\n            for (let i = 0; i < line.tokens.length; i++) {\r\n                let tk = line.tokens[i];\r\n                if (previous ? tk.offset > col : tk.offset > col)\r\n                    return new _token_cursor__WEBPACK_IMPORTED_MODULE_2__[\"LispTokenCursor\"](this.model, row, previous ? Math.max(0, lastIndex - 1) : lastIndex);\r\n                lastIndex = i;\r\n            }\r\n            return new _token_cursor__WEBPACK_IMPORTED_MODULE_2__[\"LispTokenCursor\"](this.model, row, line.tokens.length - 1);\r\n        }\r\n    }\r\n    /**\r\n     * Executes a block of code, during which any edits that are performed on the document will be created with Undo support.\r\n     * This should happen almost all of the time- in fact the only time it shouldn't is when replaying undo/redo operations.\r\n     *\r\n     * FIXME: Perhaps this should be \"withoutUndo\"?\r\n     *\r\n     * @param body the code to execute.\r\n     */\r\n    withUndo(body) {\r\n        let oldUndo = this.model.recordingUndo;\r\n        try {\r\n            this.model.recordingUndo = true;\r\n            this.model.undoManager.withUndo(body);\r\n        }\r\n        finally {\r\n            this.model.recordingUndo = oldUndo;\r\n        }\r\n    }\r\n    /**\r\n     * Inserts a string at the current cursor location.\r\n     *\r\n     * FIXME: this should just be `changeRange`.\r\n     * @param text the text to insert\r\n     */\r\n    insertString(text) {\r\n        this.withUndo(() => {\r\n            if (this.selectionStart != this.selectionEnd) {\r\n                this.deleteSelection();\r\n            }\r\n            let [cs, ce] = [this.selectionStart, this.selectionEnd];\r\n            this.selectionEnd += this.model.insertString(this.selectionEnd, text, [cs, ce], [cs + text.length, cs + text.length]);\r\n            this.selectionStart = this.selectionEnd;\r\n            this.repaint();\r\n            this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n        });\r\n    }\r\n    /**\r\n     * Moves the caret left one character, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretLeft(clear = true) {\r\n        if (clear && this.selectionStart != this.selectionEnd) {\r\n            if (this.selectionStart < this.selectionEnd)\r\n                this.selectionEnd = this.selectionStart;\r\n            else\r\n                this.selectionStart = this.selectionEnd;\r\n        }\r\n        else {\r\n            this.selectionEnd--;\r\n            if (clear)\r\n                this.selectionStart = this.selectionEnd;\r\n        }\r\n        this.repaint();\r\n        this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n    }\r\n    /**\r\n     * Moves the caret right one character, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretRight(clear = true) {\r\n        if (clear && this.selectionStart != this.selectionEnd) {\r\n            if (this.selectionStart > this.selectionEnd)\r\n                this.selectionEnd = this.selectionStart;\r\n            else\r\n                this.selectionStart = this.selectionEnd;\r\n        }\r\n        else {\r\n            this.selectionEnd++;\r\n            if (clear)\r\n                this.selectionStart = this.selectionEnd;\r\n        }\r\n        this.repaint();\r\n        this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n    }\r\n    /**\r\n     * Moves the caret to the beginning of the document, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretHomeAll(clear = true) {\r\n        this.selectionEnd = 0;\r\n        if (clear)\r\n            this.selectionStart = this.selectionEnd;\r\n        this.repaint();\r\n        this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n    }\r\n    /**\r\n     * Moves the caret to the end of the document, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretEndAll(clear = true) {\r\n        this.selectionEnd = this.model.maxOffset;\r\n        if (clear)\r\n            this.selectionStart = this.selectionEnd;\r\n        this.repaint();\r\n        this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n    }\r\n    /**\r\n     * Moves the caret to the beginning of the line, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretHome(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.selectionEnd);\r\n        this.selectionEnd = this.selectionEnd - col;\r\n        if (clear)\r\n            this.selectionStart = this.selectionEnd;\r\n        this.repaint();\r\n        this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n    }\r\n    /**\r\n     * Moves the caret to the end of the line, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretEnd(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.selectionEnd);\r\n        this.selectionEnd = this.selectionEnd - col + this.model.lines[row].text.length;\r\n        if (clear)\r\n            this.selectionStart = this.selectionEnd;\r\n        this.repaint();\r\n        this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n    }\r\n    /**\r\n     * Moves the caret to the previous line, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretUp(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.selectionEnd);\r\n        if (row > 0) {\r\n            let len = this.model.lines[row - 1].text.length;\r\n            this.selectionEnd = this.model.getOffsetForLine(row - 1) + Math.min(this.caretX, len);\r\n        }\r\n        else {\r\n            this.selectionEnd = 0;\r\n        }\r\n        if (clear)\r\n            this.selectionStart = this.selectionEnd;\r\n        this.repaint();\r\n    }\r\n    /**\r\n     * Moves the caret to the next line, using text editor semantics.\r\n     *\r\n     * @param clear if true, clears the current selection, if any, otherwise moves `cursorEnd` only.\r\n     */\r\n    caretDown(clear = true) {\r\n        let [row, col] = this.model.getRowCol(this.selectionEnd);\r\n        if (row < this.model.lines.length - 1) {\r\n            let len = this.model.lines[row + 1].text.length;\r\n            this.selectionEnd = this.model.getOffsetForLine(row + 1) + Math.min(this.caretX, len);\r\n        }\r\n        else {\r\n            this.selectionEnd = this.model.maxOffset;\r\n        }\r\n        if (clear)\r\n            this.selectionStart = this.selectionEnd;\r\n        this.repaint();\r\n    }\r\n    /**\r\n     * Deletes the current selection.\r\n     *\r\n     * FIXME: this should just be `changeRange`\r\n     */\r\n    deleteSelection() {\r\n        this.withUndo(() => {\r\n            if (this.selectionStart != this.selectionEnd) {\r\n                this.model.deleteRange(Math.min(this.selectionStart, this.selectionEnd), Math.max(this.selectionStart, this.selectionEnd) - Math.min(this.selectionStart, this.selectionEnd));\r\n                this.selectionStart = this.selectionEnd = Math.min(this.selectionStart, this.selectionEnd);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * If there is no selection- deletes the character to the left of the cursor and moves it back one character.\r\n     *\r\n     * If there is a selection, deletes the selection.\r\n     */\r\n    backspace() {\r\n        this.withUndo(() => {\r\n            if (this.selectionStart != this.selectionEnd) {\r\n                this.deleteSelection();\r\n            }\r\n            else {\r\n                if (this.selectionEnd > 0) {\r\n                    this.model.deleteRange(this.selectionEnd - 1, 1, [this.selectionStart, this.selectionEnd], [this.selectionEnd - 1, this.selectionEnd - 1]);\r\n                    this.selectionEnd--;\r\n                }\r\n                this.selectionStart = this.selectionEnd;\r\n            }\r\n            this.repaint();\r\n            this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n        });\r\n    }\r\n    /**\r\n     * If there is no selection- deletes the character to the right of the cursor.\r\n     *\r\n     * If there is a selection, deletes the selection.\r\n     */\r\n    delete() {\r\n        this.withUndo(() => {\r\n            if (this.selectionStart != this.selectionEnd) {\r\n                this.deleteSelection();\r\n            }\r\n            else {\r\n                this.model.deleteRange(this.selectionEnd, 1);\r\n                this.selectionStart = this.selectionEnd;\r\n            }\r\n            this.caretX = this.model.getRowCol(this.selectionEnd)[1];\r\n            this.repaint();\r\n        });\r\n    }\r\n    /**\r\n     * Construct a selection marker div.\r\n     * @param start the left hand side start position in pixels.\r\n     * @param width the width of the marker, in pixels.\r\n     */\r\n    makeSelection(start, width) {\r\n        let div = document.createElement(\"div\");\r\n        div.className = \"sel-marker\";\r\n        let left = start;\r\n        div.style.left = left + \"px\";\r\n        div.style.width = width + \"px\";\r\n        return div;\r\n    }\r\n    /**\r\n     * Clears the rendering for matching parenthesis.\r\n     */\r\n    clearParenMatches() {\r\n        let cp = this.getElementForToken(this.closeParen);\r\n        if (cp) {\r\n            cp.classList.remove(\"match\");\r\n            cp.classList.remove(\"match-fail\");\r\n        }\r\n        let op = this.getElementForToken(this.openParen);\r\n        if (op) {\r\n            op.classList.remove(\"match\");\r\n            op.classList.remove(\"match-fail\");\r\n        }\r\n        this.closeParen = null;\r\n        this.openParen = null;\r\n    }\r\n    /**\r\n     * Sets the rendering for matching parenthesis.\r\n     */\r\n    updateParenMatches() {\r\n        let cursor = this.getTokenCursor();\r\n        if (cursor.getToken().type == \"close\") {\r\n            this.closeParen = cursor.clone();\r\n            while (cursor.backwardSexp())\r\n                ;\r\n            if (cursor.getPrevToken().type == \"open\") {\r\n                this.openParen = cursor.previous();\r\n            }\r\n            if (this.closeParen && this.openParen)\r\n                this.matchingParen = Object(_clojure_lexer__WEBPACK_IMPORTED_MODULE_1__[\"validPair\"])(this.openParen.getToken().raw, this.closeParen.getToken().raw);\r\n            else\r\n                this.matchingParen = false;\r\n        }\r\n        else if (cursor.getToken().type == \"open\") {\r\n            this.openParen = cursor.clone();\r\n            cursor.next();\r\n            while (cursor.forwardSexp())\r\n                ;\r\n            if (cursor.getToken().type == \"close\") {\r\n                this.closeParen = cursor;\r\n            }\r\n            if (this.closeParen && this.openParen)\r\n                this.matchingParen = Object(_clojure_lexer__WEBPACK_IMPORTED_MODULE_1__[\"validPair\"])(this.openParen.getToken().raw, this.closeParen.getToken().raw);\r\n            else\r\n                this.matchingParen = false;\r\n        }\r\n        let cp = this.getElementForToken(this.closeParen);\r\n        if (cp) {\r\n            if (this.matchingParen)\r\n                cp.classList.add(\"match\");\r\n            else\r\n                cp.classList.add(\"fail-match\");\r\n        }\r\n        let op = this.getElementForToken(this.openParen);\r\n        if (op) {\r\n            if (this.matchingParen)\r\n                op.classList.add(\"match\");\r\n            else\r\n                op.classList.add(\"fail-match\");\r\n        }\r\n    }\r\n    /**\r\n     * Given a TokenCursor, returns the HTMLElement that is rendered for this token.\r\n     * @param cursor\r\n     */\r\n    getElementForToken(cursor) {\r\n        if (cursor && this.inputLines[cursor.line])\r\n            return this.inputLines[cursor.line].querySelector(\".content\").children.item(cursor.token);\r\n    }\r\n    /**\r\n     * Update the DOM for the editor. After a change in the model or local editor information (e.g. cursor position), we apply the changes,\r\n     * attempting to minimize the work.\r\n     */\r\n    repaint() {\r\n        this.clearParenMatches();\r\n        this.model.flushChanges();\r\n        // remove any deleted lines\r\n        for (let [start, count] of this.model.deletedLines) {\r\n            for (let j = 0; j < count; j++)\r\n                this.mainElem.removeChild(this.inputLines[start + j]);\r\n            this.inputLines.splice(start, count);\r\n        }\r\n        this.model.deletedLines.clear();\r\n        // insert any new lines\r\n        for (let [start, count] of this.model.insertedLines) {\r\n            for (let j = 0; j < count; j++) {\r\n                let line = this.makeLine();\r\n                if (!this.inputLines[start + j])\r\n                    this.mainElem.append(line);\r\n                else\r\n                    this.mainElem.insertBefore(line, this.inputLines[start + j]);\r\n                this.inputLines.splice(start + j, 0, line);\r\n            }\r\n        }\r\n        this.model.insertedLines.clear();\r\n        // update changed lines\r\n        for (let line of this.model.changedLines) {\r\n            let ln = this.inputLines[line].querySelector(\".content\");\r\n            while (ln.firstChild)\r\n                ln.removeChild(ln.firstChild);\r\n            for (let tk of this.model.lines[line].tokens) {\r\n                if (!tk)\r\n                    break;\r\n                ln.appendChild(makeToken(tk));\r\n            }\r\n            if (!ln.firstChild)\r\n                ln.appendChild(document.createTextNode(\" \")); // otherwise the line will collapse to height=0 due to html fun.\r\n        }\r\n        this.model.changedLines.clear();\r\n        // reposition the caret\r\n        let [row, col] = this.model.getRowCol(this.selectionEnd);\r\n        this.inputLines[row].appendChild(this.caret);\r\n        let style = getComputedStyle(this.inputLines[row]);\r\n        ctx.font = style.fontStyle + \" \" + style.fontSize + \" \" + style.fontFamily;\r\n        this.caret.style.left = measureText(this.model.lines[row].text.substr(0, col)) + \"px\";\r\n        let startLine = this.model.getRowCol(Math.min(this.lastSelectionStart, this.lastSelectionEnd, this.selectionStart, this.selectionEnd));\r\n        let endLine = this.model.getRowCol(Math.max(this.lastSelectionStart, this.lastSelectionEnd, this.selectionStart, this.selectionEnd));\r\n        let cs = this.model.getRowCol(Math.min(this.selectionStart, this.selectionEnd));\r\n        let ce = this.model.getRowCol(Math.max(this.selectionStart, this.selectionEnd));\r\n        let lcs = this.model.getRowCol(Math.min(this.lastSelectionStart, this.lastSelectionEnd));\r\n        let lce = this.model.getRowCol(Math.max(this.lastSelectionStart, this.lastSelectionEnd));\r\n        // update the selection\r\n        for (let line = startLine[0]; line <= endLine[0]; line++) {\r\n            let ln = this.inputLines[line].querySelector(\".selection\");\r\n            if (line < cs[0] || line > ce[0]) {\r\n                // definitely outside the selection, nuke all the selectiond divs.\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n            }\r\n            else if (line == cs[0] && line == ce[0]) {\r\n                // this selection is exactly 1 line, and we're at it.\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n                let left = measureText(\"M\") * cs[1];\r\n                ln.appendChild(this.makeSelection(left, measureText(\"M\") * ce[1] - left));\r\n            }\r\n            else if (line == cs[0]) {\r\n                // this is the first line of the selection\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n                let left = measureText(\"M\") * cs[1];\r\n                ln.appendChild(this.makeSelection(left, measureText(\"M\") * this.model.lines[line].text.length - left));\r\n            }\r\n            else if (line == ce[0]) {\r\n                // this is the last line of the selection\r\n                while (ln.firstChild)\r\n                    ln.removeChild(ln.firstChild);\r\n                ln.appendChild(this.makeSelection(0, measureText(\"M\") * ce[1]));\r\n            }\r\n            else if (line > cs[0] && line < ce[0]) {\r\n                // this line is within the selection, but is not the first or last.\r\n                if (line > lcs[0] && line < lce[0]) {\r\n                    // this line was within the selection previously, it is already highlighted,\r\n                    // nothing to do.\r\n                }\r\n                else if (line >= cs[0] && line <= ce[0]) {\r\n                    // this line is newly within the selection\r\n                    while (ln.firstChild)\r\n                        ln.removeChild(ln.firstChild);\r\n                    ln.appendChild(this.makeSelection(0, Math.max(measureText(\"M\"), measureText(\"M\") * this.model.lines[line].text.length)));\r\n                }\r\n                else {\r\n                    // this line is no longer within the selection\r\n                    while (ln.firstChild)\r\n                        ln.removeChild(ln.firstChild);\r\n                }\r\n            }\r\n        }\r\n        this.lastSelectionStart = this.selectionStart;\r\n        this.lastSelectionEnd = this.selectionEnd;\r\n        this.updateParenMatches();\r\n    }\r\n    /** Given a (pageX, pageY) pixel coordinate, returns the character offset into this document. */\r\n    pageToOffset(pageX, pageY) {\r\n        let rect = this.mainElem.getBoundingClientRect();\r\n        let y = pageY - (rect.top + window.scrollY);\r\n        let i;\r\n        // NOTE: assuming every line is a fixed size, this could be O(1).\r\n        // on the other hand, this seems quite fast for now.\r\n        for (i = 0; i < this.mainElem.children.length; i++) {\r\n            let child = this.mainElem.children.item(i);\r\n            if (y < child.offsetTop)\r\n                break;\r\n        }\r\n        i--;\r\n        if (i < 0)\r\n            return 0;\r\n        let offset = this.model.getOffsetForLine(i);\r\n        offset += Math.min(Math.floor((pageX - rect.left) / measureText(\"M\")), this.model.lines[i].text.length);\r\n        return offset;\r\n    }\r\n    makeLine() {\r\n        let line = document.createElement(\"div\");\r\n        line.className = \"line\";\r\n        let content = document.createElement(\"div\");\r\n        content.className = \"content\";\r\n        line.append(content);\r\n        let selection = document.createElement(\"div\");\r\n        selection.className = \"selection\";\r\n        line.append(selection);\r\n        return line;\r\n    }\r\n    canReturn() {\r\n        return this.selectionEnd == this.selectionStart && this.selectionEnd == this.model.maxOffset;\r\n    }\r\n    freeze() {\r\n        this.mainElem.removeEventListener(\"mousedown\", this.mouseDown);\r\n        window.removeEventListener(\"mouseup\", this.mouseUp);\r\n        window.removeEventListener(\"mousemove\", this.mouseDrag);\r\n        this.selectionStart = this.selectionEnd = this.model.maxOffset;\r\n        this.repaint();\r\n        this.caret.parentElement.removeChild(this.caret);\r\n    }\r\n    doReturn() {\r\n        this.freeze();\r\n    }\r\n}\r\n/**\r\n * A set of tokens which should be highlighted as macros.\r\n */\r\nconst macros = new Set([\"if\", \"let\", \"do\", \"while\", \"cond\", \"case\"]);\r\n/**\r\n * Constructs an HTMLElement to represent a token with the correct syntax highlighting.\r\n * @param tk the token to construct.\r\n */\r\nfunction makeToken(tk) {\r\n    let span = document.createElement(\"span\");\r\n    let className = tk.type;\r\n    if (tk.type == \"id\") {\r\n        if (tk.raw.startsWith(\"def\"))\r\n            className = \"decl\";\r\n        else if (macros.has(tk.raw))\r\n            className = \"macro\";\r\n    }\r\n    span.textContent = tk.raw;\r\n    span.className = className;\r\n    return span;\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/readline.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/repl-console.js":
/*!**************************************************!*\
  !*** C:/code/scryetek-editor/js/repl-console.js ***!
  \**************************************************/
/*! exports provided: ReplConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReplConsole\", function() { return ReplConsole; });\n/* harmony import */ var _readline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./readline */ \"../../../scryetek-editor/js/readline.js\");\n/* harmony import */ var _paredit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./paredit */ \"../../../scryetek-editor/js/paredit.js\");\n/* harmony import */ var _indent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./indent */ \"../../../scryetek-editor/js/indent.js\");\n/* harmony import */ var _hotkeys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hotkeys */ \"../../../scryetek-editor/js/hotkeys.js\");\n\r\n\r\n\r\n\r\nconst defaultHotkeys = new _hotkeys__WEBPACK_IMPORTED_MODULE_3__[\"HotKeyTable\"]({\r\n    \"Alt+R\": \"raise-sexp\",\r\n    \"Alt+Shift+/\": \"convolute-sexp\",\r\n    \"Alt+Backspace\": \"force-backspace\",\r\n    \"Ctrl+Shift+Space\": \"grow-selection\",\r\n    \"Ctrl+Alt+Shift+Space\": \"shrink-selection\",\r\n    \"Alt+Delete\": \"force-delete\",\r\n    \"Ctrl+LeftArrow\": \"backward-sexp\",\r\n    \"Ctrl+RightArrow\": \"forward-sexp\",\r\n    \"Ctrl+DownArrow\": \"down-list\",\r\n    \"Ctrl+Shift+UpArrow\": \"up-list\",\r\n    \"Ctrl+UpArrow\": \"backward-up-list\",\r\n    \"Cmd+A\": \"select-all\",\r\n    \"Cmd+Z\": \"undo\",\r\n    \"Cmd+Shift+Z\": \"redo\",\r\n    \"Alt+Shift+J\": \"join-sexp\",\r\n    \"Alt+Shift+Cmd+LeftArrow\": \"backward-slurp-sexp\",\r\n    \"Alt+Cmd+LeftArrow\": \"forward-barf-sexp\",\r\n    \"LeftArrow\": \"cursor-left\",\r\n    \"Shift+LeftArrow\": \"cursor-select-left\",\r\n    \"Alt+Shift+Cmd+RightArrow\": \"forward-slurp-sexp\",\r\n    \"Alt+Cmd+RightArrow\": \"backward-barf-sexp\",\r\n    \"RightArrow\": \"cursor-right\",\r\n    \"Shift+RightArrow\": \"cursor-select-right\",\r\n    \"Alt+LeftArrow\": \"splice-sexp-killing-backwards\",\r\n    \"UpArrow\": \"cursor-up\",\r\n    \"Shift+UpArrow\": \"cursor-select-up\",\r\n    \"Alt+RightArrow\": \"splice-sexp-killing-forwards\",\r\n    \"DownArrow\": \"cursor-down\",\r\n    \"Shift+DownArrow\": \"cursor-select-down\",\r\n    \"Backspace\": \"backspace\",\r\n    \"Home\": \"cursor-home\",\r\n    \"Shift+Home\": \"cursor-select-home\",\r\n    \"Ctrl+Home\": \"cursor-home-all\",\r\n    \"Shift+Ctrl+Home\": \"cursor-select-home-all\",\r\n    \"End\": \"cursor-end\",\r\n    \"Shift+End\": \"cursor-select-end\",\r\n    \"Ctrl+End\": \"cursor-end-all\",\r\n    \"Shift+Ctrl+End\": \"cursor-select-end-all\",\r\n    \"Delete\": \"delete\",\r\n    \"Alt+Shift+9\": \"wrap-round\",\r\n    \"Alt+[\": \"wrap-square\",\r\n    \"Alt+Shift+[\": \"wrap-curly\",\r\n    \"Alt+Shift+S\": \"split-sexp\",\r\n    \"Alt+S\": \"splice-sexp\",\r\n    \"Alt+UpArrow\": \"history-up\",\r\n    \"Alt+DownArrow\": \"history-down\",\r\n});\r\nclass ReplConsole {\r\n    constructor(elem, onReadLine = () => { }) {\r\n        this.elem = elem;\r\n        this.onReadLine = onReadLine;\r\n        this.historyIndex = -1;\r\n        this.history = [];\r\n        this.commands = {\r\n            \"raise-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"raiseSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"convolute-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"convolute\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"force-backspace\": () => {\r\n                this.readline.withUndo(() => {\r\n                    this.readline.backspace();\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"force-delete\": () => {\r\n                this.readline.withUndo(() => {\r\n                    this.readline.delete();\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"grow-selection\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"growSelection\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"shrink-selection\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"shrinkSelection\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"backward-sexp\": () => {\r\n                let cursor = this.readline.getTokenCursor();\r\n                cursor.backwardSexp(true);\r\n                this.readline.selectionStart = this.readline.selectionEnd = cursor.offsetStart;\r\n                this.readline.repaint();\r\n            },\r\n            \"forward-sexp\": () => {\r\n                let cursor = this.readline.getTokenCursor();\r\n                cursor.forwardSexp(true);\r\n                this.readline.selectionStart = this.readline.selectionEnd = cursor.offsetStart;\r\n                this.readline.repaint();\r\n            },\r\n            \"down-list\": () => {\r\n                let cursor = this.readline.getTokenCursor();\r\n                do {\r\n                    cursor.forwardWhitespace();\r\n                } while (cursor.getToken().type != \"open\" && cursor.forwardSexp());\r\n                { }\r\n                cursor.downList();\r\n                this.readline.selectionStart = this.readline.selectionEnd = cursor.offsetStart;\r\n                this.readline.repaint();\r\n            },\r\n            \"up-list\": () => {\r\n                let cursor = this.readline.getTokenCursor();\r\n                cursor.forwardList();\r\n                cursor.upList();\r\n                this.readline.selectionStart = this.readline.selectionEnd = cursor.offsetStart;\r\n                this.readline.repaint();\r\n            },\r\n            \"backward-up-list\": () => {\r\n                let cursor = this.readline.getTokenCursor();\r\n                cursor.backwardList();\r\n                cursor.backwardUpList();\r\n                this.readline.selectionStart = this.readline.selectionEnd = cursor.offsetStart;\r\n                this.readline.repaint();\r\n            },\r\n            \"select-all\": () => {\r\n                this.readline.selectionStart = 0;\r\n                this.readline.selectionEnd = this.readline.model.maxOffset;\r\n                this.readline.repaint();\r\n            },\r\n            \"undo\": () => {\r\n                this.readline.model.undoManager.undo(this.readline);\r\n                this.readline.repaint();\r\n            },\r\n            \"redo\": () => {\r\n                this.readline.model.undoManager.redo(this.readline);\r\n                this.readline.repaint();\r\n            },\r\n            \"join-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"joinSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"backward-slurp-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"backwardSlurpSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"forward-barf-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"forwardBarfSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"cursor-left\": () => {\r\n                this.readline.caretLeft(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-left\": () => {\r\n                this.readline.caretLeft(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"forward-slurp-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"forwardSlurpSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"backward-barf-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"backwardBarfSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"cursor-right\": () => {\r\n                this.readline.caretRight(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-right\": () => {\r\n                this.readline.caretRight(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"splice-sexp-killing-backwards\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"spliceSexpKillingBackward\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"cursor-up\": () => {\r\n                this.readline.caretUp(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-up\": () => {\r\n                this.readline.caretUp(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"splice-sexp-killing-forwards\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"spliceSexpKillingForward\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"cursor-down\": () => {\r\n                this.readline.caretDown(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-down\": () => {\r\n                this.readline.caretDown(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"backspace\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"backspace\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"cursor-home\": () => {\r\n                this.readline.caretHome(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-home\": () => {\r\n                this.readline.caretHome(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-home-all\": () => {\r\n                this.readline.caretHomeAll(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-home-all\": () => {\r\n                this.readline.caretHomeAll(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-end\": () => {\r\n                this.readline.caretEnd(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-end\": () => {\r\n                this.readline.caretEnd(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-end-all\": () => {\r\n                this.readline.caretEndAll(true);\r\n                this.readline.repaint();\r\n            },\r\n            \"cursor-select-end-all\": () => {\r\n                this.readline.caretEndAll(false);\r\n                this.readline.repaint();\r\n            },\r\n            \"delete\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"deleteForward\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"wrap-round\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"wrapSexpr\"](this.readline, \"(\", \")\");\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"wrap-square\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"wrapSexpr\"](this.readline, \"[\", \"]\");\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"wrap-curly\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"wrapSexpr\"](this.readline, \"{\", \"}\");\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"split-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"splitSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"splice-sexp\": () => {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"spliceSexp\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n            },\r\n            \"history-up\": () => {\r\n                if (this.historyIndex == 0)\r\n                    return;\r\n                if (this.historyIndex == -1)\r\n                    this.historyIndex = this.history.length;\r\n                this.historyIndex--;\r\n                let line = this.history[this.historyIndex] || \"\";\r\n                this.readline.withUndo(() => {\r\n                    this.readline.model.changeRange(0, this.readline.model.maxOffset, line);\r\n                    this.readline.selectionStart = this.readline.selectionEnd = line.length;\r\n                });\r\n                this.readline.repaint();\r\n            },\r\n            \"history-down\": () => {\r\n                if (this.historyIndex == this.history.length || this.historyIndex == -1)\r\n                    return;\r\n                this.historyIndex++;\r\n                let line = this.history[this.historyIndex] || \"\";\r\n                this.readline.withUndo(() => {\r\n                    this.readline.model.changeRange(0, this.readline.model.maxOffset, line);\r\n                    this.readline.selectionStart = this.readline.selectionEnd = line.length;\r\n                });\r\n                this.readline.repaint();\r\n            }\r\n        };\r\n        this.hotkeys = defaultHotkeys;\r\n        this.input = document.createElement(\"input\");\r\n        this.input.style.width = \"0px\";\r\n        this.input.style.height = \"0px\";\r\n        this.input.style.position = \"fixed\";\r\n        this.input.style.opacity = \"0\";\r\n        document.addEventListener(\"cut\", e => {\r\n            if (document.activeElement == this.input) {\r\n                e.clipboardData.setData(\"text/plain\", this.readline.model.getText(this.readline.selectionStart, this.readline.selectionEnd));\r\n                this.readline.delete();\r\n                e.preventDefault();\r\n            }\r\n        });\r\n        document.addEventListener(\"copy\", e => {\r\n            if (document.activeElement == this.input) {\r\n                e.clipboardData.setData(\"text/plain\", this.readline.model.getText(this.readline.selectionStart, this.readline.selectionEnd));\r\n                e.preventDefault();\r\n            }\r\n        });\r\n        document.addEventListener(\"paste\", e => {\r\n            if (document.activeElement == this.input) {\r\n                this.readline.model.undoManager.insertUndoStop();\r\n                this.readline.insertString(e.clipboardData.getData(\"text/plain\"));\r\n                e.preventDefault();\r\n            }\r\n        });\r\n        this.elem.addEventListener(\"click\", e => {\r\n            this.input.focus();\r\n        });\r\n        this.input.addEventListener(\"keydown\", e => {\r\n            if (this.hotkeys.execute(this, e)) {\r\n                e.preventDefault();\r\n                this.readline.mainElem.scrollIntoView({ block: \"end\" });\r\n                return;\r\n            }\r\n            if (e.key.length == 1 && !e.metaKey && !e.ctrlKey) {\r\n                if (e.key == \" \")\r\n                    this.readline.model.undoManager.insertUndoStop();\r\n            }\r\n            else {\r\n                switch (e.keyCode) {\r\n                    case 9: // Tab\r\n                        e.preventDefault();\r\n                        break;\r\n                    case 13:\r\n                        if (this.readline.canReturn()) {\r\n                            this.submitLine();\r\n                        }\r\n                        else {\r\n                            this.readline.model.undoManager.insertUndoStop();\r\n                            let indent = Object(_indent__WEBPACK_IMPORTED_MODULE_2__[\"getIndent\"])(this.readline, this.readline.selectionEnd);\r\n                            let istr = \"\";\r\n                            for (let i = 0; i < indent; i++)\r\n                                istr += \" \";\r\n                            this.readline.insertString(\"\\n\" + istr);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            this.readline.mainElem.scrollIntoView({ block: \"end\" });\r\n        }, { capture: true });\r\n        this.input.addEventListener(\"input\", e => {\r\n            this.readline.mainElem.scrollIntoView({ block: \"end\" });\r\n            if (this.input.value == '\"') {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"stringQuote\"](this.readline);\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \"(\") {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"open\"](this.readline, \"()\");\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \"[\") {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"open\"](this.readline, \"[]\");\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \"{\") {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"open\"](this.readline, \"{}\");\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \"{\") {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"open\"](this.readline, \"{}\");\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \")\") {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"close\"](this.readline, \")\");\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \"]\") {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"close\"](this.readline, \"]\");\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \"}\") {\r\n                this.readline.withUndo(() => {\r\n                    _paredit__WEBPACK_IMPORTED_MODULE_1__[\"close\"](this.readline, \"}\");\r\n                    this.readline.repaint();\r\n                });\r\n                e.preventDefault();\r\n            }\r\n            else if (this.input.value == \"\\n\") {\r\n                if (this.readline.canReturn()) {\r\n                    this.submitLine();\r\n                }\r\n                else {\r\n                    this.readline.model.undoManager.insertUndoStop();\r\n                    let indent = Object(_indent__WEBPACK_IMPORTED_MODULE_2__[\"getIndent\"])(this.readline, this.readline.selectionEnd);\r\n                    let istr = \"\";\r\n                    for (let i = 0; i < indent; i++)\r\n                        istr += \" \";\r\n                    this.readline.insertString(\"\\n\" + istr);\r\n                }\r\n            }\r\n            else {\r\n                this.readline.insertString(this.input.value);\r\n            }\r\n            this.input.value = \"\";\r\n            e.preventDefault();\r\n            this.readline.mainElem.scrollIntoView({ block: \"end\" });\r\n        });\r\n    }\r\n    printElement(element) {\r\n        if (!this.readline || this.input.disabled) {\r\n            this.elem.appendChild(element);\r\n        }\r\n        else {\r\n            this.elem.insertBefore(element, this.readline.elem);\r\n        }\r\n        this.elem.lastElementChild.scrollIntoView({ block: \"end\" });\r\n    }\r\n    print(text) {\r\n        let el = document.createElement(\"div\");\r\n        el.textContent = text;\r\n        el.className = \"output\";\r\n        this.printElement(el);\r\n    }\r\n    submitLine() {\r\n        let line = this.readline.model.getText(0, this.readline.model.maxOffset);\r\n        if (line.trim() == \"\")\r\n            return;\r\n        this.history.push(line);\r\n        this.historyIndex = -1;\r\n        this.readline.freeze();\r\n        this.input.disabled = true;\r\n        this.onReadLine(line);\r\n    }\r\n    requestPrompt(prompt) {\r\n        if (this.readline && !this.input.disabled)\r\n            return;\r\n        this.readline = new _readline__WEBPACK_IMPORTED_MODULE_0__[\"ReplReadline\"](this.elem, prompt);\r\n        this.elem.appendChild(this.input);\r\n        this.input.disabled = false;\r\n        this.input.focus();\r\n        this.readline.mainElem.scrollIntoView({ block: \"end\" });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/repl-console.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/token-cursor.js":
/*!**************************************************!*\
  !*** C:/code/scryetek-editor/js/token-cursor.js ***!
  \**************************************************/
/*! exports provided: TokenCursor, LispTokenCursor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenCursor\", function() { return TokenCursor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LispTokenCursor\", function() { return LispTokenCursor; });\n/**\r\n * A mutable cursor into the token stream.\r\n */\r\nclass TokenCursor {\r\n    constructor(doc, line, token) {\r\n        this.doc = doc;\r\n        this.line = line;\r\n        this.token = token;\r\n    }\r\n    /** Create a copy of this cursor. */\r\n    clone() {\r\n        return new TokenCursor(this.doc, this.line, this.token);\r\n    }\r\n    /**\r\n     * Sets this TokenCursor state to the same as another.\r\n     * @param cursor the cursor to copy state from.\r\n     */\r\n    set(cursor) {\r\n        this.doc = cursor.doc;\r\n        this.line = cursor.line;\r\n        this.token = cursor.token;\r\n    }\r\n    /** Return the position */\r\n    get rowCol() {\r\n        return [this.line, this.getToken().offset];\r\n    }\r\n    /** Return the offset at the start of the token */\r\n    get offsetStart() {\r\n        return this.doc.getOffsetForLine(this.line) + this.getToken().offset;\r\n    }\r\n    /** Return the offset at the end of the token */\r\n    get offsetEnd() {\r\n        return Math.min(this.doc.maxOffset, this.doc.getOffsetForLine(this.line) + this.getToken().offset + this.getToken().raw.length);\r\n    }\r\n    /** True if we are at the start of the document */\r\n    atStart() {\r\n        return this.token == 0 && this.line == 0;\r\n    }\r\n    /** True if we are at the end of the document */\r\n    atEnd() {\r\n        return this.line == this.doc.lines.length - 1 && this.token == this.doc.lines[this.line].tokens.length - 1;\r\n    }\r\n    /** Move this cursor backwards one token */\r\n    previous() {\r\n        if (this.token > 0) {\r\n            this.token--;\r\n        }\r\n        else {\r\n            if (this.line == 0)\r\n                return;\r\n            this.line--;\r\n            this.token = this.doc.lines[this.line].tokens.length - 1;\r\n        }\r\n        return this;\r\n    }\r\n    /** Move this cursor forwards one token */\r\n    next() {\r\n        if (this.token < this.doc.lines[this.line].tokens.length - 1) {\r\n            this.token++;\r\n        }\r\n        else {\r\n            if (this.line == this.doc.lines.length - 1)\r\n                return;\r\n            this.line++;\r\n            this.token = 0;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Return the token immediately preceding this cursor. At the start of the file, a token of type \"eol\" is returned.\r\n     */\r\n    getPrevToken() {\r\n        if (this.line == 0 && this.token == 0)\r\n            return { type: \"eol\", raw: \"\\n\", offset: 0, state: null };\r\n        let cursor = this.clone();\r\n        cursor.previous();\r\n        return cursor.getToken();\r\n    }\r\n    /**\r\n     * Returns the token at this cursor position.\r\n     */\r\n    getToken() {\r\n        return this.doc.lines[this.line].tokens[this.token];\r\n    }\r\n    equals(cursor) {\r\n        return this.line == cursor.line && this.token == cursor.token && this.doc == cursor.doc;\r\n    }\r\n}\r\nclass LispTokenCursor extends TokenCursor {\r\n    constructor(doc, line, token) {\r\n        super(doc, line, token);\r\n        this.doc = doc;\r\n        this.line = line;\r\n        this.token = token;\r\n    }\r\n    /** Create a copy of this cursor. */\r\n    clone() {\r\n        return new LispTokenCursor(this.doc, this.line, this.token);\r\n    }\r\n    /**\r\n     * Moves this token past the inside of a multiline string\r\n     */\r\n    fowardString() {\r\n        while (!this.atEnd()) {\r\n            switch (this.getToken().type) {\r\n                case \"eol\":\r\n                case \"str-inside\":\r\n                case \"str-start\":\r\n                    this.next();\r\n                    continue;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Moves this token past any whitespace or comment.\r\n     */\r\n    forwardWhitespace(includeComments = true) {\r\n        while (!this.atEnd()) {\r\n            switch (this.getToken().type) {\r\n                case \"comment\":\r\n                    if (!includeComments)\r\n                        return;\r\n                case \"eol\":\r\n                case \"ws\":\r\n                    this.next();\r\n                    continue;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Moves this token back past any whitespace or comment.\r\n     */\r\n    backwardWhitespace(includeComments = true) {\r\n        while (!this.atStart()) {\r\n            switch (this.getPrevToken().type) {\r\n                case \"comment\":\r\n                    if (!includeComments)\r\n                        return;\r\n                case \"eol\":\r\n                    this.previous();\r\n                    if (this.getPrevToken().type == \"comment\") {\r\n                        this.next();\r\n                        return;\r\n                    }\r\n                    continue;\r\n                case \"ws\":\r\n                    this.previous();\r\n                    continue;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n    // Lisp navigation commands begin here.\r\n    /**\r\n     * Moves this token forward one s-expression at this level.\r\n     * If the next non whitespace token is an open paren, skips past it's matching\r\n     * close paren.\r\n     *\r\n     * If the next token is a form of closing paren, does not move.\r\n     *\r\n     * @returns true if the cursor was moved, false otherwise.\r\n     */\r\n    forwardSexp(skipComments = false) {\r\n        let delta = 0;\r\n        this.forwardWhitespace(!skipComments);\r\n        if (this.getToken().type == \"close\") {\r\n            return false;\r\n        }\r\n        while (!this.atEnd()) {\r\n            this.forwardWhitespace(!skipComments);\r\n            let tk = this.getToken();\r\n            switch (tk.type) {\r\n                case 'comment':\r\n                    this.next(); // skip past comment\r\n                    this.next(); // skip past EOL.\r\n                    return true;\r\n                case 'id':\r\n                case 'lit':\r\n                case 'kw':\r\n                case 'str':\r\n                case 'str-end':\r\n                    this.next();\r\n                    if (delta <= 0)\r\n                        return true;\r\n                    break;\r\n                case 'str-inside':\r\n                case 'str-start':\r\n                    do {\r\n                        this.next();\r\n                        tk = this.getToken();\r\n                    } while (!this.atEnd() && (tk.type == \"str-inside\" || tk.type == \"eol\"));\r\n                    continue;\r\n                case 'close':\r\n                    delta--;\r\n                    this.next();\r\n                    if (delta <= 0)\r\n                        return true;\r\n                    break;\r\n                case 'open':\r\n                    delta++;\r\n                    this.next();\r\n                    break;\r\n                default:\r\n                    this.next();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Moves this token backward one s-expression at this level.\r\n     * If the previous non whitespace token is an close paren, skips past it's matching\r\n     * open paren.\r\n     *\r\n     * If the previous token is a form of open paren, does not move.\r\n     *\r\n     * @returns true if the cursor was moved, false otherwise.\r\n     */\r\n    backwardSexp(skipComments = true) {\r\n        let delta = 0;\r\n        this.backwardWhitespace(!skipComments);\r\n        switch (this.getPrevToken().type) {\r\n            case \"open\":\r\n                return false;\r\n        }\r\n        while (!this.atStart()) {\r\n            this.backwardWhitespace(!skipComments);\r\n            let tk = this.getPrevToken();\r\n            switch (tk.type) {\r\n                case 'id':\r\n                case 'lit':\r\n                case 'kw':\r\n                case 'comment':\r\n                case 'str':\r\n                case 'str-start':\r\n                    this.previous();\r\n                    if (delta <= 0)\r\n                        return true;\r\n                    break;\r\n                case 'str-inside':\r\n                case 'str-end':\r\n                    do {\r\n                        this.previous();\r\n                        tk = this.getPrevToken();\r\n                    } while (!this.atStart() && tk.type == \"str-inside\");\r\n                    continue;\r\n                case 'close':\r\n                    delta++;\r\n                    this.previous();\r\n                    break;\r\n                case 'open':\r\n                    delta--;\r\n                    this.previous();\r\n                    if (delta <= 0)\r\n                        return true;\r\n                    break;\r\n                default:\r\n                    this.previous();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Moves this cursor to the close paren of the containing sexpr, or until the end of the document.\r\n     */\r\n    forwardList() {\r\n        let cursor = this.clone();\r\n        while (cursor.forwardSexp()) { }\r\n        if (cursor.getToken().type == \"close\") {\r\n            this.set(cursor);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Moves this cursor backwards to the open paren of the containing sexpr, or until the start of the document.\r\n     */\r\n    backwardList() {\r\n        let cursor = this.clone();\r\n        while (cursor.backwardSexp()) { }\r\n        if (cursor.getPrevToken().type == \"open\") {\r\n            this.set(cursor);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * If possible, moves this cursor forwards past any whitespace, and then past the immediately following open-paren and returns true.\r\n     * If the source does not match this, returns false and does not move the cursor.\r\n     */\r\n    downList() {\r\n        let cursor = this.clone();\r\n        cursor.forwardWhitespace();\r\n        if (cursor.getToken().type == \"open\") {\r\n            cursor.next();\r\n            this.set(cursor);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * If possible, moves this cursor forwards past any whitespace, and then past the immediately following close-paren and returns true.\r\n     * If the source does not match this, returns false and does not move the cursor.\r\n     */\r\n    upList() {\r\n        let cursor = this.clone();\r\n        cursor.forwardWhitespace();\r\n        if (cursor.getToken().type == \"close\") {\r\n            cursor.next();\r\n            this.set(cursor);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * If possible, moves this cursor backwards past any whitespace, and then backwards past the immediately following open-paren and returns true.\r\n     * If the source does not match this, returns false and does not move the cursor.\r\n     */\r\n    backwardUpList() {\r\n        let cursor = this.clone();\r\n        cursor.backwardWhitespace();\r\n        if (cursor.getPrevToken().type == \"open\") {\r\n            cursor.previous();\r\n            this.set(cursor);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    withinWhitespace() {\r\n        let tk = this.getToken().type;\r\n        if (tk == \"eol\" || tk == \"ws\") {\r\n            return true;\r\n        }\r\n    }\r\n    withinString() {\r\n        let tk = this.getToken().type;\r\n        if (tk == \"str\" || tk == \"str-start\" || tk == \"str-end\" || tk == \"str-inside\") {\r\n            return true;\r\n        }\r\n        if (tk == \"eol\") {\r\n            tk = this.getPrevToken().type;\r\n            if (tk == \"str-inside\" || tk == \"str-start\")\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/token-cursor.js?");

/***/ }),

/***/ "../../../scryetek-editor/js/undo.js":
/*!******************************************!*\
  !*** C:/code/scryetek-editor/js/undo.js ***!
  \******************************************/
/*! exports provided: UndoStep, UndoStepGroup, UndoManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UndoStep\", function() { return UndoStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UndoStepGroup\", function() { return UndoStepGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UndoManager\", function() { return UndoManager; });\n/**\r\n * A reversable operation to a document of type T.\r\n */\r\nclass UndoStep {\r\n    /**\r\n     * Given another UndoStep, attempts to modify this undo-step to include the subsequent one.\r\n     * If successful, returns true, if unsuccessful, returns false, and the step must be added to the\r\n     * UndoManager, too.\r\n     */\r\n    coalesce(c) {\r\n        return false;\r\n    }\r\n}\r\nclass UndoStepGroup extends UndoStep {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.steps = [];\r\n    }\r\n    addUndoStep(step) {\r\n        let prevStep = this.steps.length && this.steps[this.steps.length - 1];\r\n        if (prevStep && !prevStep.undoStop && prevStep.coalesce(step))\r\n            return;\r\n        this.steps.push(step);\r\n    }\r\n    undo(c) {\r\n        for (let i = this.steps.length - 1; i >= 0; i--)\r\n            this.steps[i].undo(c);\r\n    }\r\n    redo(c) {\r\n        for (let i = 0; i < this.steps.length; i++)\r\n            this.steps[i].redo(c);\r\n    }\r\n}\r\n/**\r\n * Handles the undo/redo stacks.\r\n */\r\nclass UndoManager {\r\n    constructor() {\r\n        this.undos = [];\r\n        this.redos = [];\r\n    }\r\n    /**\r\n     * Adds the step to the undo stack, and clears the redo stack.\r\n     * If possible, coalesces it into the previous undo.\r\n     *\r\n     * @param step the UndoStep to add.\r\n     */\r\n    addUndoStep(step) {\r\n        if (this.groupedUndo) {\r\n            this.groupedUndo.addUndoStep(step);\r\n        }\r\n        else if (this.undos.length) {\r\n            let prevUndo = this.undos[this.undos.length - 1];\r\n            if (prevUndo.undoStop) {\r\n                this.undos.push(step);\r\n            }\r\n            else if (!prevUndo.coalesce(step)) {\r\n                this.undos.push(step);\r\n            }\r\n        }\r\n        else {\r\n            this.undos.push(step);\r\n        }\r\n        this.redos = [];\r\n    }\r\n    withUndo(f) {\r\n        if (!this.groupedUndo) {\r\n            try {\r\n                this.groupedUndo = new UndoStepGroup();\r\n                f();\r\n                let undo = this.groupedUndo;\r\n                this.groupedUndo = null;\r\n                switch (undo.steps.length) {\r\n                    case 0: break;\r\n                    case 1:\r\n                        this.addUndoStep(undo.steps[0]);\r\n                        break;\r\n                    default:\r\n                        this.addUndoStep(undo);\r\n                }\r\n            }\r\n            finally {\r\n                this.groupedUndo = null;\r\n            }\r\n        }\r\n        else {\r\n            f();\r\n        }\r\n    }\r\n    /** Prevents this undo from becoming coalesced with future undos */\r\n    insertUndoStop() {\r\n        if (this.undos.length)\r\n            this.undos[this.undos.length - 1].undoStop = true;\r\n    }\r\n    /** Performs the top undo operation on the document (if it exists), moving it to the redo stack. */\r\n    undo(c) {\r\n        if (this.undos.length) {\r\n            const step = this.undos.pop();\r\n            step.undo(c);\r\n            this.redos.push(step);\r\n        }\r\n    }\r\n    /** Performs the top redo operation on the document (if it exists), moving it back onto the undo stack. */\r\n    redo(c) {\r\n        if (this.redos.length) {\r\n            const step = this.redos.pop();\r\n            step.redo(c);\r\n            this.undos.push(step);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///C:/code/scryetek-editor/js/undo.js?");

/***/ }),

/***/ "./webview-src/main.ts":
/*!*****************************!*\
  !*** ./webview-src/main.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst repl_interactor_1 = __webpack_require__(/*! repl-interactor */ \"../../../scryetek-editor/js/index.js\");\r\nconst lexer = __webpack_require__(/*! repl-interactor/js/clojure-lexer */ \"../../../scryetek-editor/js/clojure-lexer.js\");\r\nconst message = acquireVsCodeApi();\r\nlet ns = \"user\";\r\nlet con = new repl_interactor_1.ReplConsole(document.querySelector(\".repl\"), line => {\r\n    message.postMessage({ type: \"read-line\", line: line });\r\n});\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n    con.input.focus();\r\n});\r\nconst motd = [\r\n    \"Some said the world should be in Perl, \\nSome said in Lisp.\\nNow, having given both a whirl,\\nI held with those who favored Perl.\\nBut I fear we passed to men\\nA disappointing founding myth.\\nAnd should we write it all again,\\nI'd end it with\\nA close-paren. -Randall Munroe\",\r\n    \"I object to doing things that computers can do. -Olin Shivers\",\r\n    \"Will write code that writes code that writes code that writes code for money.\",\r\n    \"Anyone could learn Lisp in one day, except that if they already knew Fortran, it would take three days. -Marvin Minsky\",\r\n    \"Your Kitten of Death awaits. -Christopher Rhodes.\",\r\n    \"Syntactic sugar causes cancer of the semicolon. -Alan Perlis\",\r\n    \"If you have a procedure with ten parameters, you probably missed some. -Alan Perlis\",\r\n    \"Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy. -Alan Perlis\",\r\n    \"If you give someone Fortran, he has Fortran. If you give someone Lisp, he has any language he pleases. -Guy L. Steele Jr\",\r\n    \"If you have more things than names, your design is broken- Stuart Halloway\",\r\n    \"Made with secret alien technology.\"\r\n];\r\nlet scanner = new lexer.Scanner();\r\nwindow.onmessage = (msg) => {\r\n    if (msg.data.type == \"init\") {\r\n        ns = msg.data.ns;\r\n        con.requestPrompt(ns + \"=> \");\r\n    }\r\n    if (msg.data.type == \"ui-command\") {\r\n        if (con.commands[msg.data.value])\r\n            con.commands[msg.data.value]();\r\n    }\r\n    if (msg.data.type == \"repl-response\") {\r\n        let div = document.createElement(\"div\");\r\n        for (let tk of scanner.processLine(msg.data.value)) {\r\n            let el = document.createElement(\"span\");\r\n            el.className = tk.type;\r\n            el.textContent = tk.raw;\r\n            div.appendChild(el);\r\n            ns = msg.data.ns;\r\n        }\r\n        con.printElement(div);\r\n        con.requestPrompt(ns + \"=> \");\r\n    }\r\n    if (msg.data.type == \"repl-error\") {\r\n        let div = document.createElement(\"div\");\r\n        div.className = \"error\";\r\n        div.textContent = msg.data.ex;\r\n        con.printElement(div);\r\n        con.requestPrompt(ns + \"=> \");\r\n    }\r\n    if (msg.data.type == \"stdout\") {\r\n        con.print(msg.data.value);\r\n    }\r\n    if (msg.data.type == \"stderr\") {\r\n        let div = document.createElement(\"div\");\r\n        div.className = \"error\";\r\n        div.textContent = msg.data.value;\r\n        con.printElement(div);\r\n    }\r\n};\r\nmessage.postMessage({ type: \"init\" });\r\ndocument.querySelector(\"#motd\").textContent = motd[Math.floor(Math.random() * motd.length)];\r\n\n\n//# sourceURL=webpack:///./webview-src/main.ts?");

/***/ })

/******/ });