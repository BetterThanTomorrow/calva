{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! Calva is an integrated REPL powered environment for enjoyable and productive Clojure and ClojureScript development in Visual Studio Code . It includes inline code evaluation, Paredit, code formatting, a test runner, syntax highlighting, linting , and more. Calva is open source and free to use. Getting Started Let's start a REPL! . \ud83d\ude80 Also see Get Started with Clojure How to Contribute to Calva? I'm glad you asked! Please see How to Contribute and The Tao of Calva Calva Patrons The right kind of different Calva Gold Sponsors \u2665\ufe0f Scale your growth on mobile MAKE. DO. SHIP. Please see this statement from Cognitect about the importance of supporting open source developers. See Sponsors for information about sponsoring Calva. If your Company benefits from Calva's existence and you see it as an important in the Clojure and ClojureScript ecosystem. please consider sponsoring! Have Questions and Feedback? Need Help? Easiest way is to chat with us and other Calva users. Please join the #calva channel on the Clojurians Slack. If you haven't joined that slack workspace, you can get an invite here . If you're a beginner to Clojure(Script), the #beginners channel of the Clojurians Slack is very active and helpful. Happy coding!","title":"Welcome!"},{"location":"#welcome","text":"Calva is an integrated REPL powered environment for enjoyable and productive Clojure and ClojureScript development in Visual Studio Code . It includes inline code evaluation, Paredit, code formatting, a test runner, syntax highlighting, linting , and more. Calva is open source and free to use.","title":"Welcome!"},{"location":"#getting-started","text":"Let's start a REPL! . \ud83d\ude80 Also see Get Started with Clojure","title":"Getting Started"},{"location":"#how-to-contribute-to-calva","text":"I'm glad you asked! Please see How to Contribute and The Tao of Calva","title":"How to Contribute to Calva?"},{"location":"#calva-patrons","text":"The right kind of different","title":"Calva Patrons"},{"location":"#calva-gold-sponsors","text":"Scale your growth on mobile MAKE. DO. SHIP. Please see this statement from Cognitect about the importance of supporting open source developers. See Sponsors for information about sponsoring Calva. If your Company benefits from Calva's existence and you see it as an important in the Clojure and ClojureScript ecosystem. please consider sponsoring!","title":"Calva Gold Sponsors \u2665\ufe0f"},{"location":"#have-questions-and-feedback-need-help","text":"Easiest way is to chat with us and other Calva users. Please join the #calva channel on the Clojurians Slack. If you haven't joined that slack workspace, you can get an invite here . If you're a beginner to Clojure(Script), the #beginners channel of the Clojurians Slack is very active and helpful. Happy coding!","title":"Have Questions and Feedback? Need Help?"},{"location":"clojure-lsp/","text":"Clojure-lsp Calva uses a mix of static and dynamic analysis to power the experience. A lot of the static abilities come from clojure-lsp . This enables you to check something up in a project, with a lot of navigational and contextual support, without starting a REPL for it. (And once you do start a REPL you'll get even more capabilities, enabled by the dynamic analysis.) Note By default, Calva determines the version of clojure-lsp it uses, and it defaults to latest . To use a different version of clojure-lsp, see the configuration section. Calva does not use the clojure-lsp installed on your system, unless you set the path for clojure-lsp to the installed binary in your settings . You can see what version is being used by running the Clojure-lsp Server Info command, which will also show the version of clj-kondo that's being used as well as other info. Starting the LSP server You don't need to do anything to start clojure-lsp. No install, no commands, no nothing. Calva downloads the correct binary for your operating system if necessary (this should only happen when the clojure-lsp version is updated in a new release of Calva) and then starts it. It does take a while for clojure-lsp to start, though, especially the first time for a new project, when clojure-lsp (via clj-kondo ) indexes the project files. Calva will show a status bar message during the download and while the server is starting, which will go away once the server is ready. However, much of Calva's functionality is available regardless of the LSP server , so please start using Calva while this server is starting. Ignoring LSP cache files Clojure-lsp stores its project analysis information in your project. Git users can add these lines to their project root directory .gitignore : .clj-kondo/cache/ .clj-kondo/.cache/ .lsp/sqlite.*.db Configuration For information about how to configure clojure-lsp, see the settings page of the clojure-lsp docs. Changing the Version of Clojure-lsp Used by Calva By default, Calva will use the latest released clojure-lsp . You can change the version of clojure-lsp used by Calva by setting the calva.clojureLspVersion property to a version of clojure-lsp found in its GitHub releases . This can be helpful if you're debugging an issue with clojure-lsp or you want to try out a feature of a new release that Calva does not yet use. However, you must remember to reset this setting in order for Calva to automatically use newer versions of clojure-lsp that are released with new versions of Calva. Example: \"calva.clojureLspVersion\" : \"2021.04.07-16.34.10\" If you have specified a version and want to use the latest release, either remove the setting, or set it to latest . Using a Custom Clojure-lsp Native Binary You can set a path to a clojure-lsp binary to be used by Calva by setting the calva.clojureLspPath setting. This should be an absolute path. When this is set, the binary at the path will be used and the calva.clojureLspVersion setting will be ignored. Example: \"calva.clojureLspPath\" : \"/usr/local/bin/clojure-lsp\" Troubleshooting Viewing the Logs Between the Client and Server If something doesn't seem to be working correctly, and you suspect the issue is related to clojure-lsp, a good place to start investigating is the request and response logs between the LSP client and server. In your settings, set clojure.trace.server to verbose , then in the VS Code output tab, select the Clojure Language Client output channel. It may be helpful to clear the output channel, then perform the action with which you're experiencing a problem, then read through the log for clues or paste the logs into a related issue in the Calva repo. Server Info Command You can run the Clojure-lsp Server Info command to get information about the running clojure-lsp server, such as the version the server being used, the version of clj-kondo it's using, and more. This info is printed to the \"Calva says\" output channel. Related See also: Connecting the REPL Refactoring","title":"Clojure-lsp"},{"location":"clojure-lsp/#clojure-lsp","text":"Calva uses a mix of static and dynamic analysis to power the experience. A lot of the static abilities come from clojure-lsp . This enables you to check something up in a project, with a lot of navigational and contextual support, without starting a REPL for it. (And once you do start a REPL you'll get even more capabilities, enabled by the dynamic analysis.) Note By default, Calva determines the version of clojure-lsp it uses, and it defaults to latest . To use a different version of clojure-lsp, see the configuration section. Calva does not use the clojure-lsp installed on your system, unless you set the path for clojure-lsp to the installed binary in your settings . You can see what version is being used by running the Clojure-lsp Server Info command, which will also show the version of clj-kondo that's being used as well as other info.","title":"Clojure-lsp"},{"location":"clojure-lsp/#starting-the-lsp-server","text":"You don't need to do anything to start clojure-lsp. No install, no commands, no nothing. Calva downloads the correct binary for your operating system if necessary (this should only happen when the clojure-lsp version is updated in a new release of Calva) and then starts it. It does take a while for clojure-lsp to start, though, especially the first time for a new project, when clojure-lsp (via clj-kondo ) indexes the project files. Calva will show a status bar message during the download and while the server is starting, which will go away once the server is ready. However, much of Calva's functionality is available regardless of the LSP server , so please start using Calva while this server is starting.","title":"Starting the LSP server"},{"location":"clojure-lsp/#ignoring-lsp-cache-files","text":"Clojure-lsp stores its project analysis information in your project. Git users can add these lines to their project root directory .gitignore : .clj-kondo/cache/ .clj-kondo/.cache/ .lsp/sqlite.*.db","title":"Ignoring LSP cache files"},{"location":"clojure-lsp/#configuration","text":"For information about how to configure clojure-lsp, see the settings page of the clojure-lsp docs.","title":"Configuration"},{"location":"clojure-lsp/#changing-the-version-of-clojure-lsp-used-by-calva","text":"By default, Calva will use the latest released clojure-lsp . You can change the version of clojure-lsp used by Calva by setting the calva.clojureLspVersion property to a version of clojure-lsp found in its GitHub releases . This can be helpful if you're debugging an issue with clojure-lsp or you want to try out a feature of a new release that Calva does not yet use. However, you must remember to reset this setting in order for Calva to automatically use newer versions of clojure-lsp that are released with new versions of Calva. Example: \"calva.clojureLspVersion\" : \"2021.04.07-16.34.10\" If you have specified a version and want to use the latest release, either remove the setting, or set it to latest .","title":"Changing the Version of Clojure-lsp Used by Calva"},{"location":"clojure-lsp/#using-a-custom-clojure-lsp-native-binary","text":"You can set a path to a clojure-lsp binary to be used by Calva by setting the calva.clojureLspPath setting. This should be an absolute path. When this is set, the binary at the path will be used and the calva.clojureLspVersion setting will be ignored. Example: \"calva.clojureLspPath\" : \"/usr/local/bin/clojure-lsp\"","title":"Using a Custom Clojure-lsp Native Binary"},{"location":"clojure-lsp/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"clojure-lsp/#viewing-the-logs-between-the-client-and-server","text":"If something doesn't seem to be working correctly, and you suspect the issue is related to clojure-lsp, a good place to start investigating is the request and response logs between the LSP client and server. In your settings, set clojure.trace.server to verbose , then in the VS Code output tab, select the Clojure Language Client output channel. It may be helpful to clear the output channel, then perform the action with which you're experiencing a problem, then read through the log for clues or paste the logs into a related issue in the Calva repo.","title":"Viewing the Logs Between the Client and Server"},{"location":"clojure-lsp/#server-info-command","text":"You can run the Clojure-lsp Server Info command to get information about the running clojure-lsp server, such as the version the server being used, the version of clj-kondo it's using, and more. This info is printed to the \"Calva says\" output channel.","title":"Server Info Command"},{"location":"clojure-lsp/#related","text":"See also: Connecting the REPL Refactoring","title":"Related"},{"location":"commands-top10/","text":"The Top 10 Calva Commands There are not all that many Calva commands. You can learn them all if you like, but here are the most important ones to know about for effective Clojure/ClojureScript coding: Grow/expand selection : ctrl+w ( shift+alt+right on Windows and Linux) Load current file : alt+ctrl+c enter , evaluates the namespace code in the active editor tab. This also loads any required namespaces, and generally gives Calva what it needs to work. Evaluate current form : ctrl+enter finds the form from the cursor position, evaluates it and displays the result inline. Hit esc to dismiss the results display. Evaluate current top-level form : alt+enter : inline evaluate the current top-level form. This also works inside (comment) forms. Use it to (re)define vars and then inside comment forms you can verify that they do what you want them to do. Dismiss the display of results : escape : (VIM Extension users should read Using Calva with the VIM Extension ). There are also two commands for bringing over the current form and the current top level form over to the repl window: ctrl+alt+c ctrl+alt+e ( ctrl+alt+c ctrl+alt+v on Windows): to paste the current form in the REPL window. ctrl+alt+c ctrl+alt+space : to paste the current top-level form in this window You can also switch the name space of the output/repl window to that of the current file: alt+ctrl+c alt+n Toggle pretty printing of results on and off: ctrl+alt+c p . It's on by default. There is a status bar button showing the status and that also can be used to toggle the setting. Some More Commands to Try Code evaluation Evaluate code and add as comment: ctrl+alt+c c (current form), ctrl+alt+c ctrl+space (current top level form) Evaluate code and replace it in the editor, inline: ctrl+alt+c r Integrated REPLs Send current editor form to the REPL window: ctrl+alt+c ctrl+alt+e ( ctrl+alt+c ctrl+alt+v on Windows) Send current editor top level form to the REPL window: ctrl+alt+c ctrl+alt+space Run tests and mark failures and errors in the Problems pane Run namespace tests: ctrl+alt+c t Run all tests: ctrl+alt+c shift+t Run current test: ctrl+alt+c ctrl+alt+t Rerun previously failing tests: ctrl+alt+c ctrl+t Caveat : Right now the tests are reported only when all are run, making it painful to run all tests in larger projects. I'll fix it. Promise! Select current form: ctrl+alt+c s . Run custom commands, i.e. code snippets, at will: ctrl+alt+c . See also: Code Evaluation Tips Finding Calva Commands and Shortcuts","title":"The Top 10 Calva Commands"},{"location":"commands-top10/#the-top-10-calva-commands","text":"There are not all that many Calva commands. You can learn them all if you like, but here are the most important ones to know about for effective Clojure/ClojureScript coding: Grow/expand selection : ctrl+w ( shift+alt+right on Windows and Linux) Load current file : alt+ctrl+c enter , evaluates the namespace code in the active editor tab. This also loads any required namespaces, and generally gives Calva what it needs to work. Evaluate current form : ctrl+enter finds the form from the cursor position, evaluates it and displays the result inline. Hit esc to dismiss the results display. Evaluate current top-level form : alt+enter : inline evaluate the current top-level form. This also works inside (comment) forms. Use it to (re)define vars and then inside comment forms you can verify that they do what you want them to do. Dismiss the display of results : escape : (VIM Extension users should read Using Calva with the VIM Extension ). There are also two commands for bringing over the current form and the current top level form over to the repl window: ctrl+alt+c ctrl+alt+e ( ctrl+alt+c ctrl+alt+v on Windows): to paste the current form in the REPL window. ctrl+alt+c ctrl+alt+space : to paste the current top-level form in this window You can also switch the name space of the output/repl window to that of the current file: alt+ctrl+c alt+n Toggle pretty printing of results on and off: ctrl+alt+c p . It's on by default. There is a status bar button showing the status and that also can be used to toggle the setting.","title":"The Top 10 Calva Commands"},{"location":"commands-top10/#some-more-commands-to-try","text":"Code evaluation Evaluate code and add as comment: ctrl+alt+c c (current form), ctrl+alt+c ctrl+space (current top level form) Evaluate code and replace it in the editor, inline: ctrl+alt+c r Integrated REPLs Send current editor form to the REPL window: ctrl+alt+c ctrl+alt+e ( ctrl+alt+c ctrl+alt+v on Windows) Send current editor top level form to the REPL window: ctrl+alt+c ctrl+alt+space Run tests and mark failures and errors in the Problems pane Run namespace tests: ctrl+alt+c t Run all tests: ctrl+alt+c shift+t Run current test: ctrl+alt+c ctrl+alt+t Rerun previously failing tests: ctrl+alt+c ctrl+t Caveat : Right now the tests are reported only when all are run, making it painful to run all tests in larger projects. I'll fix it. Promise! Select current form: ctrl+alt+c s . Run custom commands, i.e. code snippets, at will: ctrl+alt+c . See also: Code Evaluation Tips Finding Calva Commands and Shortcuts","title":"Some More Commands to Try"},{"location":"connect-sequences/","text":"REPL Jack-in and Connection Sequences Many projects grow out of the template phase and call for custom developer workflows involving application start commands, customized REPLs, and what have you. Even some templates add this kind of complexity. To make Jack-in usable for a broader set of projects, Calva has a setting keyed calva.replConnectSequences which lets you configure one ore more connect sequences. NB: Connect sequence configuration affects Calva's Jack-in menu in the following ways: With no sequence configured, Calva will prompt for the built-in sequences it has that seems to match your project. When any number of connection sequences are configured, Calva will prompt for your custom sequences, as well as the built-in sequences. Whether built-in or custom, only sequences relevant to your project will be included in the prompt. Settings for adding Custom Sequences A connect sequence configures the following: name : (required) This will show up in the Jack-in quick-pick menu when you start Jack-in (see above). projectType : (required) This is either \"Leiningen\u201d, \u201ddeps.edn\u201d, \u201dshadow-cljs\u201d, \u201dlein-shadow\u201d, or \u201dgeneric\". nReplPortFile : An array of path segments with the project root-relative path to the nREPL port file for this connect sequence. E.g. For shadow-cljs this would be [\".shadow-cljs\", \"nrepl.port\"] . afterCLJReplJackInCode : Here you can give Calva some Clojure code to evaluate in the CLJ REPL, once it has been created. cljsType : This can be either \"Figwheel Main\", \"shadow-cljs\", \"ClojureScript built-in for browser\", \"ClojureScript built-in for node\", \"lein-figwheel\", \"none\", or a dictionary configuring a custom type. If set to \"none\", Calva will skip connecting a ClojureScript repl. A custom type has the following fields: dependsOn : (required) Calva will use this to determine which dependencies it will add when starting the project (Jacking in). This can be either \"Figwheel Main\", \"shadow-cljs\", \"ClojureScript built-in for browser\", \"ClojureScript built-in for node\", \"lein-figwheel\", or \u201dUser provided\u201d. If it is \"User provided\", then you need to provide the dependencies in the project or launch with an alias (deps.edn), profile (Leiningen), or build (shadow-cljs) that provides the dependencies needed. isStarted : Boolean. For CLJS REPLs that Calva does not need to start, set this to true. (If you base your custom cljs repl on a shadow-cljs workflow, for instance.) startCode : Clojure code to be evaluated to create and/or start your custom CLJS REPL. isStartedRegExp : A regular expression which, when matched in the stdout from the startCode evaluation, will make Calva continue with connecting the REPL, and to prompt the user to start the application. If omitted and there is startCode Calva will continue when that code is evaluated. openUrlRegExp : A regular expression, matched against the stdout of cljsType evaluations, for extracting the URL with which the app can be started. The expression should have a capturing group named url . E.g. \"Open URL: (?\\<url>S+)\" shouldOpenUrl : Choose if Calva should automatically open the URL for you or not. connectCode : (required) Clojure code to be evaluated to convert the REPL to a CLJS REPL that Calva can use to connect to the application. (For some setups this could also conditionally start the CLJS REPL. If so: startCode should be omitted.) isConnectedRegExp : (required) A regular expression which, when matched in the stdout from the connectCode evaluation, will tell Calva that the application is connected. The default is To quit, type: :cljs/quit and you should leave it at that unless you know it won't work. printThisLineRegExp : regular expression which, when matched in the stdout from any code evaluations in the cljsType , will make the matched text be printed to the Output window . buildsRequired : Boolean. If the repl type requires that builds are started in order to connect to them, set this to true. menuSelections : a dictionary with pre-filled-in selections for the Jack-in and Connect prompts, making Calva not prompt for that particular selection: leinProfiles : At Jack-in to a Leiningen project, use these profiles to launch the repl. leinAlias : At Jack-in to a Leiningen project, launch with this alias. Set to null to launch with Calva's default task (a headless repl), w/o prompting. cljAliases : At Jack-in to a deps.edn project, use these aliases to launch the repl. cljsLaunchBuilds : The cljs builds to start/watch at Jack-in/connect. cljsDefaultBuild : Which cljs build to attach to at the initial connect. jackInEnv : An object with environment variables that will be merged with the global calva.jackInEnv and then applied to the Jack-in process. The merge is very similar to how Clojure's merge works. So for any common keys between the global setting and this one, the ones from this setting will win. The Calva built-in sequences also use this format, check them out to get a clearer picture of how these settings work. Example Sequences Setting for a full-stack application. It starts the backend server when the CLJ REPL has started. Then proceeds to create a custom CLJS REPL (calling in to the application code for this). And then connects to it. { \"calva.replConnectSequences\" : [ { \"name\" : \"Example Sequence\" , \"projectType\" : \"Clojure-CLI\" , \"afterCLJReplJackInCode\" : \"(go)\" , \"cljsType\" : { \"startCode\" : \"(do (require '[cljs-test.main :refer :all])(start-nrepl+fig))\" , \"isStartedRegExp\" : \"Prompt will show\" , \"connectCode\" : \"(do (use 'cljs-test.main) (cljs-repl))\" , \"isConnectedRegExp\" : \"To quit, type: :cljs/quit\" , \"printThisLineRegExp\" : \"\\\\[Figwheel\\\\] Starting Server at.*\" } } ] } Here is an example from the JUXT Edge project template. It adds two sequences, one for when only the Clojure REPL should be launched and one for when the customized Edge cljs repl should also be connected. The Edge backend + frontend sequence specifies that the web app should be opened by Calva, making cljs repl connection more stable, and also adds menuSelections to skip the launch aliases prompt. { \"calva.replConnectSequences\" : [ { \"name\" : \"Edge backend only\" , \"projectType\" : \"deps.edn\" }, { \"name\" : \"Edge backend + frontend\" , \"projectType\" : \"deps.edn\" , \"cljsType\" : { \"dependsOn\" : \"Figwheel Main\" , \"startCode\" : \"(do (require 'dev-extras) (dev-extras/go) (println \\\"Edge Figwheel Main started\\\") ((resolve 'dev-extras/cljs-repl)))\" , \"isReadyToStartRegExp\" : \"Edge Figwheel Main started\" , \"openUrlRegExp\" : \"Website listening on: (?<url>\\\\S+)\" , \"printThisLineRegExp\" : \"\\\\[Edge\\\\]\" , \"shouldOpenUrl\" : true , \"connectCode\" : \"(do (require 'dev-extras) ((resolve 'dev-extras/cljs-repl)))\" , \"isConnectedRegExp\" : \"To quit, type: :cljs/quit\" , \"buildsRequired\" : false }, \"menuSelections\" : { \"cljAliases\" : [ \"dev\" , \"build\" , \"dev/build\" ], } } ] } A deps.edn sequence that does not promote the ClojureScript repl at all (leaving it a Clojure REPL), and leaves that up to you to do interactively. (Could be useful while you are developing a custom cljs repl.) The example is for when adapting a Figwheel Main repl. { \"calva.replConnectSequences\" : [ { \"name\" : \"Do not promote to cljs\" , \"projectType\" : \"deps.edn\" , \"cljsType\" : { \"dependsOn\" : \"Figwheel Main\" , \"connectCode\" : \"\\\"Don't promote me bro!\\\"\" , \"isConnectedRegExp\" : \"Don't promote me bro!\" } } ] }","title":"REPL Jack-in and Connection Sequences"},{"location":"connect-sequences/#repl-jack-in-and-connection-sequences","text":"Many projects grow out of the template phase and call for custom developer workflows involving application start commands, customized REPLs, and what have you. Even some templates add this kind of complexity. To make Jack-in usable for a broader set of projects, Calva has a setting keyed calva.replConnectSequences which lets you configure one ore more connect sequences. NB: Connect sequence configuration affects Calva's Jack-in menu in the following ways: With no sequence configured, Calva will prompt for the built-in sequences it has that seems to match your project. When any number of connection sequences are configured, Calva will prompt for your custom sequences, as well as the built-in sequences. Whether built-in or custom, only sequences relevant to your project will be included in the prompt.","title":"REPL Jack-in and Connection Sequences"},{"location":"connect-sequences/#settings-for-adding-custom-sequences","text":"A connect sequence configures the following: name : (required) This will show up in the Jack-in quick-pick menu when you start Jack-in (see above). projectType : (required) This is either \"Leiningen\u201d, \u201ddeps.edn\u201d, \u201dshadow-cljs\u201d, \u201dlein-shadow\u201d, or \u201dgeneric\". nReplPortFile : An array of path segments with the project root-relative path to the nREPL port file for this connect sequence. E.g. For shadow-cljs this would be [\".shadow-cljs\", \"nrepl.port\"] . afterCLJReplJackInCode : Here you can give Calva some Clojure code to evaluate in the CLJ REPL, once it has been created. cljsType : This can be either \"Figwheel Main\", \"shadow-cljs\", \"ClojureScript built-in for browser\", \"ClojureScript built-in for node\", \"lein-figwheel\", \"none\", or a dictionary configuring a custom type. If set to \"none\", Calva will skip connecting a ClojureScript repl. A custom type has the following fields: dependsOn : (required) Calva will use this to determine which dependencies it will add when starting the project (Jacking in). This can be either \"Figwheel Main\", \"shadow-cljs\", \"ClojureScript built-in for browser\", \"ClojureScript built-in for node\", \"lein-figwheel\", or \u201dUser provided\u201d. If it is \"User provided\", then you need to provide the dependencies in the project or launch with an alias (deps.edn), profile (Leiningen), or build (shadow-cljs) that provides the dependencies needed. isStarted : Boolean. For CLJS REPLs that Calva does not need to start, set this to true. (If you base your custom cljs repl on a shadow-cljs workflow, for instance.) startCode : Clojure code to be evaluated to create and/or start your custom CLJS REPL. isStartedRegExp : A regular expression which, when matched in the stdout from the startCode evaluation, will make Calva continue with connecting the REPL, and to prompt the user to start the application. If omitted and there is startCode Calva will continue when that code is evaluated. openUrlRegExp : A regular expression, matched against the stdout of cljsType evaluations, for extracting the URL with which the app can be started. The expression should have a capturing group named url . E.g. \"Open URL: (?\\<url>S+)\" shouldOpenUrl : Choose if Calva should automatically open the URL for you or not. connectCode : (required) Clojure code to be evaluated to convert the REPL to a CLJS REPL that Calva can use to connect to the application. (For some setups this could also conditionally start the CLJS REPL. If so: startCode should be omitted.) isConnectedRegExp : (required) A regular expression which, when matched in the stdout from the connectCode evaluation, will tell Calva that the application is connected. The default is To quit, type: :cljs/quit and you should leave it at that unless you know it won't work. printThisLineRegExp : regular expression which, when matched in the stdout from any code evaluations in the cljsType , will make the matched text be printed to the Output window . buildsRequired : Boolean. If the repl type requires that builds are started in order to connect to them, set this to true. menuSelections : a dictionary with pre-filled-in selections for the Jack-in and Connect prompts, making Calva not prompt for that particular selection: leinProfiles : At Jack-in to a Leiningen project, use these profiles to launch the repl. leinAlias : At Jack-in to a Leiningen project, launch with this alias. Set to null to launch with Calva's default task (a headless repl), w/o prompting. cljAliases : At Jack-in to a deps.edn project, use these aliases to launch the repl. cljsLaunchBuilds : The cljs builds to start/watch at Jack-in/connect. cljsDefaultBuild : Which cljs build to attach to at the initial connect. jackInEnv : An object with environment variables that will be merged with the global calva.jackInEnv and then applied to the Jack-in process. The merge is very similar to how Clojure's merge works. So for any common keys between the global setting and this one, the ones from this setting will win. The Calva built-in sequences also use this format, check them out to get a clearer picture of how these settings work.","title":"Settings for adding Custom Sequences"},{"location":"connect-sequences/#example-sequences","text":"Setting for a full-stack application. It starts the backend server when the CLJ REPL has started. Then proceeds to create a custom CLJS REPL (calling in to the application code for this). And then connects to it. { \"calva.replConnectSequences\" : [ { \"name\" : \"Example Sequence\" , \"projectType\" : \"Clojure-CLI\" , \"afterCLJReplJackInCode\" : \"(go)\" , \"cljsType\" : { \"startCode\" : \"(do (require '[cljs-test.main :refer :all])(start-nrepl+fig))\" , \"isStartedRegExp\" : \"Prompt will show\" , \"connectCode\" : \"(do (use 'cljs-test.main) (cljs-repl))\" , \"isConnectedRegExp\" : \"To quit, type: :cljs/quit\" , \"printThisLineRegExp\" : \"\\\\[Figwheel\\\\] Starting Server at.*\" } } ] } Here is an example from the JUXT Edge project template. It adds two sequences, one for when only the Clojure REPL should be launched and one for when the customized Edge cljs repl should also be connected. The Edge backend + frontend sequence specifies that the web app should be opened by Calva, making cljs repl connection more stable, and also adds menuSelections to skip the launch aliases prompt. { \"calva.replConnectSequences\" : [ { \"name\" : \"Edge backend only\" , \"projectType\" : \"deps.edn\" }, { \"name\" : \"Edge backend + frontend\" , \"projectType\" : \"deps.edn\" , \"cljsType\" : { \"dependsOn\" : \"Figwheel Main\" , \"startCode\" : \"(do (require 'dev-extras) (dev-extras/go) (println \\\"Edge Figwheel Main started\\\") ((resolve 'dev-extras/cljs-repl)))\" , \"isReadyToStartRegExp\" : \"Edge Figwheel Main started\" , \"openUrlRegExp\" : \"Website listening on: (?<url>\\\\S+)\" , \"printThisLineRegExp\" : \"\\\\[Edge\\\\]\" , \"shouldOpenUrl\" : true , \"connectCode\" : \"(do (require 'dev-extras) ((resolve 'dev-extras/cljs-repl)))\" , \"isConnectedRegExp\" : \"To quit, type: :cljs/quit\" , \"buildsRequired\" : false }, \"menuSelections\" : { \"cljAliases\" : [ \"dev\" , \"build\" , \"dev/build\" ], } } ] } A deps.edn sequence that does not promote the ClojureScript repl at all (leaving it a Clojure REPL), and leaves that up to you to do interactively. (Could be useful while you are developing a custom cljs repl.) The example is for when adapting a Figwheel Main repl. { \"calva.replConnectSequences\" : [ { \"name\" : \"Do not promote to cljs\" , \"projectType\" : \"deps.edn\" , \"cljsType\" : { \"dependsOn\" : \"Figwheel Main\" , \"connectCode\" : \"\\\"Don't promote me bro!\\\"\" , \"isConnectedRegExp\" : \"Don't promote me bro!\" } } ] }","title":"Example Sequences"},{"location":"connect/","text":"Connect Calva to Your Project The recommended way is to: Jack-in: Let Calva start the REPL for you This way Calva can make sure it is started with the dependencies needed for a working Clojure and/or ClojureScript session. This is often referred to as Jack in (because that is what it is called in CIDER). Jack-in supports both CLJ and for CLJS, and has built-in configurations for Leiningen , deps.edn , and shadow-cljs projects, as well as for the CLJS repl types: Figwheel Main , lein-figwheel (legacy Figwheel), shadow-cljs , and ClojureScript built-ins for both browser and node.js. Using jack-in provides your development environment with all the dependencies you need for Calva to work. It works like so: Open your project root directory in VS Code. Issue the command Start a Project REPL and Connect : ctrl+alt+c ctrl+alt+j . Answer the quick-pick prompts telling Calva about project types and what profiles to start. (See the Jack-in Project Types and Profiles wiki page for more info if needed.) See also: Workspace Layouts Note You must have a project file, such as project.clj for Leiningen or deps.edn for deps.edn, in the directory opened in VS Code in order for jack-in to work. If, after adding the project file, you experience an error during jack-in that says something could not be located, make sure you have the correct dependencies in your project file. For example, when using the Figwheel Main project type, you should have com.bhauman/figwheel-main in your project dependencies. Aliases, profiles, builds When Jack-in starts it will depend on the project type, and whether ClojureScript is involved or not, and if it is, what kind of ClojureScript project, what will happen next. Calva will analyze the project files and will then give you prompts with selections based on what is found there. You will need some basic knowledge about the project and the project type terminologies to answer the prompts. There are ways to tell Calva the answers to these prompts beforehand, so that Jack-in can be a zero-prompting command. Read on. Customizing Jack-in The main mechanism for customizing your Jack-in, including automating menu selections, and custom CLJS REPL types is Custom Connect Sequences . There are also these settings: calva.jackInEnv : An object with environment variables that will be added to the environment of the Jack-in process. calva.myCljAliases : An array of deps.edn aliases not found in the project file. Use this to tell Calva Jack-in to launch your REPL using your user defined aliases. calva.myLeinProfiles : An array of Leiningen profiles not found in project.clj . Use this to tell Calva Jack-in to launch your REPL using your user defined profiles. calva.openBrowserWhenFigwheelStarted : For Legacy Figwheel only. A boolean controlling if Calva should automatically launch your ClojureScript app, once it is compiled by Figwheel. Defaults to true . Note When processing the calva.jackInEnv setting you can refer to existing ENV variables with ${env:VARIABLE} . Troubleshooting Command not found errors If you get command not found error when Calva tries to start your project, and you know you have the command installed, it's probably because VS Code starts from an environment where the command is not on the $PATH . It can look like so: lein update-in :dependencies conj '[nrepl,\"0.8.3\"]' -- update-in :plugins conj '[cider/cider-nrepl,\"0.25.8\"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- repl :headless /bin/sh: lein: command not found Jack-in process exited. Status: 127 The fix is to always start VS Code from the command line: $ code You might need to first run the Shell Command: Install code command in PATH . This will also make sure your REPL has access to the environment you probably expect it to have access to. See below. Environment variables are not readable From REPL If you've added environment variables in your OS, such as in your ~/.bashrc file (Linux), in order for them to be read in a REPL created by Calva's jackin command, VS Code must be started from a shell where the environment variables are defined. For example, if you can open a bash terminal and run echo $SOME_VAR and see the value there, then open VS Code from that terminal with code <project path> . Connecting w/o Jack-in If, for whatever reasons, you can't use Jack-in with your project (possibly because the REPL is started as part of some other job) all is not lost. Old fashioned Connect to a running REPL is still there for you. For all features to work in Calva while connecting to a running REPL, your environment needs to have REPL related dependencies set up. However, just as before it can be tricky to get the dependencies right. Consider using Jack in to inform yourself on how to start your REPL to Calva's satisfaction. When you use Jack in, Calva starts a VS Code task for it and the command line used is displayed in the terminal pane used to handle the task. Reading that command line tells you what dependencies are needed for your project. Even better: Copying that command line gives you the command to start the REPL with the correct dependencies. All this said, I still recommend you challenge the conclusion that you can't use Jack-in. Note There is a Calva command for copying the Jack-in command line to the clipboard.","title":"Connect Calva to Your Project"},{"location":"connect/#connect-calva-to-your-project","text":"The recommended way is to:","title":"Connect Calva to Your Project"},{"location":"connect/#jack-in-let-calva-start-the-repl-for-you","text":"This way Calva can make sure it is started with the dependencies needed for a working Clojure and/or ClojureScript session. This is often referred to as Jack in (because that is what it is called in CIDER). Jack-in supports both CLJ and for CLJS, and has built-in configurations for Leiningen , deps.edn , and shadow-cljs projects, as well as for the CLJS repl types: Figwheel Main , lein-figwheel (legacy Figwheel), shadow-cljs , and ClojureScript built-ins for both browser and node.js. Using jack-in provides your development environment with all the dependencies you need for Calva to work. It works like so: Open your project root directory in VS Code. Issue the command Start a Project REPL and Connect : ctrl+alt+c ctrl+alt+j . Answer the quick-pick prompts telling Calva about project types and what profiles to start. (See the Jack-in Project Types and Profiles wiki page for more info if needed.) See also: Workspace Layouts Note You must have a project file, such as project.clj for Leiningen or deps.edn for deps.edn, in the directory opened in VS Code in order for jack-in to work. If, after adding the project file, you experience an error during jack-in that says something could not be located, make sure you have the correct dependencies in your project file. For example, when using the Figwheel Main project type, you should have com.bhauman/figwheel-main in your project dependencies.","title":"Jack-in: Let Calva start the REPL for you"},{"location":"connect/#aliases-profiles-builds","text":"When Jack-in starts it will depend on the project type, and whether ClojureScript is involved or not, and if it is, what kind of ClojureScript project, what will happen next. Calva will analyze the project files and will then give you prompts with selections based on what is found there. You will need some basic knowledge about the project and the project type terminologies to answer the prompts. There are ways to tell Calva the answers to these prompts beforehand, so that Jack-in can be a zero-prompting command. Read on.","title":"Aliases, profiles, builds"},{"location":"connect/#customizing-jack-in","text":"The main mechanism for customizing your Jack-in, including automating menu selections, and custom CLJS REPL types is Custom Connect Sequences . There are also these settings: calva.jackInEnv : An object with environment variables that will be added to the environment of the Jack-in process. calva.myCljAliases : An array of deps.edn aliases not found in the project file. Use this to tell Calva Jack-in to launch your REPL using your user defined aliases. calva.myLeinProfiles : An array of Leiningen profiles not found in project.clj . Use this to tell Calva Jack-in to launch your REPL using your user defined profiles. calva.openBrowserWhenFigwheelStarted : For Legacy Figwheel only. A boolean controlling if Calva should automatically launch your ClojureScript app, once it is compiled by Figwheel. Defaults to true . Note When processing the calva.jackInEnv setting you can refer to existing ENV variables with ${env:VARIABLE} .","title":"Customizing Jack-in"},{"location":"connect/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"connect/#command-not-found-errors","text":"If you get command not found error when Calva tries to start your project, and you know you have the command installed, it's probably because VS Code starts from an environment where the command is not on the $PATH . It can look like so: lein update-in :dependencies conj '[nrepl,\"0.8.3\"]' -- update-in :plugins conj '[cider/cider-nrepl,\"0.25.8\"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- repl :headless /bin/sh: lein: command not found Jack-in process exited. Status: 127 The fix is to always start VS Code from the command line: $ code You might need to first run the Shell Command: Install code command in PATH . This will also make sure your REPL has access to the environment you probably expect it to have access to. See below.","title":"Command not found errors"},{"location":"connect/#environment-variables-are-not-readable-from-repl","text":"If you've added environment variables in your OS, such as in your ~/.bashrc file (Linux), in order for them to be read in a REPL created by Calva's jackin command, VS Code must be started from a shell where the environment variables are defined. For example, if you can open a bash terminal and run echo $SOME_VAR and see the value there, then open VS Code from that terminal with code <project path> .","title":"Environment variables are not readable From REPL"},{"location":"connect/#connecting-wo-jack-in","text":"If, for whatever reasons, you can't use Jack-in with your project (possibly because the REPL is started as part of some other job) all is not lost. Old fashioned Connect to a running REPL is still there for you. For all features to work in Calva while connecting to a running REPL, your environment needs to have REPL related dependencies set up. However, just as before it can be tricky to get the dependencies right. Consider using Jack in to inform yourself on how to start your REPL to Calva's satisfaction. When you use Jack in, Calva starts a VS Code task for it and the command line used is displayed in the terminal pane used to handle the task. Reading that command line tells you what dependencies are needed for your project. Even better: Copying that command line gives you the command to start the REPL with the correct dependencies. All this said, I still recommend you challenge the conclusion that you can't use Jack-in. Note There is a Calva command for copying the Jack-in command line to the clipboard.","title":"Connecting w/o Jack-in"},{"location":"contribute/","text":"Contribute to Calva There are many ways to contribute: Become a sponsor Give us feedback: File issues Talk to us ia the #calva channel at the Clojurians Slack (use the latter link to grab an invite) Provide PRs, see the Calva wiki about How to Hack on Calva Give us feedback, preferably v Cheer us on. (Same channel) Help us test things like reported issues, new features, etcetera. See Testing VSIX Packages and Smoke Testing Make tutorials, write blog articles, spread the word Star the Calva repository Help us help beginners with Calva and Clojure, on Slack as well as IRL and wherever. Be creative! Happy Coding! \u2764\ufe0f","title":"Contribute to Calva"},{"location":"contribute/#contribute-to-calva","text":"There are many ways to contribute: Become a sponsor Give us feedback: File issues Talk to us ia the #calva channel at the Clojurians Slack (use the latter link to grab an invite) Provide PRs, see the Calva wiki about How to Hack on Calva Give us feedback, preferably v Cheer us on. (Same channel) Help us test things like reported issues, new features, etcetera. See Testing VSIX Packages and Smoke Testing Make tutorials, write blog articles, spread the word Star the Calva repository Help us help beginners with Calva and Clojure, on Slack as well as IRL and wherever. Be creative! Happy Coding! \u2764\ufe0f","title":"Contribute to Calva"},{"location":"custom-commands/","text":"Custom REPL Commands Calva supports configuration of custom command snippets that you can evaluate in the REPL at will. If your workflow has you repeatedly evaluate a particular piece of code, you can use the setting calva.customREPLCommandSnippets to configure it. Then either bind keyboard shortcuts to them or use the command Run Custom REPL Command to access it. The command will give you a menu with the snippets you have configured. The calva.customREPLCommandSnippets is an array of objects with the following fields (required fields in bold ): name : The name of the snippet as it will appear in the picker menu snippet : The code that will be evaluated key : A key can be used to reference the snippet from Run Custom REPL Command keyboard shortcut arguments. It will also be used in the quick-pick menu. ns : A namespace to evaluate the command in. If omitted the command will be executed in the namespace of the current editor. repl : Which repl session to use for the evaluation. Either \"clj\" or \"cljs\" . Omit if you want to use the session of the current editor. There are also substitutions available, which will take elements from the current state of Calva and splice them in to the text of your command before executing it. They are $line : Current line number in editor $column : Current column number in editor $file : Full name of current file edited $ns : The namespace used for evaluating the command $selection : The currently selected text $current-form : The text of the current form $enclosing-form : The text of the current enclosing form $top-level-form The text of the current top level form $current-fn : The sexpr/form at call position in the current list, e.g. str with (defn foo [] (str \"foo\" \"bar|\")) $top-level-defined-symbol : The second symbol of the top level form, e.g. foo with (defn foo [] (str \"foo\" \"bar|\")) $head : The text between the start of the current list to the cursor $tail : The text between the cursor and the end of the current list User and Workspace settings Settings from your User (global) level and the workspace are merged. With these User settings: \"calva.customREPLCommandSnippets\" : [ { \"name\" : \"Call Current Form\" , \"key\" : \"c\" , \"snippet\" : \"($current-form)\" }, { \"name\" : \"Call Current Top Level Form\" , \"key\" : \"t\" , \"snippet\" : \"($top-level-form)\" }, { \"name\" : \"CLJ Test Top Level Defined Symbol\" , \"repl\" : \"clj\" , \"snippet\" : \"(clojure.test/test-var #'$top-level-defined-symbol)\" }, { \"name\" : \"CLJS Test Top Level Defined Symbol\" , \"repl\" : \"cljs\" , \"snippet\" : \"(cljs.test/test-var #'$top-level-defined-symbol)\" , \"key\" : \"tab\" } ], And these Workspace settings: \"calva.customREPLCommandSnippets\" : [ { \"name\" : \"Remount CLJS App\" , \"key\" : \"r\" , \"repl\" : \"cljs\" , \"ns\" : \"example.app\" , \"snippet\" : \"(start)\" } ], Issuing Run Custom REPL Command will then render this VS Code menu: The default keyboard shortcut for the command is ctrl+alt+space space . Binding keyboard shortcuts There are three ways to bind shortcuts to custom commands: Use a predefined key shortcut. These are predefined as ctrl+alt+space <something> , where <something> is one of: The digits 0 through 9 The English letters a through z Arrow keys right , left , up , or down One of tab , backspace , , , . , or - Bind calva.runCustomREPLCommand to a shortcut with whatever code you want to evaluate in args key. You have access to the substitution variables here as well. Bind calva.runCustomREPLCommand to a keyboard shortcut referencing the key of one of your calva.customREPLCommandSnippets . (If not using any of the key s mentioned in 1. )","title":"Custom REPL Commands"},{"location":"custom-commands/#custom-repl-commands","text":"Calva supports configuration of custom command snippets that you can evaluate in the REPL at will. If your workflow has you repeatedly evaluate a particular piece of code, you can use the setting calva.customREPLCommandSnippets to configure it. Then either bind keyboard shortcuts to them or use the command Run Custom REPL Command to access it. The command will give you a menu with the snippets you have configured. The calva.customREPLCommandSnippets is an array of objects with the following fields (required fields in bold ): name : The name of the snippet as it will appear in the picker menu snippet : The code that will be evaluated key : A key can be used to reference the snippet from Run Custom REPL Command keyboard shortcut arguments. It will also be used in the quick-pick menu. ns : A namespace to evaluate the command in. If omitted the command will be executed in the namespace of the current editor. repl : Which repl session to use for the evaluation. Either \"clj\" or \"cljs\" . Omit if you want to use the session of the current editor. There are also substitutions available, which will take elements from the current state of Calva and splice them in to the text of your command before executing it. They are $line : Current line number in editor $column : Current column number in editor $file : Full name of current file edited $ns : The namespace used for evaluating the command $selection : The currently selected text $current-form : The text of the current form $enclosing-form : The text of the current enclosing form $top-level-form The text of the current top level form $current-fn : The sexpr/form at call position in the current list, e.g. str with (defn foo [] (str \"foo\" \"bar|\")) $top-level-defined-symbol : The second symbol of the top level form, e.g. foo with (defn foo [] (str \"foo\" \"bar|\")) $head : The text between the start of the current list to the cursor $tail : The text between the cursor and the end of the current list","title":"Custom REPL Commands"},{"location":"custom-commands/#user-and-workspace-settings","text":"Settings from your User (global) level and the workspace are merged. With these User settings: \"calva.customREPLCommandSnippets\" : [ { \"name\" : \"Call Current Form\" , \"key\" : \"c\" , \"snippet\" : \"($current-form)\" }, { \"name\" : \"Call Current Top Level Form\" , \"key\" : \"t\" , \"snippet\" : \"($top-level-form)\" }, { \"name\" : \"CLJ Test Top Level Defined Symbol\" , \"repl\" : \"clj\" , \"snippet\" : \"(clojure.test/test-var #'$top-level-defined-symbol)\" }, { \"name\" : \"CLJS Test Top Level Defined Symbol\" , \"repl\" : \"cljs\" , \"snippet\" : \"(cljs.test/test-var #'$top-level-defined-symbol)\" , \"key\" : \"tab\" } ], And these Workspace settings: \"calva.customREPLCommandSnippets\" : [ { \"name\" : \"Remount CLJS App\" , \"key\" : \"r\" , \"repl\" : \"cljs\" , \"ns\" : \"example.app\" , \"snippet\" : \"(start)\" } ], Issuing Run Custom REPL Command will then render this VS Code menu: The default keyboard shortcut for the command is ctrl+alt+space space .","title":"User and Workspace settings"},{"location":"custom-commands/#binding-keyboard-shortcuts","text":"There are three ways to bind shortcuts to custom commands: Use a predefined key shortcut. These are predefined as ctrl+alt+space <something> , where <something> is one of: The digits 0 through 9 The English letters a through z Arrow keys right , left , up , or down One of tab , backspace , , , . , or - Bind calva.runCustomREPLCommand to a shortcut with whatever code you want to evaluate in args key. You have access to the substitution variables here as well. Bind calva.runCustomREPLCommand to a keyboard shortcut referencing the key of one of your calva.customREPLCommandSnippets . (If not using any of the key s mentioned in 1. )","title":"Binding keyboard shortcuts"},{"location":"customizing/","text":"Customizing Calva Don't like the defaults? On this page we can collect some of the customizations that people have done, and maybe write a thing or two about it some day. Tip for VS Code newcomers: The search box in Settings is your friend. Also, some Calva settings are more complex than the Settings UI can handle. VS Code will then show you a link to settings.json . And VS Code's built-in json extension is awesome. To add settings for Calva's Pretty Printing, for example, search for \u201dprettyprint\u201d in VS Code Settings and follow the link to settings.json . Start typing \u201dcalvapretty\u201d until auto-complete suggests calva.prettyPrintingOptions . Press ENTER and VS Code will fill in these defaults: \"calva.prettyPrintingOptions\" : { \"enabled\" : true , \"printEngine\" : \"pprint\" , \"width\" : 40 }, Clojure Defaults Calva sets some VS Code settings for all Clojure files. Some of these are needed for Calva to function correctly, which should not be tampered with unless you really know what you are doing, and some of them are convenient defaults. If you add a setting to your settings.json and accept the snippet help you get when you type \"[clojure]\" , you will get the Calva defaults pasted: \"[clojure]\" : { \"editor.wordSeparators\" : \"\\t ()\\\"':,;~@#$%^&{}[]`\" , \"editor.autoClosingBrackets\" : \"always\" , \"editor.autoClosingQuotes\" : \"always\" , \"editor.formatOnType\" : true , \"editor.autoIndent\" : \"full\" , \"editor.formatOnPaste\" : true , \"files.trimTrailingWhitespace\" : false , \"editor.matchBrackets\" : \"never\" , \"editor.renderIndentGuides\" : false , \"editor.parameterHints.enabled\" : false } Note The above editor.wordSeparators setting establish Clojure word boundaries. E.g - is considered to be part of words. This affects what happens when double-clicking symbols and other things. If you want to include - or something else as a word boundary, just add it to the setting. Pretty Printing Calva's pretty printing mode can be configured a bit. See Pretty Printing . Calva Highlight Calva takes care of syntax highlighting, and also provides some features not available through VS Code's highlighting mechanism. These extras include rainbow parens, sane bracket matching, and comment form dimming/highlighting. You are in charge of how brackets and comments are highlighted via the calva.highlight.<setting> settings: Setting Meaning Example enableBracketColors Enable rainbow colors true rainbowIndentGuides Enable rainbow indent guides true highlightActiveIndent Highlight the active indent guide true bracketColors Which colors to use [\"#000\", \"#999\"] cycleBracketColors Whether same colors should be reused for deeply nested brackets true misplacedBracketStyle Style of misplaced bracket { \"border\": \"2px solid #c33\" } matchedBracketStyle Style of bracket pair highlight {\"backgroundColor\": \"#E0E0E0\"} ignoredFormStyle Style of #_... form {\"textDecoration\": \"none; opacity: 0.5\"} commentFormStyle Style of (comment ...) form {\"fontStyle\": \"italic\"} Note The VS Code built-in settings editor.renderIndentGuides and editor.highlightActiveIndent do not have any effect, since the former is switched off by the Clojure Defaults , mentioned above. Use Calva Highlight's rainbowIndentGuides and highlightActiveIndent instead. They are different from the built in ones in that they are independent, meaning you can choose to have active indent highlighted while the guides generally are not rendered (this is the default, even). Automatic Parameter Hints Poppup Calva has helpful parameter hints to aid when typing function calls. They look like so: To have the hints automatically pop up when you are typing, set editor.parameterHints.enabled to true in the above [clojure] scoped setting. (To call them up on demand the default VS Code keybindings are cmd+shift+space on Mac and ctrl+shift+space on Linux/Windows.) Code Formatting See Formatting for information on how to configure this. Jack-in and Connect Sequences Jack-in and Connect are very customizable through Custom Connect Sequences . Jack-in Dependency Versions The versions of the dependencies Calva Jack-in injects in order for the REPL session to support IDE features are configurable via the VS Code settings calva.jackInDependencyVersions . At the time of this writing the default versions are: Dependency Version Description nrepl 0.8.3 nREPL is the wonderful piece of software that gives Calva a structured and extensible connection to the REPL in your Clojure and ClojureScript projects. cider-nrepl 0.25.8 cider-nrepl is middleware that extends the nREPL connection with all sorts of nice stuff that Calva uses to give you a delightful IDE experience. cider/piggieback 0.5.2 Piggieback is used to create nREPL sessions in ClojureScript projects. (Not with shadow-cljs projects though, which provides its own middleware for this.) Key bindings Most of Calva's commands have default keybindings. They are only defaults, though, and you can change keybindings as you wish. To facilitate precision in binding keys Calva keeps some when clause contexts updated. When Clause Contexts The following contexts are available with Calva: calva:keybindingsEnabled : a master switch that you find in the settings paredit:keyMap : strict , original , or none from the corresponding Calva setting (see Paredit ) calva:connected : true when Calva is connected to a REPL (there is also calva:connecting || calva:launching ) calva:outputWindowActive : true when the Output/REPL window has input focus calva:replHistoryCommandsActive : true when the cursor is in the Output/REPL window at the top level after the last prompt calva:outputWindowSubmitOnEnter : true when the cursor is adjacent after the last top level form in the Output/REPL window calva:cursorInString : true when the cursor/caret is in a string or a regexp calva:cursorInComment : true when the cursor is in, or adjacent to a line comment calva:cursorBeforeComment : true when the cursor is adjacent before a line comment calva:cursorAfterComment : true when the cursor is adjacent after a line comment calva:cursorAtStartOfLine : true when the cursor is at the start of a line including any leading whitespace calva:cursorAtEndOfLine : true when the cursor is at the end of a line including any trailing whitespace calva:showReplUi : false when Calva's REPL UI is disabled through the corresponding setting Some Custom Bindings Here is a collection of custom keybindings from here and there. Replace all Calva ctrl+alt+... key bindings with ctrl+shift+... , for keyboards lacking alt key: this gist Replace the default Calva \u201dprefix\u201d, ctrl+alt+c to just alt+v : WebWItch's keybindings.json (Please note, that alt+v does not work for some locales, but for when it works it is much less clunky than the default prefix). Here the Calva key is switched for ctrl+, : manas_marthi's keybindings Keybindings for Emacs users Are you a vim extension user? See: Using with VIM extension . Move by word By default Calva changes the move-by-word key bindings to move by sexpr/form when the cursor is in structural Clojure code. Within line comments the editor default word movement is active. If you want the VS Code default word movement shortcuts, use these settings: { \"key\" : \"ctrl+right\" , \"win\" : \"ctrl+right\" , \"mac\" : \"alt+right\" , \"command\" : \"cursorWordRight\" }, { \"key\" : \"ctrl+left\" , \"win\" : \"ctrl+left\" , \"mac\" : \"alt+left\" , \"command\" : \"cursorWordLeft\" }, { \"key\" : \"ctrl+right\" , \"mac\" : \"ctrl+right\" , \"win\" : \"alt+right\" , \"command\" : \"paredit.forwardSexp\" , \"when\" : \"calva:keybindingsEnabled && editorTextFocus && editorLangId == 'clojure' && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+left\" , \"mac\" : \"ctrl+left\" , \"win\" : \"alt+left\" , \"command\" : \"paredit.backwardSexp\" , \"when\" : \"calva:keybindingsEnabled && editorTextFocus && editorLangId == 'clojure' && paredit:keyMap =~ /original|strict/\" } Use it as an inspiration for customizing things to your own liking. \ud83d\ude04 Wrap using ( , [ , { (like Cursive) Something I use in IntelliJ/Cursive is the ability to select an expression and hit one of ( , [ , { to wrap it. And after wrapping the expression I don't want the selection anymore, so if I were wrapping (foo) then I would want to get ( | (foo)) where | would be my cursor. Here's how you can make this work with Calva Paredit: Update all of the Paredit: Wrap Around ... commands so that their respective shortcuts are the wrappers themselves and update the when clause to include editorHasSelection (otherwise when you open a paren the next expression would get slurped in). The change would look like this in your keybindings.json : { \"key\" : \"shift+9\" , \"command\" : \"paredit.wrapAroundParens\" , \"when\" : \"editorTextFocus && editorHasSelection && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"[\" , \"command\" : \"paredit.wrapAroundSquare\" , \"when\" : \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"shift+[\" , \"command\" : \"paredit.wrapAroundCurly\" , \"when\" : \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }","title":"Customizing Calva"},{"location":"customizing/#customizing-calva","text":"Don't like the defaults? On this page we can collect some of the customizations that people have done, and maybe write a thing or two about it some day. Tip for VS Code newcomers: The search box in Settings is your friend. Also, some Calva settings are more complex than the Settings UI can handle. VS Code will then show you a link to settings.json . And VS Code's built-in json extension is awesome. To add settings for Calva's Pretty Printing, for example, search for \u201dprettyprint\u201d in VS Code Settings and follow the link to settings.json . Start typing \u201dcalvapretty\u201d until auto-complete suggests calva.prettyPrintingOptions . Press ENTER and VS Code will fill in these defaults: \"calva.prettyPrintingOptions\" : { \"enabled\" : true , \"printEngine\" : \"pprint\" , \"width\" : 40 },","title":"Customizing Calva"},{"location":"customizing/#clojure-defaults","text":"Calva sets some VS Code settings for all Clojure files. Some of these are needed for Calva to function correctly, which should not be tampered with unless you really know what you are doing, and some of them are convenient defaults. If you add a setting to your settings.json and accept the snippet help you get when you type \"[clojure]\" , you will get the Calva defaults pasted: \"[clojure]\" : { \"editor.wordSeparators\" : \"\\t ()\\\"':,;~@#$%^&{}[]`\" , \"editor.autoClosingBrackets\" : \"always\" , \"editor.autoClosingQuotes\" : \"always\" , \"editor.formatOnType\" : true , \"editor.autoIndent\" : \"full\" , \"editor.formatOnPaste\" : true , \"files.trimTrailingWhitespace\" : false , \"editor.matchBrackets\" : \"never\" , \"editor.renderIndentGuides\" : false , \"editor.parameterHints.enabled\" : false } Note The above editor.wordSeparators setting establish Clojure word boundaries. E.g - is considered to be part of words. This affects what happens when double-clicking symbols and other things. If you want to include - or something else as a word boundary, just add it to the setting.","title":"Clojure Defaults"},{"location":"customizing/#pretty-printing","text":"Calva's pretty printing mode can be configured a bit. See Pretty Printing .","title":"Pretty Printing"},{"location":"customizing/#calva-highlight","text":"Calva takes care of syntax highlighting, and also provides some features not available through VS Code's highlighting mechanism. These extras include rainbow parens, sane bracket matching, and comment form dimming/highlighting. You are in charge of how brackets and comments are highlighted via the calva.highlight.<setting> settings: Setting Meaning Example enableBracketColors Enable rainbow colors true rainbowIndentGuides Enable rainbow indent guides true highlightActiveIndent Highlight the active indent guide true bracketColors Which colors to use [\"#000\", \"#999\"] cycleBracketColors Whether same colors should be reused for deeply nested brackets true misplacedBracketStyle Style of misplaced bracket { \"border\": \"2px solid #c33\" } matchedBracketStyle Style of bracket pair highlight {\"backgroundColor\": \"#E0E0E0\"} ignoredFormStyle Style of #_... form {\"textDecoration\": \"none; opacity: 0.5\"} commentFormStyle Style of (comment ...) form {\"fontStyle\": \"italic\"} Note The VS Code built-in settings editor.renderIndentGuides and editor.highlightActiveIndent do not have any effect, since the former is switched off by the Clojure Defaults , mentioned above. Use Calva Highlight's rainbowIndentGuides and highlightActiveIndent instead. They are different from the built in ones in that they are independent, meaning you can choose to have active indent highlighted while the guides generally are not rendered (this is the default, even).","title":"Calva Highlight"},{"location":"customizing/#automatic-parameter-hints-poppup","text":"Calva has helpful parameter hints to aid when typing function calls. They look like so: To have the hints automatically pop up when you are typing, set editor.parameterHints.enabled to true in the above [clojure] scoped setting. (To call them up on demand the default VS Code keybindings are cmd+shift+space on Mac and ctrl+shift+space on Linux/Windows.)","title":"Automatic Parameter Hints Poppup"},{"location":"customizing/#code-formatting","text":"See Formatting for information on how to configure this.","title":"Code Formatting"},{"location":"customizing/#jack-in-and-connect-sequences","text":"Jack-in and Connect are very customizable through Custom Connect Sequences .","title":"Jack-in and Connect Sequences"},{"location":"customizing/#jack-in-dependency-versions","text":"The versions of the dependencies Calva Jack-in injects in order for the REPL session to support IDE features are configurable via the VS Code settings calva.jackInDependencyVersions . At the time of this writing the default versions are: Dependency Version Description nrepl 0.8.3 nREPL is the wonderful piece of software that gives Calva a structured and extensible connection to the REPL in your Clojure and ClojureScript projects. cider-nrepl 0.25.8 cider-nrepl is middleware that extends the nREPL connection with all sorts of nice stuff that Calva uses to give you a delightful IDE experience. cider/piggieback 0.5.2 Piggieback is used to create nREPL sessions in ClojureScript projects. (Not with shadow-cljs projects though, which provides its own middleware for this.)","title":"Jack-in Dependency Versions"},{"location":"customizing/#key-bindings","text":"Most of Calva's commands have default keybindings. They are only defaults, though, and you can change keybindings as you wish. To facilitate precision in binding keys Calva keeps some when clause contexts updated.","title":"Key bindings"},{"location":"customizing/#when-clause-contexts","text":"The following contexts are available with Calva: calva:keybindingsEnabled : a master switch that you find in the settings paredit:keyMap : strict , original , or none from the corresponding Calva setting (see Paredit ) calva:connected : true when Calva is connected to a REPL (there is also calva:connecting || calva:launching ) calva:outputWindowActive : true when the Output/REPL window has input focus calva:replHistoryCommandsActive : true when the cursor is in the Output/REPL window at the top level after the last prompt calva:outputWindowSubmitOnEnter : true when the cursor is adjacent after the last top level form in the Output/REPL window calva:cursorInString : true when the cursor/caret is in a string or a regexp calva:cursorInComment : true when the cursor is in, or adjacent to a line comment calva:cursorBeforeComment : true when the cursor is adjacent before a line comment calva:cursorAfterComment : true when the cursor is adjacent after a line comment calva:cursorAtStartOfLine : true when the cursor is at the start of a line including any leading whitespace calva:cursorAtEndOfLine : true when the cursor is at the end of a line including any trailing whitespace calva:showReplUi : false when Calva's REPL UI is disabled through the corresponding setting","title":"When Clause Contexts"},{"location":"customizing/#some-custom-bindings","text":"Here is a collection of custom keybindings from here and there. Replace all Calva ctrl+alt+... key bindings with ctrl+shift+... , for keyboards lacking alt key: this gist Replace the default Calva \u201dprefix\u201d, ctrl+alt+c to just alt+v : WebWItch's keybindings.json (Please note, that alt+v does not work for some locales, but for when it works it is much less clunky than the default prefix). Here the Calva key is switched for ctrl+, : manas_marthi's keybindings Keybindings for Emacs users Are you a vim extension user? See: Using with VIM extension .","title":"Some Custom Bindings"},{"location":"customizing/#move-by-word","text":"By default Calva changes the move-by-word key bindings to move by sexpr/form when the cursor is in structural Clojure code. Within line comments the editor default word movement is active. If you want the VS Code default word movement shortcuts, use these settings: { \"key\" : \"ctrl+right\" , \"win\" : \"ctrl+right\" , \"mac\" : \"alt+right\" , \"command\" : \"cursorWordRight\" }, { \"key\" : \"ctrl+left\" , \"win\" : \"ctrl+left\" , \"mac\" : \"alt+left\" , \"command\" : \"cursorWordLeft\" }, { \"key\" : \"ctrl+right\" , \"mac\" : \"ctrl+right\" , \"win\" : \"alt+right\" , \"command\" : \"paredit.forwardSexp\" , \"when\" : \"calva:keybindingsEnabled && editorTextFocus && editorLangId == 'clojure' && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+left\" , \"mac\" : \"ctrl+left\" , \"win\" : \"alt+left\" , \"command\" : \"paredit.backwardSexp\" , \"when\" : \"calva:keybindingsEnabled && editorTextFocus && editorLangId == 'clojure' && paredit:keyMap =~ /original|strict/\" } Use it as an inspiration for customizing things to your own liking. \ud83d\ude04","title":"Move by word"},{"location":"customizing/#wrap-using-like-cursive","text":"Something I use in IntelliJ/Cursive is the ability to select an expression and hit one of ( , [ , { to wrap it. And after wrapping the expression I don't want the selection anymore, so if I were wrapping (foo) then I would want to get ( | (foo)) where | would be my cursor. Here's how you can make this work with Calva Paredit: Update all of the Paredit: Wrap Around ... commands so that their respective shortcuts are the wrappers themselves and update the when clause to include editorHasSelection (otherwise when you open a paren the next expression would get slurped in). The change would look like this in your keybindings.json : { \"key\" : \"shift+9\" , \"command\" : \"paredit.wrapAroundParens\" , \"when\" : \"editorTextFocus && editorHasSelection && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"[\" , \"command\" : \"paredit.wrapAroundSquare\" , \"when\" : \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"shift+[\" , \"command\" : \"paredit.wrapAroundCurly\" , \"when\" : \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }","title":"Wrap using (, [, { (like Cursive)"},{"location":"debugger/","text":"Debugger Calva comes with a powerful expression-based debugger, inspired by Cider 's debugger, and using the same underlying library, cider-nrepl . We hope you love it! Note The debugger currently does not support ClojureScript. Calva's debugger utilizes cider-nrepl for debugging. See this Cider issue for more information. Features Current Instrument functions for debugging with ctrl+alt+c i Instrument a function manually with #dbg (as opposed to the above command) Set individual breakpoints with #break Continue to next breakpoint Step over form Step into form Step out of form Evaluate code in the debug context See variable values in the debugger side pane See variable values on hover in the editor Future goals See structured variables in the debugger side pane (currently maps and collections are just shown as strings) Inject values into the debug context Trace: continue, printing expressions and their values Dependencies The debugger itself relies pretty heavily on cider-nrepl , as do other parts of Calva. This library is loaded as a dependency when you use Calva Jack-in. If you are not using Calva Jack-in, you can add these dependencies in your project definition or user profile. See the Calva Jack-in guide for more information. Using the Debugger If you're new to Clojure or expression-based debuggers, this debugger may function differently than what you're used to. Instead of placing breakpoints in the side margin and then hitting F5 to start debugging, you instead use Clojure reader tags, #break and #dbg , to denote breakpoints anywhere in a Clojure form. When you evaluate a call to a function that has been evaluated with that reader tag, the debugger will start when execution reaches the first breakpoint. There's also a convenience command to instrument functions. Read below about both options. Note The debugger is not configured via a launch.json file, and is not started in the same way as you may be used to when working with other languages in VS Code. The debugger is used by way of the REPL. If you are new to Clojure, please visit the Getting Started section of the documentation and get familiar with evaluating code using the REPL before using the debugger. Instrumenting a Function You can instrument a top level function for debugging with ctrl+alt+c i . This places invisible breakpoints throughout the function where pausing makes sense. When you evaluate a call to this function, the debugger will start and execution will pause at the first breakpoint. Annotations show the value of the form at the cursor. A border is placed around the definition of the instrumented function and its references to show that it's instrumented. You can remove instrumentation by evaluating the function again normally, such as with alt+enter . Setting Breakpoints with #break You can insert a breakpoint manually into any code by placing a #break in front of the form where you want execution to pause, and then evaluating the top level form with alt+enter . When you evaluate a call to this code the VS Code debugger will start, the cursor will move to right after the form that's preceded by #break , and the line will be highlighted to show execution is paused there. Note Code will be executed up to and including the form after the breakpoint. Conditional Breakpoints You can set conditional breapoints by adding metadata before the form that the #break applies to. ( defn print-nums [ n ] ( dotimes [ i n ] # break ^ { :break/when ( = i 7 )} ;; This breakpoint will only be hit when i equals 7 ( prn i ))) Instrumenting a Form with #dbg Adding #dbg before a form then evaluating the form with alt+enter will instrument the form. This has the same effect as using the instrument command . Evaluating Code in the Paused Context When execution is paused at a breakpoint, you can evaluate code in that context. This can be done in the editor or in the REPL window, as usual. Viewing Variable Values While debugging, you can view the values of variables in VS Code's debugger side pane. You can also view values by hovering over the variables in the editor. Currently, values for collections and maps are shown as strings, but we plan to make them structured in the future. For now, if you want to see the value of a large structured variable, you can evaluate the variable from the editor or from the REPL window. Viewing the Call Stack While debugging, you can view the call stack in VS Code's call stack side pane. Clicking the stack frames will show the related line of code in an editor. Note You may only see one stack frame in the call stack side pane, as the change for adding additional frames was rolled back due to an issue. You can follow the change for this at #1150 . Stepping Commands You can use VS Code's debugger UI to advance execution while debugging. Note Clicking restart does nothing, since this functionality does not make sense for our debugger. Continue - Continues without stopping for the current breakpoint Step over - Continues to the next breakpoint Step in - Steps in to the function about to be called. If the next breakpoint is not around a function call, does the same as next. Note that not all functions can be stepped in to - only normal functions stored in vars, for which cider-nrepl can find the source. You cannot currently step in to multimethods, protocol functions, or functions in clojure.core (although multimethods and protocols can be instrumented manually). Step out - Steps to the next breakpoint that is outside of the current sexp Restart - Does nothing. To restart debugging, you can hit disconnect or continue execution through the final result, then re-evaluate the expression that started the debugger. Disconnect - Disconnects the debugger Caveats Breakpoints in loop/recur One construct where the debugger is limited is loop / recur . As recur always has to appear in a tail-position inside a loop or a fn and the debugger uses macros to interleave breakpoints in the forms, it might happen that a recur no longer appears in a tail position. In that case we have to avoid setting up the breakpoint. An example of such a case is: ( loop [ i 0 ] # break ( when ( < i 10 ) ( println i ) ( recur ( inc i )))) Here the breakpoint is exactly in front of a form that contains as its last expression a recur which is wrapped in a loop. This breakpoint has no effect. This does not mean you cannot use the debugger with loop , it just means you have to set your debug statements more carefully. Loading the File and \"Eval On Save\" When you load a file, any breakpoints that were previously set in functions will be unset. If you have the \"Eval On Save\" setting enabled, your file is also loaded with each save, therefore saving the file will remove breakpoints previously set. Troubleshooting Debugger hangs when stepping over infinite seqs This is because the debugger tries to evaluate the form when it's stepped over, and if clojure.core/*print-length* is set to nil as it is by default, evaluation will never complete. If you want to debug a form with an infinite seq, make sure to set *print-length* beforehand. For example: ( set! *print-length* 3 ) ;; Or, to be more precise ( set! clojure.core/*print-length* 3 ) Calva does not set this for you during debug mode, instead leaving it up to you to decide the value. My breakpoint isn't being hit It's likely that your breakpoint is in a place that cider-nrepl does not see as an appropriate place to break execution. For example, if you put a breakpoint before a literal number, it will not be hit, because there's no need to show the value of a literal. ( defn simple [ x ] ( + 1 # break 1 )) ;; This breakpoint will not be hit Another possible issue is that you're loading the file again after setting breakpoints, which unsets them. See Loading the File and \"Eval On Save\" under Caveats. My breakpoint in a test isn't being hit If you're using the test commands like \"Run current test\" to run your tests, breakpoints will not be hit. This is because Calva loads the file before running the tests to make sure the latest version of test code is being run, and when the file is loaded, breakpoints are unset. If you want a breakpoint to work within the test, evaluate the test form with a breakpoint tag in it, then call the test directly. \"No reader function for tag\" error If you get an error like this, it's likely that you connected to a REPL instead of jacking in, and you don't have the proper depednencies loaded in your REPL. You can run the command \"Copy Jack-in Command to Clipboard\" to see what command would be run if you jacked in. Most importantly, make sure you have cider/cider-nrepl as a dependency, and cider.nrepl/cider-middleware as middleware loaded in your REPL. For example, this is a jack-in command for a deps.edn project: clojure -Sdeps '{:deps {nrepl/nrepl {:mvn/version,\"0.8.3\"},cider/cider-nrepl {:mvn/version,\"0.25.8\"}}}' -m nrepl.cmdline --middleware \"[cider.nrepl/cider-middleware]\"","title":"Debugger"},{"location":"debugger/#debugger","text":"Calva comes with a powerful expression-based debugger, inspired by Cider 's debugger, and using the same underlying library, cider-nrepl . We hope you love it! Note The debugger currently does not support ClojureScript. Calva's debugger utilizes cider-nrepl for debugging. See this Cider issue for more information.","title":"Debugger"},{"location":"debugger/#features","text":"","title":"Features"},{"location":"debugger/#current","text":"Instrument functions for debugging with ctrl+alt+c i Instrument a function manually with #dbg (as opposed to the above command) Set individual breakpoints with #break Continue to next breakpoint Step over form Step into form Step out of form Evaluate code in the debug context See variable values in the debugger side pane See variable values on hover in the editor","title":"Current"},{"location":"debugger/#future-goals","text":"See structured variables in the debugger side pane (currently maps and collections are just shown as strings) Inject values into the debug context Trace: continue, printing expressions and their values","title":"Future goals"},{"location":"debugger/#dependencies","text":"The debugger itself relies pretty heavily on cider-nrepl , as do other parts of Calva. This library is loaded as a dependency when you use Calva Jack-in. If you are not using Calva Jack-in, you can add these dependencies in your project definition or user profile. See the Calva Jack-in guide for more information.","title":"Dependencies"},{"location":"debugger/#using-the-debugger","text":"If you're new to Clojure or expression-based debuggers, this debugger may function differently than what you're used to. Instead of placing breakpoints in the side margin and then hitting F5 to start debugging, you instead use Clojure reader tags, #break and #dbg , to denote breakpoints anywhere in a Clojure form. When you evaluate a call to a function that has been evaluated with that reader tag, the debugger will start when execution reaches the first breakpoint. There's also a convenience command to instrument functions. Read below about both options. Note The debugger is not configured via a launch.json file, and is not started in the same way as you may be used to when working with other languages in VS Code. The debugger is used by way of the REPL. If you are new to Clojure, please visit the Getting Started section of the documentation and get familiar with evaluating code using the REPL before using the debugger.","title":"Using the Debugger"},{"location":"debugger/#instrumenting-a-function","text":"You can instrument a top level function for debugging with ctrl+alt+c i . This places invisible breakpoints throughout the function where pausing makes sense. When you evaluate a call to this function, the debugger will start and execution will pause at the first breakpoint. Annotations show the value of the form at the cursor. A border is placed around the definition of the instrumented function and its references to show that it's instrumented. You can remove instrumentation by evaluating the function again normally, such as with alt+enter .","title":"Instrumenting a Function"},{"location":"debugger/#setting-breakpoints-with-break","text":"You can insert a breakpoint manually into any code by placing a #break in front of the form where you want execution to pause, and then evaluating the top level form with alt+enter . When you evaluate a call to this code the VS Code debugger will start, the cursor will move to right after the form that's preceded by #break , and the line will be highlighted to show execution is paused there. Note Code will be executed up to and including the form after the breakpoint.","title":"Setting Breakpoints with #break"},{"location":"debugger/#conditional-breakpoints","text":"You can set conditional breapoints by adding metadata before the form that the #break applies to. ( defn print-nums [ n ] ( dotimes [ i n ] # break ^ { :break/when ( = i 7 )} ;; This breakpoint will only be hit when i equals 7 ( prn i )))","title":"Conditional Breakpoints"},{"location":"debugger/#instrumenting-a-form-with-dbg","text":"Adding #dbg before a form then evaluating the form with alt+enter will instrument the form. This has the same effect as using the instrument command .","title":"Instrumenting a Form with #dbg"},{"location":"debugger/#evaluating-code-in-the-paused-context","text":"When execution is paused at a breakpoint, you can evaluate code in that context. This can be done in the editor or in the REPL window, as usual.","title":"Evaluating Code in the Paused Context"},{"location":"debugger/#viewing-variable-values","text":"While debugging, you can view the values of variables in VS Code's debugger side pane. You can also view values by hovering over the variables in the editor. Currently, values for collections and maps are shown as strings, but we plan to make them structured in the future. For now, if you want to see the value of a large structured variable, you can evaluate the variable from the editor or from the REPL window.","title":"Viewing Variable Values"},{"location":"debugger/#viewing-the-call-stack","text":"While debugging, you can view the call stack in VS Code's call stack side pane. Clicking the stack frames will show the related line of code in an editor. Note You may only see one stack frame in the call stack side pane, as the change for adding additional frames was rolled back due to an issue. You can follow the change for this at #1150 .","title":"Viewing the Call Stack"},{"location":"debugger/#stepping-commands","text":"You can use VS Code's debugger UI to advance execution while debugging. Note Clicking restart does nothing, since this functionality does not make sense for our debugger. Continue - Continues without stopping for the current breakpoint Step over - Continues to the next breakpoint Step in - Steps in to the function about to be called. If the next breakpoint is not around a function call, does the same as next. Note that not all functions can be stepped in to - only normal functions stored in vars, for which cider-nrepl can find the source. You cannot currently step in to multimethods, protocol functions, or functions in clojure.core (although multimethods and protocols can be instrumented manually). Step out - Steps to the next breakpoint that is outside of the current sexp Restart - Does nothing. To restart debugging, you can hit disconnect or continue execution through the final result, then re-evaluate the expression that started the debugger. Disconnect - Disconnects the debugger","title":"Stepping Commands"},{"location":"debugger/#caveats","text":"","title":"Caveats"},{"location":"debugger/#breakpoints-in-looprecur","text":"One construct where the debugger is limited is loop / recur . As recur always has to appear in a tail-position inside a loop or a fn and the debugger uses macros to interleave breakpoints in the forms, it might happen that a recur no longer appears in a tail position. In that case we have to avoid setting up the breakpoint. An example of such a case is: ( loop [ i 0 ] # break ( when ( < i 10 ) ( println i ) ( recur ( inc i )))) Here the breakpoint is exactly in front of a form that contains as its last expression a recur which is wrapped in a loop. This breakpoint has no effect. This does not mean you cannot use the debugger with loop , it just means you have to set your debug statements more carefully.","title":"Breakpoints in loop/recur"},{"location":"debugger/#loading-the-file-and-eval-on-save","text":"When you load a file, any breakpoints that were previously set in functions will be unset. If you have the \"Eval On Save\" setting enabled, your file is also loaded with each save, therefore saving the file will remove breakpoints previously set.","title":"Loading the File and \"Eval On Save\""},{"location":"debugger/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"debugger/#debugger-hangs-when-stepping-over-infinite-seqs","text":"This is because the debugger tries to evaluate the form when it's stepped over, and if clojure.core/*print-length* is set to nil as it is by default, evaluation will never complete. If you want to debug a form with an infinite seq, make sure to set *print-length* beforehand. For example: ( set! *print-length* 3 ) ;; Or, to be more precise ( set! clojure.core/*print-length* 3 ) Calva does not set this for you during debug mode, instead leaving it up to you to decide the value.","title":"Debugger hangs when stepping over infinite seqs"},{"location":"debugger/#my-breakpoint-isnt-being-hit","text":"It's likely that your breakpoint is in a place that cider-nrepl does not see as an appropriate place to break execution. For example, if you put a breakpoint before a literal number, it will not be hit, because there's no need to show the value of a literal. ( defn simple [ x ] ( + 1 # break 1 )) ;; This breakpoint will not be hit Another possible issue is that you're loading the file again after setting breakpoints, which unsets them. See Loading the File and \"Eval On Save\" under Caveats.","title":"My breakpoint isn't being hit"},{"location":"debugger/#my-breakpoint-in-a-test-isnt-being-hit","text":"If you're using the test commands like \"Run current test\" to run your tests, breakpoints will not be hit. This is because Calva loads the file before running the tests to make sure the latest version of test code is being run, and when the file is loaded, breakpoints are unset. If you want a breakpoint to work within the test, evaluate the test form with a breakpoint tag in it, then call the test directly.","title":"My breakpoint in a test isn't being hit"},{"location":"debugger/#no-reader-function-for-tag-error","text":"If you get an error like this, it's likely that you connected to a REPL instead of jacking in, and you don't have the proper depednencies loaded in your REPL. You can run the command \"Copy Jack-in Command to Clipboard\" to see what command would be run if you jacked in. Most importantly, make sure you have cider/cider-nrepl as a dependency, and cider.nrepl/cider-middleware as middleware loaded in your REPL. For example, this is a jack-in command for a deps.edn project: clojure -Sdeps '{:deps {nrepl/nrepl {:mvn/version,\"0.8.3\"},cider/cider-nrepl {:mvn/version,\"0.25.8\"}}}' -m nrepl.cmdline --middleware \"[cider.nrepl/cider-middleware]\"","title":"\"No reader function for tag\" error"},{"location":"emacs-keybindings/","text":"Emacs Keybindings Some keybindings to make it easier for Emacs users [ { \"key\" : \"ctrl+cmd+b\" , \"command\" : \"paredit.backwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+alt+left\" , \"command\" : \"-paredit.backwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"shift+cmd+]\" , \"command\" : \"-workbench.action.nextEditor\" }, { \"key\" : \"ctrl+shift+]\" , \"command\" : \"paredit.barfSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+right\" , \"command\" : \"-paredit.barfSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+[\" , \"command\" : \"paredit.barfSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+left\" , \"command\" : \"-paredit.barfSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+f\" , \"command\" : \"paredit.forwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+alt+right\" , \"command\" : \"-paredit.forwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+f\" , \"command\" : \"-workbench.action.toggleFullScreen\" }, { \"key\" : \"ctrl+shift+backspace\" , \"command\" : \"-paredit.killSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"shift+cmd+k\" , \"command\" : \"-editor.action.deleteLines\" , \"when\" : \"textInputFocus && !editorReadonly\" }, { \"key\" : \"ctrl+shift+0\" , \"command\" : \"paredit.slurpSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+right\" , \"command\" : \"-paredit.slurpSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+9\" , \"command\" : \"paredit.slurpSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+left\" , \"command\" : \"-paredit.slurpSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+c ctrl+c\" , \"command\" : \"calva.evaluateCurrentTopLevelForm\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+alt+c space\" , \"command\" : \"-calva.evaluateCurrentTopLevelForm\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+x ctrl+e\" , \"command\" : \"calva.evalCurrentTopLevelFormInREPLWindow\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+alt+c ctrl+alt+space\" , \"command\" : \"-calva.evalCurrentTopLevelFormInREPLWindow\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+x ctrl+s\" , \"command\" : \"workbench.action.files.save\" }, { \"key\" : \"cmd+s\" , \"command\" : \"-workbench.action.files.save\" }, { \"key\" : \"cmd+s\" , \"command\" : \"paredit.spliceSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+alt+s\" , \"command\" : \"-paredit.spliceSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+k\" , \"command\" : \"paredit.cutForwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+x right\" , \"command\" : \"-paredit.cutForwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+backspace\" , \"command\" : \"paredit.cutBackwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+x left\" , \"command\" : \"-paredit.cutBackwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+1\" , \"command\" : \"-workbench.action.openEditorAtIndex1\" }, { \"key\" : \"ctrl+1\" , \"command\" : \"editor.action.quickFix\" , \"when\" : \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\" : \"cmd+.\" , \"command\" : \"-editor.action.quickFix\" , \"when\" : \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\" : \"cmd+.\" , \"command\" : \"editor.action.revealDefinition\" , \"when\" : \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" }, { \"key\" : \"f12\" , \"command\" : \"-editor.action.revealDefinition\" , \"when\" : \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" } ]","title":"Emacs Keybindings"},{"location":"emacs-keybindings/#emacs-keybindings","text":"Some keybindings to make it easier for Emacs users [ { \"key\" : \"ctrl+cmd+b\" , \"command\" : \"paredit.backwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+alt+left\" , \"command\" : \"-paredit.backwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"shift+cmd+]\" , \"command\" : \"-workbench.action.nextEditor\" }, { \"key\" : \"ctrl+shift+]\" , \"command\" : \"paredit.barfSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+right\" , \"command\" : \"-paredit.barfSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+[\" , \"command\" : \"paredit.barfSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+left\" , \"command\" : \"-paredit.barfSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+f\" , \"command\" : \"paredit.forwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+alt+right\" , \"command\" : \"-paredit.forwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+f\" , \"command\" : \"-workbench.action.toggleFullScreen\" }, { \"key\" : \"ctrl+shift+backspace\" , \"command\" : \"-paredit.killSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"shift+cmd+k\" , \"command\" : \"-editor.action.deleteLines\" , \"when\" : \"textInputFocus && !editorReadonly\" }, { \"key\" : \"ctrl+shift+0\" , \"command\" : \"paredit.slurpSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+right\" , \"command\" : \"-paredit.slurpSexpForward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+9\" , \"command\" : \"paredit.slurpSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+left\" , \"command\" : \"-paredit.slurpSexpBackward\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+c ctrl+c\" , \"command\" : \"calva.evaluateCurrentTopLevelForm\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+alt+c space\" , \"command\" : \"-calva.evaluateCurrentTopLevelForm\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+x ctrl+e\" , \"command\" : \"calva.evalCurrentTopLevelFormInREPLWindow\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+alt+c ctrl+alt+space\" , \"command\" : \"-calva.evalCurrentTopLevelFormInREPLWindow\" , \"when\" : \"calva:activated\" }, { \"key\" : \"ctrl+x ctrl+s\" , \"command\" : \"workbench.action.files.save\" }, { \"key\" : \"cmd+s\" , \"command\" : \"-workbench.action.files.save\" }, { \"key\" : \"cmd+s\" , \"command\" : \"paredit.spliceSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+alt+s\" , \"command\" : \"-paredit.spliceSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+k\" , \"command\" : \"paredit.cutForwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+x right\" , \"command\" : \"-paredit.cutForwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+cmd+backspace\" , \"command\" : \"paredit.cutBackwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+shift+x left\" , \"command\" : \"-paredit.cutBackwardSexp\" , \"when\" : \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\" : \"ctrl+1\" , \"command\" : \"-workbench.action.openEditorAtIndex1\" }, { \"key\" : \"ctrl+1\" , \"command\" : \"editor.action.quickFix\" , \"when\" : \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\" : \"cmd+.\" , \"command\" : \"-editor.action.quickFix\" , \"when\" : \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\" : \"cmd+.\" , \"command\" : \"editor.action.revealDefinition\" , \"when\" : \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" }, { \"key\" : \"f12\" , \"command\" : \"-editor.action.revealDefinition\" , \"when\" : \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" } ]","title":"Emacs Keybindings"},{"location":"eval-tips/","text":"Code Evaluation Calva tries to make it easy to evaluate code, supporting interactive development. The fastest path to learning about it is to use the Fire up the Getting Started REPL command, which you can learn more about in the Getting Started section. NB: The below assumes you have read about Finding Calva Commands and Shortcuts . Evaluation in a File Editor Calva has many commands for evaluating forms, including the current form and the current top-level form . Some of the commands also let you choose what should happen with the results: Inline. This will display the results (or some of it, if it is long) inline in the editor. This also creates a hover pane including the full results and a button which will copy the results to the clipboard. There is also a command for copying the last result to the clipboard. The full results are always available in the output window . There is a command for showing the output window, allowing for a workflow where you either generally have it closed, or have it as one of the tabs in the same editor group as the files you are working with. To comments. This will add the results as line comments below the current line. Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results. Wait, Current Form? Top-level Form? These are important concepts in Calva in order for you to create your most effective workflow. Current Form Default shortcut for evaluating the current form: ctrl+enter . The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form , ctrl+alt+c s , to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides). Generally the current form is determined like so: If text is selected, then that text If the cursor is \u201din\u201d a symbol, then that symbol foob|ar ; foobar If the cursor is adjacent to a form (a symbol or a list of some kind), then that form ( foo bar | ( baz )) ; (baz) If the cursor is between to forms, then the left side form ( foo bar | ( baz )) ; bar If the cursor is before the first form of a line, then that form ( foo | bar ( baz )) ; bar Current Top-level Form Default shortcut for evaluating the current top level form: alt+enter . The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find def and defn (and defwhatever ) forms at the top level, which also is one major intended use for evaluating top level form: to define and redefine variables . However, Calva does not check the contents of the form in order to determine it as a top-level forms: all forms not enclosed in any other form are top level forms . An \u201dexception\u201d is introduced by the comment form. It will create a new top level context, so that any forms immediately inside a (commment ...) form will be considered top-level by Calva. This is to support a workflow with what is often referred to the Rich Comments . At the top level the selection of which form is the current top level form follows the same rules as those for the current form . Evaluate to Cursor There is also a command for evaluating the text from the start of the current list to where the cursor is. Convenient for checking intermediate results in thread or doto , or similar pipelines. The cursor is right behind :d in this form: ( ->> [ 1 1 2 3 5 8 13 21 ] ( partition 2 ) ( zipmap [ :a :b :c :d ]) :d| ; => (12 21) ( apply - ) ( Math/abs )) The default shortcut for this command is ctrl+alt+enter . Evaluate Top Level Form to Cursor This command has a default shortcut keybinding of shift+alt+enter . It will create a form from the start of the current top level form, up to the cursor, then fold the form, closing all brackets, and this will then be evaluated. Good for examining code blocks up to a certain point. Take this example and paste it in a file loaded into the REPL, then place the cursor in front of each line comment and try the command. ( comment ( do ( def colt-express { :name \"Colt Express\" :categories [ \"Family\" \"Strategy\" ] :play-time 40 :ratings { :pez 5.0 :kat 5.0 :wiw 5.0 ; 1, then eval `colt-express` :vig 3.0 :rex 5.0 :lun 4.0 }}) ( defn average [ coll ] ( / ( apply + coll ) ( count coll ))) ( let [ foo-express ( -> colt-express ( assoc :name \"Foo Express\" ) ( assoc-in [ :ratings :lyr ] 5.0 ) ( update-in [ :ratings :vig ] inc ))] ( ->> foo-express ; 2 :ratings ; 3 vals ; 4 average ; 5 )))) Evaluate Enclosing Form The default keyboard shortcut for evaluating the current enclosing form (the list the cursor is in) is ctrl+shift+enter . ( let [ foo :bar ] ( when false ( str| foo ))) ; => \":bar\" Copying the inline results There is a command called Copy last evaluation results , ctrl+alt+c ctrl+c . This works regardless if you have evaluated in a file editor or in a REPL window. Evaluating in a REPL window Since the REPL Window is mostly just a regular file, things work pretty similar at the REPL prompt. You use alt+enter to evaluate. Selecting the current form (default key binding ctrl+w on Mac and shift+alt+right on Windows and Linux) after evaluating will select the result.","title":"Code Evaluation"},{"location":"eval-tips/#code-evaluation","text":"Calva tries to make it easy to evaluate code, supporting interactive development. The fastest path to learning about it is to use the Fire up the Getting Started REPL command, which you can learn more about in the Getting Started section. NB: The below assumes you have read about Finding Calva Commands and Shortcuts .","title":"Code Evaluation"},{"location":"eval-tips/#evaluation-in-a-file-editor","text":"Calva has many commands for evaluating forms, including the current form and the current top-level form . Some of the commands also let you choose what should happen with the results: Inline. This will display the results (or some of it, if it is long) inline in the editor. This also creates a hover pane including the full results and a button which will copy the results to the clipboard. There is also a command for copying the last result to the clipboard. The full results are always available in the output window . There is a command for showing the output window, allowing for a workflow where you either generally have it closed, or have it as one of the tabs in the same editor group as the files you are working with. To comments. This will add the results as line comments below the current line. Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results.","title":"Evaluation in a File Editor"},{"location":"eval-tips/#wait-current-form-top-level-form","text":"These are important concepts in Calva in order for you to create your most effective workflow.","title":"Wait, Current Form? Top-level Form?"},{"location":"eval-tips/#current-form","text":"Default shortcut for evaluating the current form: ctrl+enter . The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form , ctrl+alt+c s , to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides). Generally the current form is determined like so: If text is selected, then that text If the cursor is \u201din\u201d a symbol, then that symbol foob|ar ; foobar If the cursor is adjacent to a form (a symbol or a list of some kind), then that form ( foo bar | ( baz )) ; (baz) If the cursor is between to forms, then the left side form ( foo bar | ( baz )) ; bar If the cursor is before the first form of a line, then that form ( foo | bar ( baz )) ; bar","title":"Current Form"},{"location":"eval-tips/#current-top-level-form","text":"Default shortcut for evaluating the current top level form: alt+enter . The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find def and defn (and defwhatever ) forms at the top level, which also is one major intended use for evaluating top level form: to define and redefine variables . However, Calva does not check the contents of the form in order to determine it as a top-level forms: all forms not enclosed in any other form are top level forms . An \u201dexception\u201d is introduced by the comment form. It will create a new top level context, so that any forms immediately inside a (commment ...) form will be considered top-level by Calva. This is to support a workflow with what is often referred to the Rich Comments . At the top level the selection of which form is the current top level form follows the same rules as those for the current form .","title":"Current Top-level Form"},{"location":"eval-tips/#evaluate-to-cursor","text":"There is also a command for evaluating the text from the start of the current list to where the cursor is. Convenient for checking intermediate results in thread or doto , or similar pipelines. The cursor is right behind :d in this form: ( ->> [ 1 1 2 3 5 8 13 21 ] ( partition 2 ) ( zipmap [ :a :b :c :d ]) :d| ; => (12 21) ( apply - ) ( Math/abs )) The default shortcut for this command is ctrl+alt+enter .","title":"Evaluate to Cursor"},{"location":"eval-tips/#evaluate-top-level-form-to-cursor","text":"This command has a default shortcut keybinding of shift+alt+enter . It will create a form from the start of the current top level form, up to the cursor, then fold the form, closing all brackets, and this will then be evaluated. Good for examining code blocks up to a certain point. Take this example and paste it in a file loaded into the REPL, then place the cursor in front of each line comment and try the command. ( comment ( do ( def colt-express { :name \"Colt Express\" :categories [ \"Family\" \"Strategy\" ] :play-time 40 :ratings { :pez 5.0 :kat 5.0 :wiw 5.0 ; 1, then eval `colt-express` :vig 3.0 :rex 5.0 :lun 4.0 }}) ( defn average [ coll ] ( / ( apply + coll ) ( count coll ))) ( let [ foo-express ( -> colt-express ( assoc :name \"Foo Express\" ) ( assoc-in [ :ratings :lyr ] 5.0 ) ( update-in [ :ratings :vig ] inc ))] ( ->> foo-express ; 2 :ratings ; 3 vals ; 4 average ; 5 ))))","title":"Evaluate Top Level Form to Cursor"},{"location":"eval-tips/#evaluate-enclosing-form","text":"The default keyboard shortcut for evaluating the current enclosing form (the list the cursor is in) is ctrl+shift+enter . ( let [ foo :bar ] ( when false ( str| foo ))) ; => \":bar\"","title":"Evaluate Enclosing Form"},{"location":"eval-tips/#copying-the-inline-results","text":"There is a command called Copy last evaluation results , ctrl+alt+c ctrl+c . This works regardless if you have evaluated in a file editor or in a REPL window.","title":"Copying the inline results"},{"location":"eval-tips/#evaluating-in-a-repl-window","text":"Since the REPL Window is mostly just a regular file, things work pretty similar at the REPL prompt. You use alt+enter to evaluate. Selecting the current form (default key binding ctrl+w on Mac and shift+alt+right on Windows and Linux) after evaluating will select the result.","title":"Evaluating in a REPL window"},{"location":"evaluation/","text":"Code Evaluation Calva tries to make it easy to evaluate code, supporting interactive development. The fastest path to learning about it is to use the Fire up the Getting Started REPL command, which you can learn more about in the Getting Started section. NB: The below assumes you have read about Finding Calva Commands and Shortcuts . Evaluation in a File Editor Calva has many commands for evaluating forms, including the current form and the current top-level form . Some of the commands also let you choose what should happen with the results: Inline. This will display the results (or some of it, if it is long) inline in the editor. This also creates a hover pane including the full results and a button which will copy the results to the clipboard. There is also a command for copying the last result to the clipboard. The full results are always available in the output window . There is a command for showing the output window, allowing for a workflow where you either generally have it closed, or have it as one of the tabs in the same editor group as the files you are working with. To comments. This will add the results as line comments below the current line. Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results. Wait, Current Form? Top-level Form? These are important concepts in Calva in order for you to create your most effective workflow. Current Form Default shortcut for evaluating the current form: ctrl+enter . The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form , ctrl+alt+c s , to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides). Generally the current form is determined like so: If text is selected, then that text If the cursor is \u201din\u201d a symbol, then that symbol foob|ar ; foobar If the cursor is adjacent to a form (a symbol or a list of some kind), then that form ( foo bar | ( baz )) ; (baz) If the cursor is between to forms, then the left side form ( foo bar | ( baz )) ; bar If the cursor is before the first form of a line, then that form ( foo | bar ( baz )) ; bar Current Top-level Form Default shortcut for evaluating the current top level form: alt+enter . The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find def and defn (and defwhatever ) forms at the top level, which also is one major intended use for evaluating top level form: to define and redefine variables . However, Calva does not check the contents of the form in order to determine it as a top-level forms: all forms not enclosed in any other form are top level forms . An \u201dexception\u201d is introduced by the comment form. It will create a new top level context, so that any forms immediately inside a (commment ...) form will be considered top-level by Calva. This is to support a workflow with what is often referred to the Rich Comments . At the top level the selection of which form is the current top level form follows the same rules as those for the current form . Evaluate to Cursor There is also a command for evaluating the text from the start of the current list to where the cursor is. Convenient for checking intermediate results in thread or doto , or similar pipelines. The cursor is right behind :d in this form: ( ->> [ 1 1 2 3 5 8 13 21 ] ( partition 2 ) ( zipmap [ :a :b :c :d ]) :d| ; => (12 21) ( apply - ) ( Math/abs )) The default shortcut for this command is ctrl+alt+enter . Evaluate Top Level Form to Cursor This command has a default shortcut keybinding of shift+alt+enter . It will create a form from the start of the current top level form, up to the cursor, then fold the form, closing all brackets, and this will then be evaluated. Good for examining code blocks up to a certain point. Take this example and paste it in a file loaded into the REPL, then place the cursor in front of each line comment and try the command. ( comment ( do ( def colt-express { :name \"Colt Express\" :categories [ \"Family\" \"Strategy\" ] :play-time 40 :ratings { :pez 5.0 :kat 5.0 :wiw 5.0 ; 1, then eval `colt-express` :vig 3.0 :rex 5.0 :lun 4.0 }}) ( defn average [ coll ] ( / ( apply + coll ) ( count coll ))) ( let [ foo-express ( -> colt-express ( assoc :name \"Foo Express\" ) ( assoc-in [ :ratings :lyr ] 5.0 ) ( update-in [ :ratings :vig ] inc ))] ( ->> foo-express ; 2 :ratings ; 3 vals ; 4 average ; 5 )))) Evaluate Enclosing Form The default keyboard shortcut for evaluating the current enclosing form (the list the cursor is in) is ctrl+shift+enter . ( let [ foo :bar ] ( when false ( str| foo ))) ; => \":bar\" Copying the inline results There is a command called Copy last evaluation results , ctrl+alt+c ctrl+c . This works regardless if you have evaluated in a file editor or in a REPL window. Evaluating in a REPL window Since the REPL Window is mostly just a regular file, things work pretty similar at the REPL prompt. You use alt+enter to evaluate. Selecting the current form (default key binding ctrl+w on Mac and shift+alt+right on Windows and Linux) after evaluating will select the result.","title":"Code Evaluation"},{"location":"evaluation/#code-evaluation","text":"Calva tries to make it easy to evaluate code, supporting interactive development. The fastest path to learning about it is to use the Fire up the Getting Started REPL command, which you can learn more about in the Getting Started section. NB: The below assumes you have read about Finding Calva Commands and Shortcuts .","title":"Code Evaluation"},{"location":"evaluation/#evaluation-in-a-file-editor","text":"Calva has many commands for evaluating forms, including the current form and the current top-level form . Some of the commands also let you choose what should happen with the results: Inline. This will display the results (or some of it, if it is long) inline in the editor. This also creates a hover pane including the full results and a button which will copy the results to the clipboard. There is also a command for copying the last result to the clipboard. The full results are always available in the output window . There is a command for showing the output window, allowing for a workflow where you either generally have it closed, or have it as one of the tabs in the same editor group as the files you are working with. To comments. This will add the results as line comments below the current line. Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results.","title":"Evaluation in a File Editor"},{"location":"evaluation/#wait-current-form-top-level-form","text":"These are important concepts in Calva in order for you to create your most effective workflow.","title":"Wait, Current Form? Top-level Form?"},{"location":"evaluation/#current-form","text":"Default shortcut for evaluating the current form: ctrl+enter . The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form , ctrl+alt+c s , to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides). Generally the current form is determined like so: If text is selected, then that text If the cursor is \u201din\u201d a symbol, then that symbol foob|ar ; foobar If the cursor is adjacent to a form (a symbol or a list of some kind), then that form ( foo bar | ( baz )) ; (baz) If the cursor is between to forms, then the left side form ( foo bar | ( baz )) ; bar If the cursor is before the first form of a line, then that form ( foo | bar ( baz )) ; bar","title":"Current Form"},{"location":"evaluation/#current-top-level-form","text":"Default shortcut for evaluating the current top level form: alt+enter . The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find def and defn (and defwhatever ) forms at the top level, which also is one major intended use for evaluating top level form: to define and redefine variables . However, Calva does not check the contents of the form in order to determine it as a top-level forms: all forms not enclosed in any other form are top level forms . An \u201dexception\u201d is introduced by the comment form. It will create a new top level context, so that any forms immediately inside a (commment ...) form will be considered top-level by Calva. This is to support a workflow with what is often referred to the Rich Comments . At the top level the selection of which form is the current top level form follows the same rules as those for the current form .","title":"Current Top-level Form"},{"location":"evaluation/#evaluate-to-cursor","text":"There is also a command for evaluating the text from the start of the current list to where the cursor is. Convenient for checking intermediate results in thread or doto , or similar pipelines. The cursor is right behind :d in this form: ( ->> [ 1 1 2 3 5 8 13 21 ] ( partition 2 ) ( zipmap [ :a :b :c :d ]) :d| ; => (12 21) ( apply - ) ( Math/abs )) The default shortcut for this command is ctrl+alt+enter .","title":"Evaluate to Cursor"},{"location":"evaluation/#evaluate-top-level-form-to-cursor","text":"This command has a default shortcut keybinding of shift+alt+enter . It will create a form from the start of the current top level form, up to the cursor, then fold the form, closing all brackets, and this will then be evaluated. Good for examining code blocks up to a certain point. Take this example and paste it in a file loaded into the REPL, then place the cursor in front of each line comment and try the command. ( comment ( do ( def colt-express { :name \"Colt Express\" :categories [ \"Family\" \"Strategy\" ] :play-time 40 :ratings { :pez 5.0 :kat 5.0 :wiw 5.0 ; 1, then eval `colt-express` :vig 3.0 :rex 5.0 :lun 4.0 }}) ( defn average [ coll ] ( / ( apply + coll ) ( count coll ))) ( let [ foo-express ( -> colt-express ( assoc :name \"Foo Express\" ) ( assoc-in [ :ratings :lyr ] 5.0 ) ( update-in [ :ratings :vig ] inc ))] ( ->> foo-express ; 2 :ratings ; 3 vals ; 4 average ; 5 ))))","title":"Evaluate Top Level Form to Cursor"},{"location":"evaluation/#evaluate-enclosing-form","text":"The default keyboard shortcut for evaluating the current enclosing form (the list the cursor is in) is ctrl+shift+enter . ( let [ foo :bar ] ( when false ( str| foo ))) ; => \":bar\"","title":"Evaluate Enclosing Form"},{"location":"evaluation/#copying-the-inline-results","text":"There is a command called Copy last evaluation results , ctrl+alt+c ctrl+c . This works regardless if you have evaluated in a file editor or in a REPL window.","title":"Copying the inline results"},{"location":"evaluation/#evaluating-in-a-repl-window","text":"Since the REPL Window is mostly just a regular file, things work pretty similar at the REPL prompt. You use alt+enter to evaluate. Selecting the current form (default key binding ctrl+w on Mac and shift+alt+right on Windows and Linux) after evaluating will select the result.","title":"Evaluating in a REPL window"},{"location":"finding-commands/","text":"Finding Calva Commands Calva relies a lot on that VS Code makes it really easy to find commands by opening the command palette: ctrl+shift+p (Windows/Linux), cmd+shift+p (Mac), and then start typing some words (or part of words) that you think might be in the command. To leverage this, all Calva commands are prefixed with Calva . As an example, say you want to evaluate a form and pretty print it. Then you can do this: Open the command palette Type calevpr VS Code will match cal to \u201d Cal va\u201d, ev to \u201d Ev aluate\u201d, and pr to \u201d pr etty\u201d in \u201d pr etty print\u201d. It looks like so: As you can see on the screenshot, VS Code will also reveal the keyboard shortcut for the command. My advice is to make it a habit to try to remember those shortcuts and use them for a more effective workflow. Now might be a good time to see Calva Top 10 Commands All the Settings and Commands Did you know? There is a complete list of Calva settings and commands in the Contributions tab of the Calva entry in the Extensions pane in VS Code. Toggling Keyboard Shortcuts On/Off The command calva.toggleKeybindingsEnabled can be used to quickly enable and disable (almost) all keyboard shortcuts. This allows you to quickly toggle between Calva keybindings and other keybindings which would otherwise not be available when Calva is enabled. This is particularly useful with the Paredit keyboard shortcuts, whose default shortcuts conflict with the default VS Code shortcuts for textual (non-structural) editing. By default it is not bound to a shortcut so as not to cause confusion by users unwittingly pressing it, but if this is something you'd like to use often, you may want to bind it to a shortcut.","title":"Finding Calva Commands"},{"location":"finding-commands/#finding-calva-commands","text":"Calva relies a lot on that VS Code makes it really easy to find commands by opening the command palette: ctrl+shift+p (Windows/Linux), cmd+shift+p (Mac), and then start typing some words (or part of words) that you think might be in the command. To leverage this, all Calva commands are prefixed with Calva . As an example, say you want to evaluate a form and pretty print it. Then you can do this: Open the command palette Type calevpr VS Code will match cal to \u201d Cal va\u201d, ev to \u201d Ev aluate\u201d, and pr to \u201d pr etty\u201d in \u201d pr etty print\u201d. It looks like so: As you can see on the screenshot, VS Code will also reveal the keyboard shortcut for the command. My advice is to make it a habit to try to remember those shortcuts and use them for a more effective workflow. Now might be a good time to see Calva Top 10 Commands","title":"Finding Calva Commands"},{"location":"finding-commands/#all-the-settings-and-commands","text":"Did you know? There is a complete list of Calva settings and commands in the Contributions tab of the Calva entry in the Extensions pane in VS Code.","title":"All the Settings and Commands"},{"location":"finding-commands/#toggling-keyboard-shortcuts-onoff","text":"The command calva.toggleKeybindingsEnabled can be used to quickly enable and disable (almost) all keyboard shortcuts. This allows you to quickly toggle between Calva keybindings and other keybindings which would otherwise not be available when Calva is enabled. This is particularly useful with the Paredit keyboard shortcuts, whose default shortcuts conflict with the default VS Code shortcuts for textual (non-structural) editing. By default it is not bound to a shortcut so as not to cause confusion by users unwittingly pressing it, but if this is something you'd like to use often, you may want to bind it to a shortcut.","title":"Toggling Keyboard Shortcuts On/Off"},{"location":"formatting/","text":"Formatting We have tried to make Calva's formatter so that it just works . It is enabled by default for Clojure files, and unconfigured it mostly follows Bozhidar Batsov's Clojure Style Guide . Calva uses cljfmt for the formatting. Tips Calva's code formatter sets the default keybinding of its Format Current Form command to tab . Meaning that most often when things look a bit untidy, you can press tab to make things look pretty. Good to know, right? For performance reasons it only formats the current enclosing form, so sometimes you want to move the cursor up/out a form ( ctrl+up ) first. See The Paredit Guide for more on moving the cursor structurally through your code. With the default settings, Calva's formatting behaves like so: formats as you type (when entering new lines) formats the current enclosing form when you hit tab formats pasted code formats according to community standards (see above link) formats the current form, aligning map keys and values , when you press ctrl+alt+l formats (comment ..) forms special, see rich comments Tips Calva has a command that will \u201dheal\u201d the bracket structure if it is correctly indented. Yes, it is Parinfer behind the scenes. This command is default bound to shift+tab to form a nicely balanced pair with the tab formatting. Also: If you have Format on Save enabled in VS Code, it will be Calva doing the formatting for Clojure files. Calva's formatting is mostly about indenting, but it also (again, defaults): trims whitespace at the end of the line trims whitespace inside brackets this also folds trailing brackets (a k a the paren trail ) up on the same line inserts whitespace between forms Not a fan of some default setting? The formatter is quite configurable. Configuration You configure Calva's formatting using cljfmt's configuration EDN . This means that you can adjust the above mentioned defaults, including the indenting. Note The cljfmt docs mention the :cljfmt config key of Leiningen projects. Calva does not yet read the config from there, so if your Leiningen project has such a configuration, you will need to copy it out into a file. To start changing the Calva formatting defaults, paste the following map into a file and save it. It could be somewhere in the project workspace, or some other place, depending on your requirements: { :remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? true :align-associative? false } Then set calva.fmt.configPath to the path to the file. The path should either be absolute, or relative to the project root directory. So, if you named the file .cljfmt.edn and saved it in the root of the project, then this setting should be .cljfmt.edn . Since you are editing the file in Calva (you are, right?), you can quickly test how different settings affect the formatting. Try: setting :align-associative to true then save then hit tab , and see what happens. (This particular setting is experimental and known to cause trouble together with namespaced keywords. Consider using ctrl+alt+l instead of tab as your formatting command, instead of enabling this setting.) Note The hot reloading of the config file only works for config files inside the project directory structure. Indentation rules The cljfmt indents are highly configurable. They, and the rest of the configuration options, are masterly detailed here . Calva is an extra good tool for experimenting with these settings. cljfmt doesn't care about keys in the map that it doesn't know about so you can sneak in test code there to quickly see how it will get formatted by certain rules. Try this, for instance: { :remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? false :align-associative? false :indents ^ :replace { # \"^\\w\" [[ :inner 0 ]]} :test-code ( concat [ 2 ] ( map # ( inc ( * % 2 )) ( filter # ( aget sieved % ) ( range 1 hn ))))} Save, then hit tab , and the code should get formatted like so: :test-code ( concat [ 2 ] ( map # ( inc ( * % 2 )) ( filter # ( aget sieved % ) ( range 1 hn )))) That's somewhat similar to Nikita Prokopov's Better Clojure Formatting suggestion. (Please be aware that this setting might not be sufficient to get complete Tonsky Formatting , please share any settings you use to get full compliance.) Rich Comments To encourage use of (comment ...) forms for development, these forms get a special treatment when formatting. See Rich Comments .","title":"Formatting"},{"location":"formatting/#formatting","text":"We have tried to make Calva's formatter so that it just works . It is enabled by default for Clojure files, and unconfigured it mostly follows Bozhidar Batsov's Clojure Style Guide . Calva uses cljfmt for the formatting. Tips Calva's code formatter sets the default keybinding of its Format Current Form command to tab . Meaning that most often when things look a bit untidy, you can press tab to make things look pretty. Good to know, right? For performance reasons it only formats the current enclosing form, so sometimes you want to move the cursor up/out a form ( ctrl+up ) first. See The Paredit Guide for more on moving the cursor structurally through your code. With the default settings, Calva's formatting behaves like so: formats as you type (when entering new lines) formats the current enclosing form when you hit tab formats pasted code formats according to community standards (see above link) formats the current form, aligning map keys and values , when you press ctrl+alt+l formats (comment ..) forms special, see rich comments Tips Calva has a command that will \u201dheal\u201d the bracket structure if it is correctly indented. Yes, it is Parinfer behind the scenes. This command is default bound to shift+tab to form a nicely balanced pair with the tab formatting. Also: If you have Format on Save enabled in VS Code, it will be Calva doing the formatting for Clojure files. Calva's formatting is mostly about indenting, but it also (again, defaults): trims whitespace at the end of the line trims whitespace inside brackets this also folds trailing brackets (a k a the paren trail ) up on the same line inserts whitespace between forms Not a fan of some default setting? The formatter is quite configurable.","title":"Formatting"},{"location":"formatting/#configuration","text":"You configure Calva's formatting using cljfmt's configuration EDN . This means that you can adjust the above mentioned defaults, including the indenting. Note The cljfmt docs mention the :cljfmt config key of Leiningen projects. Calva does not yet read the config from there, so if your Leiningen project has such a configuration, you will need to copy it out into a file. To start changing the Calva formatting defaults, paste the following map into a file and save it. It could be somewhere in the project workspace, or some other place, depending on your requirements: { :remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? true :align-associative? false } Then set calva.fmt.configPath to the path to the file. The path should either be absolute, or relative to the project root directory. So, if you named the file .cljfmt.edn and saved it in the root of the project, then this setting should be .cljfmt.edn . Since you are editing the file in Calva (you are, right?), you can quickly test how different settings affect the formatting. Try: setting :align-associative to true then save then hit tab , and see what happens. (This particular setting is experimental and known to cause trouble together with namespaced keywords. Consider using ctrl+alt+l instead of tab as your formatting command, instead of enabling this setting.) Note The hot reloading of the config file only works for config files inside the project directory structure.","title":"Configuration"},{"location":"formatting/#indentation-rules","text":"The cljfmt indents are highly configurable. They, and the rest of the configuration options, are masterly detailed here . Calva is an extra good tool for experimenting with these settings. cljfmt doesn't care about keys in the map that it doesn't know about so you can sneak in test code there to quickly see how it will get formatted by certain rules. Try this, for instance: { :remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? false :align-associative? false :indents ^ :replace { # \"^\\w\" [[ :inner 0 ]]} :test-code ( concat [ 2 ] ( map # ( inc ( * % 2 )) ( filter # ( aget sieved % ) ( range 1 hn ))))} Save, then hit tab , and the code should get formatted like so: :test-code ( concat [ 2 ] ( map # ( inc ( * % 2 )) ( filter # ( aget sieved % ) ( range 1 hn )))) That's somewhat similar to Nikita Prokopov's Better Clojure Formatting suggestion. (Please be aware that this setting might not be sufficient to get complete Tonsky Formatting , please share any settings you use to get full compliance.)","title":"Indentation rules"},{"location":"formatting/#rich-comments","text":"To encourage use of (comment ...) forms for development, these forms get a special treatment when formatting. See Rich Comments .","title":"Rich Comments"},{"location":"get-started-with-clojure/","text":"Get Started with Clojure Welcome to a zero-install, interactive, guide to get you started with Clojure using: Clojure Gitpod (A development environment delivered via the web browser) VS Code (Or Gitpod Code, actually. In your web browser.) Calva (A Clojure extension to VS Code. The thing this site is about.) Calva's Getting Started REPL I have VS Code and Java Clojure runs on the JVM. How to install it is a big topic. Since you have already done that, you can, if you want, choose to install Calva in your local VS Code and fire up the Getting Started REPL . By all means read this page anyway, you can just skip the Gitpod parts. Also: If you are using Windows your Java might have a bug that prevents things from working . Then you might want to defer fixing that and use the zero-install option first. Is Gitpod Code exactly as VS Code? Almost! But, yeah, there are some difference between regular VS Code and Gitpod's ditto. Most of it doesn't matter, but finding the main menu can be a bit tricky: What you'll learn The basics of the Clojure language (at least the start of the basics) The basics of the ClojureScipt language (we won't be using ClojureScript, but it is same language \ud83d\ude00) The basics of Calva (It's a bit as a side effect. You need it to learn Clojure this way, and by learning Clojure this way, Calva knowledge trickles in.) What is meant by, and some ways to perform, Interactive Programming (aka REPL Driven Development) Where to find Clojurians, i.e. folks who use Clojure and care about it (you will thus find help, the friendliest help you have ever seen a community provide) I am not convinced I should spend time on learning Clojure Fair enough. We can recommend watching any or all of these videos to get excited about Clojure and the rather unique mood of development it offers: Solving Problems the Clojure Way - with Rafal Dittwald (using JavaScript, so no new syntax to grasp to get the message) Developer Ergonomics with VS Code, Clojure, and ClojureScript - with Peter Str\u00f6mberg Clojure in VS Code Workflow using FizzBuzz - with Peter Str\u00f6mberg What you won't learn How to install Clojure for your operating system of choice About various old and new build and dependency tools How to create projects and do real stuff Why won't I learn about this? All in due time. \ud83d\ude04 It can be a bit confusing with all the things you find out about installing Clojure and creating projects when searching for information about it. We want you to relax about all that and just enjoy learning a bit about this fantastic programming language and the wonderful mode of development it offers. There is a lot of info about this out there already. And since you will learn where to find Clojurians, you will also find guidance. But we suggest do these things later. First, let's focus on having fun with Interactive Programming! What you need Curiosity about Clojure A web browser The browser ate my keyboard shortcuts! There is always a competition for which system gets to catch keyboard shortcuts first. This worsens a bit when an application like VS Code runs in the web browser. Remember this if some shortcut/command doesn't work. On some machines, with some web browsers, some shortcuts are caught by the web browser and instead re-opening a closed tab or whatever. These have been observed: Undo (undoing something web browser related) Select the line (focusing the browser URL input) Open the command palette (opening a private browsing window. Looking at you Firefox.) Escape key shortcuts (are you using VIM bindings in your browser?) Sometimes the workaround is to redefine the shortcuts in VS Code, sometimes making your web browser stop catching the shortcut. I am new to VS Code You might want to have a look at this Getting Started with VS Code video . (You can of course ignore the parts about installing for now.) Also, have this overview of the VS Code interface handy. How it works You will open an instance of VS Code in a development environment running in the browser. The envirnoment will have Java, Clojure tools, and Calva installed. Gitpod Sign-in You will be asked to sign in to Gitpod, if you aren't already. You need to use the \u201dSign in with GitHub\u201d option. Instructions will be automatically displayed (very brief such, because it is mainly about firing up the Getting Started REPL ) The guides are a mix of prose (in Clojure line comments), Clojure code, and exercises. What's extra poetic is that you will use Calva and Clojure to learn Calva and Clojure. Use a desktop/laptop computer. Even if it actually works on the phone, it is far from convenient. It sometimes takes a while (several minutes) for the environment to initialize. Take some deep breaths and be patient. \ud83d\ude0e Let's go! Ready? Awesome. Click this button to start the guide in a new browser tab. https://gitpod.io/#https://github.com/PEZ/get-started-with-clojure Stuck? Something not working? Or just unclear? Please don't hesitate to reach out for help, should you get stuck. See below for where to find Clojurians. As for the Calva team, we are almost always (true story) to be found at the Clojurians Slack, especially in the #calva Channel. We are @pez and @bringe there. Happy Interactive Programming! \u2764\ufe0f And where do I find those Clojurians? We Clojurians inhabit a lot of community platforms. I'll list some of the more popular ones here in some order of popularity. The Clojurians Slack - by far the largest and most active Clojure community, the #beginners channel is spectacularly fantastic ClojureVerse - a web forum. Lots of Clojurians, lots of Clojure knowledge collected, easy to search, easy to join /r/Clojure - Reddit when Reddit is at its best, lots of Clojurians here Clojurians on Zulip - An other web forum using the Zulip platform On Discord there are two active servers: Clojurians and Discord You can also ask questions, and find answers, about Clojure at ask.clojure.org Learn and Practice Clojure using Rich 4Clojure If you like the style of interactive learning that this guide provides, you should definitely check Rich 4Clojure out. It also can be used in the zero-installed way. You can regard it as a companion to this guide. It is aimed at practicing Clojure, starting at the elementary levels, bringing you to advanced stuff. Can I use Rich 4Clojure instead of this guide? We suggest you start by opening up this guide and do the Calva part of the excerises. Then use the welcome_to_clojure.clj guide in combination with Rich 4Clojure .. Run the Clojure Exercism Track in your browser In a similar manner to the Get Started with Clojure project, you can run the Clojure Exercism Track in your browser without installing anything and with full Interactive Programming enabled using this Template project . ClojureDocs Clojurians draw tremendous value from ClojureDocs . At ClojureDocs the concise documentation for Clojure core functions, etcetera, are amended with examples and advice from fellow Clojurians. Crowdsourcing at its very best! It is a big part of the reason why you won't find an abundance of Clojure information at StackOverflow. Other learning resources Clojure Beginner Resources - a much more comprehensive list than this one clojure.org Gettting Started - the source of truth, includes installing and stuff The Exercism Clojure track - Learn solving carefully crafted Clojure exercises, get mentor feedback if you like. Clojure for the Brave and True - helping you from beginner to pretty advanced stuff, very popular among Clojurians What do beginners struggle with? - a ClojureVerse thread, where you can tell us about what you have found hard in picking up Clojure. It's what spawned the creation of this guide. on the code again - often features Clojure concepts, with snappy, well communicated, and entertaining videos CalvaTV - Calva's YouTube channel often focuses on beginning with Clojure and ClojureScript. Subscribe, please! Help us help beginners Give us feedback. Spread the word. Please consider: Join the #improve-getting-started channel at the Clojurian Slack Linking to this page from your blog Tweeting about this guide Contributing to the Calva project Wearing Calva and RFC T-shirts Starring these repositories: Get Started with Clojure - (the repository powering this guide) Rich 4Clojure Clojure Exercism Track Template Calva Dram - Where this guide (the Getting Started REPL) is authored Please also consider other ways to contribute . Thanks! \ud83d\ude4f","title":"Get Started with Clojure"},{"location":"get-started-with-clojure/#get-started-with-clojure","text":"Welcome to a zero-install, interactive, guide to get you started with Clojure using: Clojure Gitpod (A development environment delivered via the web browser) VS Code (Or Gitpod Code, actually. In your web browser.) Calva (A Clojure extension to VS Code. The thing this site is about.) Calva's Getting Started REPL I have VS Code and Java Clojure runs on the JVM. How to install it is a big topic. Since you have already done that, you can, if you want, choose to install Calva in your local VS Code and fire up the Getting Started REPL . By all means read this page anyway, you can just skip the Gitpod parts. Also: If you are using Windows your Java might have a bug that prevents things from working . Then you might want to defer fixing that and use the zero-install option first. Is Gitpod Code exactly as VS Code? Almost! But, yeah, there are some difference between regular VS Code and Gitpod's ditto. Most of it doesn't matter, but finding the main menu can be a bit tricky:","title":"Get Started with Clojure"},{"location":"get-started-with-clojure/#what-youll-learn","text":"The basics of the Clojure language (at least the start of the basics) The basics of the ClojureScipt language (we won't be using ClojureScript, but it is same language \ud83d\ude00) The basics of Calva (It's a bit as a side effect. You need it to learn Clojure this way, and by learning Clojure this way, Calva knowledge trickles in.) What is meant by, and some ways to perform, Interactive Programming (aka REPL Driven Development) Where to find Clojurians, i.e. folks who use Clojure and care about it (you will thus find help, the friendliest help you have ever seen a community provide) I am not convinced I should spend time on learning Clojure Fair enough. We can recommend watching any or all of these videos to get excited about Clojure and the rather unique mood of development it offers: Solving Problems the Clojure Way - with Rafal Dittwald (using JavaScript, so no new syntax to grasp to get the message) Developer Ergonomics with VS Code, Clojure, and ClojureScript - with Peter Str\u00f6mberg Clojure in VS Code Workflow using FizzBuzz - with Peter Str\u00f6mberg","title":"What you'll learn"},{"location":"get-started-with-clojure/#what-you-wont-learn","text":"How to install Clojure for your operating system of choice About various old and new build and dependency tools How to create projects and do real stuff Why won't I learn about this? All in due time. \ud83d\ude04 It can be a bit confusing with all the things you find out about installing Clojure and creating projects when searching for information about it. We want you to relax about all that and just enjoy learning a bit about this fantastic programming language and the wonderful mode of development it offers. There is a lot of info about this out there already. And since you will learn where to find Clojurians, you will also find guidance. But we suggest do these things later. First, let's focus on having fun with Interactive Programming!","title":"What you won't learn"},{"location":"get-started-with-clojure/#what-you-need","text":"Curiosity about Clojure A web browser The browser ate my keyboard shortcuts! There is always a competition for which system gets to catch keyboard shortcuts first. This worsens a bit when an application like VS Code runs in the web browser. Remember this if some shortcut/command doesn't work. On some machines, with some web browsers, some shortcuts are caught by the web browser and instead re-opening a closed tab or whatever. These have been observed: Undo (undoing something web browser related) Select the line (focusing the browser URL input) Open the command palette (opening a private browsing window. Looking at you Firefox.) Escape key shortcuts (are you using VIM bindings in your browser?) Sometimes the workaround is to redefine the shortcuts in VS Code, sometimes making your web browser stop catching the shortcut. I am new to VS Code You might want to have a look at this Getting Started with VS Code video . (You can of course ignore the parts about installing for now.) Also, have this overview of the VS Code interface handy.","title":"What you need"},{"location":"get-started-with-clojure/#how-it-works","text":"You will open an instance of VS Code in a development environment running in the browser. The envirnoment will have Java, Clojure tools, and Calva installed. Gitpod Sign-in You will be asked to sign in to Gitpod, if you aren't already. You need to use the \u201dSign in with GitHub\u201d option. Instructions will be automatically displayed (very brief such, because it is mainly about firing up the Getting Started REPL ) The guides are a mix of prose (in Clojure line comments), Clojure code, and exercises. What's extra poetic is that you will use Calva and Clojure to learn Calva and Clojure. Use a desktop/laptop computer. Even if it actually works on the phone, it is far from convenient. It sometimes takes a while (several minutes) for the environment to initialize. Take some deep breaths and be patient. \ud83d\ude0e","title":"How it works"},{"location":"get-started-with-clojure/#lets-go","text":"Ready? Awesome. Click this button to start the guide in a new browser tab. https://gitpod.io/#https://github.com/PEZ/get-started-with-clojure Stuck? Something not working? Or just unclear? Please don't hesitate to reach out for help, should you get stuck. See below for where to find Clojurians. As for the Calva team, we are almost always (true story) to be found at the Clojurians Slack, especially in the #calva Channel. We are @pez and @bringe there. Happy Interactive Programming! \u2764\ufe0f","title":"Let's go!"},{"location":"get-started-with-clojure/#and-where-do-i-find-those-clojurians","text":"We Clojurians inhabit a lot of community platforms. I'll list some of the more popular ones here in some order of popularity. The Clojurians Slack - by far the largest and most active Clojure community, the #beginners channel is spectacularly fantastic ClojureVerse - a web forum. Lots of Clojurians, lots of Clojure knowledge collected, easy to search, easy to join /r/Clojure - Reddit when Reddit is at its best, lots of Clojurians here Clojurians on Zulip - An other web forum using the Zulip platform On Discord there are two active servers: Clojurians and Discord You can also ask questions, and find answers, about Clojure at ask.clojure.org","title":"And where do I find those Clojurians?"},{"location":"get-started-with-clojure/#learn-and-practice-clojure-using-rich-4clojure","text":"If you like the style of interactive learning that this guide provides, you should definitely check Rich 4Clojure out. It also can be used in the zero-installed way. You can regard it as a companion to this guide. It is aimed at practicing Clojure, starting at the elementary levels, bringing you to advanced stuff. Can I use Rich 4Clojure instead of this guide? We suggest you start by opening up this guide and do the Calva part of the excerises. Then use the welcome_to_clojure.clj guide in combination with Rich 4Clojure ..","title":"Learn and Practice Clojure using Rich 4Clojure"},{"location":"get-started-with-clojure/#run-the-clojure-exercism-track-in-your-browser","text":"In a similar manner to the Get Started with Clojure project, you can run the Clojure Exercism Track in your browser without installing anything and with full Interactive Programming enabled using this Template project .","title":"Run the Clojure Exercism Track in your browser"},{"location":"get-started-with-clojure/#clojuredocs","text":"Clojurians draw tremendous value from ClojureDocs . At ClojureDocs the concise documentation for Clojure core functions, etcetera, are amended with examples and advice from fellow Clojurians. Crowdsourcing at its very best! It is a big part of the reason why you won't find an abundance of Clojure information at StackOverflow.","title":"ClojureDocs"},{"location":"get-started-with-clojure/#other-learning-resources","text":"Clojure Beginner Resources - a much more comprehensive list than this one clojure.org Gettting Started - the source of truth, includes installing and stuff The Exercism Clojure track - Learn solving carefully crafted Clojure exercises, get mentor feedback if you like. Clojure for the Brave and True - helping you from beginner to pretty advanced stuff, very popular among Clojurians What do beginners struggle with? - a ClojureVerse thread, where you can tell us about what you have found hard in picking up Clojure. It's what spawned the creation of this guide. on the code again - often features Clojure concepts, with snappy, well communicated, and entertaining videos CalvaTV - Calva's YouTube channel often focuses on beginning with Clojure and ClojureScript. Subscribe, please!","title":"Other learning resources"},{"location":"get-started-with-clojure/#help-us-help-beginners","text":"Give us feedback. Spread the word. Please consider: Join the #improve-getting-started channel at the Clojurian Slack Linking to this page from your blog Tweeting about this guide Contributing to the Calva project Wearing Calva and RFC T-shirts Starring these repositories: Get Started with Clojure - (the repository powering this guide) Rich 4Clojure Clojure Exercism Track Template Calva Dram - Where this guide (the Getting Started REPL) is authored Please also consider other ways to contribute . Thanks! \ud83d\ude4f","title":"Help us help beginners"},{"location":"getting-started/","text":"Getting Started Depending on wether you want to just start a Clojure REPL or you have a project you want to work with, getting started looks similar but a bit different. Regardless, you need to install Calva in VS Code. I am completely new to Clojure The \u201dGetting Started\u201d REPL below introduces you to Clojure as well as to Calva. You might however, not want to start with installing the right version of Java and such to run the guide. If so you should definitely check the Get Started with Clojure guide on this site. Three clicks will have you running Calva in your browser with the REPL ready to serve. I don't have Java installed If you like, you can defer installing anything at all and still get started with Calva (not kidding). See Get Started with Clojure . If you have a Clojure or ClojureScript project, you will be interested in how to get Calva connected to the REPL of your project . But before you run over there, you might want to familiarize yourself with Calva a bit, which you can do without a project. The demo tells you about the command (and some about the Clojure Beginner's material that it makes available). There's a \u201dGetting Started\u201d REPL If you are new to Calva, a good place to start is using the command Fire up the \u201dGetting Started\u201d REPL . Demo: It will open up a three files in a temporary directory, and start and connect a REPL. The files are: hello_repl.clj \u2013 The basics of how to evaluate code in Calva hello_paredit.clj - A super brief intro to Calva structural editing welcome_to_clojure.clj - The very basics of the Clojure language The only prerequisite here is that you have Java installed. No pre-installed clojure tools required. (You will want to install these tools later, of course.) Note On Windows the Oracle Java installer sets Java up in some funny way so that the Getting Started REPL fails to start. We are figuring about workarounds for this, but for now, if you are on Windows, you will need to make VS Code have some other Java in the PATH of its environment for this feature to work. See this issue on the Calva repo for more on this, including any progress. There are standalone \u201dClojureScript Quick Start\u201d REPLs Without creating a project structure or installing anything but Calva, you can start standalone ClojureScirpt REPLs both in a browser and for node: Fire up the ClojureScript Quick Start Browser REPL Opens the files core.cljs and index.html and starts the ClojureScript app, opening it in the browser. Fire up the ClojureScript Quick Start Node REPL Opens a file, core.cljs , and starts a nodejs REPL where it loads the file. The browser REPL app looks like so: You have a Project? If you are new to Calva, please consider the above option first. Then when it it will be time to get Calva connected to the REPL of your project . Clojure Resources If you are new to Clojure or ClojureScript altogether, please check out the guide material on the respective official sites: Getting Started with Clojure ClojureScript Quick Start There are also many great books on Clojure. Clojure for the Brave and True can be read for free online. It is a great resource for beginners. There is also Standalone REPL When you are more familiar with Calva, and want a standalone REPL, there is a separate command: Start a standalone REPL (not in project) . It will open up a user.clj in a temporary directory, containing only an (ns user) form, and start and connect the REPL. Dram - Where the Guides Live The command for starting the Getting Started REPL will download the files from this repository . It is very much work in progress, and there is not even a finished Clojure Beginner's Guide there yet. WHen you run the command again, and from then on, you will get the option to download new files or keep using your existing. Downloading new ones will not overwrite your existing ones, because they will be downloaded to a new temp directory. You can find the directory easily using VS Codes context menu command for revealing a file in the Explorer/Finder. One Last Thing Happy coding! \u2665\ufe0f","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Depending on wether you want to just start a Clojure REPL or you have a project you want to work with, getting started looks similar but a bit different. Regardless, you need to install Calva in VS Code. I am completely new to Clojure The \u201dGetting Started\u201d REPL below introduces you to Clojure as well as to Calva. You might however, not want to start with installing the right version of Java and such to run the guide. If so you should definitely check the Get Started with Clojure guide on this site. Three clicks will have you running Calva in your browser with the REPL ready to serve. I don't have Java installed If you like, you can defer installing anything at all and still get started with Calva (not kidding). See Get Started with Clojure . If you have a Clojure or ClojureScript project, you will be interested in how to get Calva connected to the REPL of your project . But before you run over there, you might want to familiarize yourself with Calva a bit, which you can do without a project. The demo tells you about the command (and some about the Clojure Beginner's material that it makes available).","title":"Getting Started"},{"location":"getting-started/#theres-a-getting-started-repl","text":"If you are new to Calva, a good place to start is using the command Fire up the \u201dGetting Started\u201d REPL . Demo: It will open up a three files in a temporary directory, and start and connect a REPL. The files are: hello_repl.clj \u2013 The basics of how to evaluate code in Calva hello_paredit.clj - A super brief intro to Calva structural editing welcome_to_clojure.clj - The very basics of the Clojure language The only prerequisite here is that you have Java installed. No pre-installed clojure tools required. (You will want to install these tools later, of course.) Note On Windows the Oracle Java installer sets Java up in some funny way so that the Getting Started REPL fails to start. We are figuring about workarounds for this, but for now, if you are on Windows, you will need to make VS Code have some other Java in the PATH of its environment for this feature to work. See this issue on the Calva repo for more on this, including any progress.","title":"There's a \u201dGetting Started\u201d REPL"},{"location":"getting-started/#there-are-standalone-clojurescript-quick-start-repls","text":"Without creating a project structure or installing anything but Calva, you can start standalone ClojureScirpt REPLs both in a browser and for node: Fire up the ClojureScript Quick Start Browser REPL Opens the files core.cljs and index.html and starts the ClojureScript app, opening it in the browser. Fire up the ClojureScript Quick Start Node REPL Opens a file, core.cljs , and starts a nodejs REPL where it loads the file. The browser REPL app looks like so:","title":"There are standalone \u201dClojureScript Quick Start\u201d REPLs"},{"location":"getting-started/#you-have-a-project","text":"If you are new to Calva, please consider the above option first. Then when it it will be time to get Calva connected to the REPL of your project .","title":"You have a Project?"},{"location":"getting-started/#clojure-resources","text":"If you are new to Clojure or ClojureScript altogether, please check out the guide material on the respective official sites: Getting Started with Clojure ClojureScript Quick Start There are also many great books on Clojure. Clojure for the Brave and True can be read for free online. It is a great resource for beginners.","title":"Clojure Resources"},{"location":"getting-started/#there-is-also-standalone-repl","text":"When you are more familiar with Calva, and want a standalone REPL, there is a separate command: Start a standalone REPL (not in project) . It will open up a user.clj in a temporary directory, containing only an (ns user) form, and start and connect the REPL.","title":"There is also Standalone REPL"},{"location":"getting-started/#dram-where-the-guides-live","text":"The command for starting the Getting Started REPL will download the files from this repository . It is very much work in progress, and there is not even a finished Clojure Beginner's Guide there yet. WHen you run the command again, and from then on, you will get the option to download new files or keep using your existing. Downloading new ones will not overwrite your existing ones, because they will be downloaded to a new temp directory. You can find the directory easily using VS Codes context menu command for revealing a file in the Explorer/Finder.","title":"Dram - Where the Guides Live"},{"location":"getting-started/#one-last-thing","text":"Happy coding! \u2665\ufe0f","title":"One Last Thing"},{"location":"jack-in-guide/","text":"Learn about Calva Jack-in The Calva Jack-In Academy, by @pez Like with CIDER Jack-in , Calva's let-me-help-you-start-your-project-and-connect feature might seem a bit mysterious. It really is helpful, but also really isn't mysterious. Here are a few things about it that is good to know about. Note If you came here to find out how to configure the versions of the dependencies that Calva Jack-in injects, see Customizing Calva - Jack-in Dependency Versions . What it Solves At first it might seem that something like lein repl in a terminal and then connecting Calva is enough. It sometimes might be, but only if you are in luck. To provide many of its IDE features, Calva relies on nREPL middleware, mainly cider-nrepl and, for ClojureScript, piggieback . When starting your Clojure(Script) app and its REPL, it needs to be started with these dependencies satisfied. There are mainly three ways this can be achieved. In the project definition (files like project.clj , deps.edn , shadow-cljs.edn , and combination of these). In your user profile (files like ~/.lein/profiles.clj and ~/.clojure/deps.edn ). On the command line. Because 1 and 2 are hard to keep in sync with the various editor environments people in your project might be using, Calva Jack-In is about 3 . Ideally, you will be able to rid your project files completely of editor dependencies when people working on the project can rely on the Jack-In features of their Clojure editor. A Controlled Shell Command At its core Calva Jack-In is just a glorified, REPL-starting, command-line. No, it is more than that, but anyway. The command line can look like so for a Leiningen project using legacy Figwheel for its ClojureScript assistance: lein update-in :dependencies conj '[nrepl\"0.6.0\"]' -- update-in :dependencies conj '[cider/piggieback\"0.4.1\"]' -- update-in :dependencies conj '[figwheel-sidecar\"0.5.18\"]' -- update-in :plugins conj '[cider/cider-nrepl\"0.22.4\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.piggieback/wrap-cljs-repl\"]' -- with-profile +dev repl :headless Even if a bit long, it might look simple enough. But actually it has taken quite some effort to make Calva craft it. Shell quoting can be really tricky. Look at how '[nrepl\"0.6.0\"]' doesn't have a space between nrepl and the version. That was the only way I could find that was cross platform enough to make all supported shells parse the command line. (The trick relies on that the string is read by the super reliable Clojure Reader, which does not need that space to tokenize it.) It is awesome that Clojure is used on so many platforms, but for a tool smith this also means more work. (I think Windows and its shell hell ate up about 95% of the many hours spent on getting the quoting good enough.) The command-line crafted is then used to start a shell command that Calva controls, but we are getting ahead of ourselves... Project Types, Builds, Aliases, Profiles, etcetera In order to cook the right command for your project, Calva looks for project files, reads them, and figures out what possible project types and ClojureScript tools could be involved. Then Calva presents you with a menu with the options it has found. You need to know enough about your project to answer this question. It looks like this in a shadow-cljs project that uses a deps.edn file for setting up its classpath. (I know enough about this particular project to know that I should choose the shadow-cljs project type.) But Calva isn't ready to cook the command-line just yet. Depending on the project type, and contents of your project files, more info is needed. E.g. in the case of shadow-cljs projects, Calva needs to know what builds to start. Here you can select any combination of builds defined in the project, and Calva will cook a command line that starts them. You might get more prompts from Calva before it issues the command, but for this example project, Calva goes ahead, cooks the command line, and issues it. On my Mac, it looks like so: npx shadow-cljs -d cider/piggieback:0.4.1 -d cider/cider-nrepl:0.22.4 watch :app (Much shorter than the one with lein-figwheel, right? It is because shadow-cljs is aware of CIDER dependencies, so it doesn't need as many dependencies specified as some other project types do.) Connecting When the command is issued Calva needs to wait until the REPL Server is started, before connecting to it and possibly continuing with starting a ClojureScript REPL and connecting to that as well. It also needs to know which port to connect to. Because reasons, Calva can't yet read the stdout of the shell command it has issued, so to know when the REPL server is started, and on which port, Calva monitors the filesystem for the .nrepl-port file. (This file is not always named like that. shadow-cljs, for instance, creates the file .shadow-cljs/nrepl.port .) When the port file is created, Calva picks up the port number from it and connects to the nREPL server. At this point you have a Clojure REPL backing your Calva session, providing all sorts of nice IDE help for you. Starting Your Clojure App Once you have the Clojure REPL connected you can start your Clojure app/server. See Custom Connect Sequences for how to let Calva do this for you automatically. See the same article for ways to automate more of the Jack-In process. It can be brought down to a single Jack-In command/action, even for a full stack Clojure and ClojureScript application. ClojureScript For ClojureScript, things are not done yet, though, far from it. It turns out that cooking the command line was the easy part. In order for Calva to provide REPL power for ClojureScript projects, several things need to happen: A Clojure nREPL connection needs to be established. We've covered that above. Calva makes an nREPL session clone to use for the ClojureScript REPL and then: Your ClojureScript app needs to be compiled. Your ClojureScript app needs to be started. The Clojure nREPL session needs to be promoted to a ClojureScript nREPL session. (This is what piggieback helps with.) Compiling the App and Watchers Depending on ClojureScript project type, Calva uses different methods to start the compilation and the watcher: Figwheel: The compilation and the watchers are started in the Clojure REPL session. (This is both for Figwheel Main and for lein-figwheel.) shadow-cljs: The compilation and the watchers are started with the Jack-In command line. This results in a bit of difference in the user interaction. Mainly that for shadow-cljs, the user needs to check the Jack-In Terminal tab to follow what's going on. Starting the App Number 3 above, the app needs to be started , might seem obvious, but it actually trips many people up. Because of this, Calva goes to quite some lengths to provide assistance. Many projects are configured not to spawn a browser session automatically, requesting the app once it has been compiled, so we can't rely on that. What Calva does instead is to monitor the output of the commands it uses for starting the compilation, looking for information that the app is ready to be requested/started. It then tells the user this, providing a URL, in case it is a browser app. (There are also settings that tell Calva to open the URL automatically for you, regardless what the project settings are.) Connecting Meanwhile, Calva is monitoring the output and when it sees that the app is started, it continues to hook up the REPL connection to the editor. This whole connection sequence is quite configurable, using Custom Connect Sequences . In fact, Calva's built in ClojureScript sequences (Figwheel Main, lein-figwheel, shadow-cljs, and ClojureScript built-ins for both Browser and Node) are all built using those same settings mechanisms. shadow-cljs is Less Managed by Calva NB: The managed way in which Calva creates and connects the ClojureScript REPL breaks apart a bit for shadow-cljs, which works a bit differently and also outputs most of the information Calva is looking for on the stdout of the REPL start command (where Calva can't see it, remember?). We'll figure out a better way to support shadow-cljs, but for now, the user needs to do more of this figuring out than is needed with Figwheel projects. Hack Away So, there are things going on when you start Jack-In, and even more things for ClojureScript projects, but Calva tries to keep it together, so as a user it is a matter of paying attention and responding to a few prompts/menus with pre-populated options (prompts which can be configured away, even). Switch ClojureScript Builds Once the REPL is connected you might want to change which ClojureScript build you have Calva connected to. For this Calva has the Select CLJS Build Connection command. Please note that you can only switch between builds that you have started. Play With Starting the cljs-repl Yourself To get a good grip on what is going on when creating and connecting the ClojureScript REPL, I can recommend making a custom connect sequence which leaves the REPL unpromoted (e.g. give it nil as connectCode ), and then evaluate the cljs-repl start commands yourself. So for instance, promoting it to a ClojureScript Node.js REPL looks something like so: user=> ( require 'cljs.repl.node ) user=> ( cider.piggieback/cljs-repl ( cljs.repl.node/repl-env )) ClojureScript 1.10 .844 To quit , type : :cljs/quit nil cljs.user=> | It is the piggieback middleware there telling you that you can unpromote the REPL by \u201devaluating\u201d :cljs/quit . About Full Stack Applications Because Calva uses the Clojure REPL connection to spawn the ClojureScript REPL, and because Calva only handles one Clojure REPL per VS Code window, some projects need special handling by the user. If your full stack project is using shadow-cljs for the frontend, like this Fulcro template project does, maybe you first try to Jack-In to your backend Clojure REPL, and then to your shadow-cljs frontend. This works if you do it in separate VS Code windows, but if you do it in the same window, the second Jack-In will kill the backend session! See Workspace Layouts for tips about how to open the same project folder in two separate VS Code windows. Please Grab your Calva Jack-In Certificate There, you now know all there is to know about Calva Jack-In. Just kidding, there are a few more details to it, some of which might find their way into this article at a later time. To really get to know it all, you will need to spend some time with the Calva Jack-In code. Head over to the Calva Development Wiki to learn how to hack on Calva.","title":"Learn about Calva Jack-in"},{"location":"jack-in-guide/#learn-about-calva-jack-in","text":"The Calva Jack-In Academy, by @pez Like with CIDER Jack-in , Calva's let-me-help-you-start-your-project-and-connect feature might seem a bit mysterious. It really is helpful, but also really isn't mysterious. Here are a few things about it that is good to know about. Note If you came here to find out how to configure the versions of the dependencies that Calva Jack-in injects, see Customizing Calva - Jack-in Dependency Versions .","title":"Learn about Calva Jack-in"},{"location":"jack-in-guide/#what-it-solves","text":"At first it might seem that something like lein repl in a terminal and then connecting Calva is enough. It sometimes might be, but only if you are in luck. To provide many of its IDE features, Calva relies on nREPL middleware, mainly cider-nrepl and, for ClojureScript, piggieback . When starting your Clojure(Script) app and its REPL, it needs to be started with these dependencies satisfied. There are mainly three ways this can be achieved. In the project definition (files like project.clj , deps.edn , shadow-cljs.edn , and combination of these). In your user profile (files like ~/.lein/profiles.clj and ~/.clojure/deps.edn ). On the command line. Because 1 and 2 are hard to keep in sync with the various editor environments people in your project might be using, Calva Jack-In is about 3 . Ideally, you will be able to rid your project files completely of editor dependencies when people working on the project can rely on the Jack-In features of their Clojure editor.","title":"What it Solves"},{"location":"jack-in-guide/#a-controlled-shell-command","text":"At its core Calva Jack-In is just a glorified, REPL-starting, command-line. No, it is more than that, but anyway. The command line can look like so for a Leiningen project using legacy Figwheel for its ClojureScript assistance: lein update-in :dependencies conj '[nrepl\"0.6.0\"]' -- update-in :dependencies conj '[cider/piggieback\"0.4.1\"]' -- update-in :dependencies conj '[figwheel-sidecar\"0.5.18\"]' -- update-in :plugins conj '[cider/cider-nrepl\"0.22.4\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.piggieback/wrap-cljs-repl\"]' -- with-profile +dev repl :headless Even if a bit long, it might look simple enough. But actually it has taken quite some effort to make Calva craft it. Shell quoting can be really tricky. Look at how '[nrepl\"0.6.0\"]' doesn't have a space between nrepl and the version. That was the only way I could find that was cross platform enough to make all supported shells parse the command line. (The trick relies on that the string is read by the super reliable Clojure Reader, which does not need that space to tokenize it.) It is awesome that Clojure is used on so many platforms, but for a tool smith this also means more work. (I think Windows and its shell hell ate up about 95% of the many hours spent on getting the quoting good enough.) The command-line crafted is then used to start a shell command that Calva controls, but we are getting ahead of ourselves...","title":"A Controlled Shell Command"},{"location":"jack-in-guide/#project-types-builds-aliases-profiles-etcetera","text":"In order to cook the right command for your project, Calva looks for project files, reads them, and figures out what possible project types and ClojureScript tools could be involved. Then Calva presents you with a menu with the options it has found. You need to know enough about your project to answer this question. It looks like this in a shadow-cljs project that uses a deps.edn file for setting up its classpath. (I know enough about this particular project to know that I should choose the shadow-cljs project type.) But Calva isn't ready to cook the command-line just yet. Depending on the project type, and contents of your project files, more info is needed. E.g. in the case of shadow-cljs projects, Calva needs to know what builds to start. Here you can select any combination of builds defined in the project, and Calva will cook a command line that starts them. You might get more prompts from Calva before it issues the command, but for this example project, Calva goes ahead, cooks the command line, and issues it. On my Mac, it looks like so: npx shadow-cljs -d cider/piggieback:0.4.1 -d cider/cider-nrepl:0.22.4 watch :app (Much shorter than the one with lein-figwheel, right? It is because shadow-cljs is aware of CIDER dependencies, so it doesn't need as many dependencies specified as some other project types do.)","title":"Project Types, Builds, Aliases, Profiles, etcetera"},{"location":"jack-in-guide/#connecting","text":"When the command is issued Calva needs to wait until the REPL Server is started, before connecting to it and possibly continuing with starting a ClojureScript REPL and connecting to that as well. It also needs to know which port to connect to. Because reasons, Calva can't yet read the stdout of the shell command it has issued, so to know when the REPL server is started, and on which port, Calva monitors the filesystem for the .nrepl-port file. (This file is not always named like that. shadow-cljs, for instance, creates the file .shadow-cljs/nrepl.port .) When the port file is created, Calva picks up the port number from it and connects to the nREPL server. At this point you have a Clojure REPL backing your Calva session, providing all sorts of nice IDE help for you.","title":"Connecting"},{"location":"jack-in-guide/#starting-your-clojure-app","text":"Once you have the Clojure REPL connected you can start your Clojure app/server. See Custom Connect Sequences for how to let Calva do this for you automatically. See the same article for ways to automate more of the Jack-In process. It can be brought down to a single Jack-In command/action, even for a full stack Clojure and ClojureScript application.","title":"Starting Your Clojure App"},{"location":"jack-in-guide/#clojurescript","text":"For ClojureScript, things are not done yet, though, far from it. It turns out that cooking the command line was the easy part. In order for Calva to provide REPL power for ClojureScript projects, several things need to happen: A Clojure nREPL connection needs to be established. We've covered that above. Calva makes an nREPL session clone to use for the ClojureScript REPL and then: Your ClojureScript app needs to be compiled. Your ClojureScript app needs to be started. The Clojure nREPL session needs to be promoted to a ClojureScript nREPL session. (This is what piggieback helps with.)","title":"ClojureScript"},{"location":"jack-in-guide/#compiling-the-app-and-watchers","text":"Depending on ClojureScript project type, Calva uses different methods to start the compilation and the watcher: Figwheel: The compilation and the watchers are started in the Clojure REPL session. (This is both for Figwheel Main and for lein-figwheel.) shadow-cljs: The compilation and the watchers are started with the Jack-In command line. This results in a bit of difference in the user interaction. Mainly that for shadow-cljs, the user needs to check the Jack-In Terminal tab to follow what's going on.","title":"Compiling the App and Watchers"},{"location":"jack-in-guide/#starting-the-app","text":"Number 3 above, the app needs to be started , might seem obvious, but it actually trips many people up. Because of this, Calva goes to quite some lengths to provide assistance. Many projects are configured not to spawn a browser session automatically, requesting the app once it has been compiled, so we can't rely on that. What Calva does instead is to monitor the output of the commands it uses for starting the compilation, looking for information that the app is ready to be requested/started. It then tells the user this, providing a URL, in case it is a browser app. (There are also settings that tell Calva to open the URL automatically for you, regardless what the project settings are.)","title":"Starting the App"},{"location":"jack-in-guide/#connecting_1","text":"Meanwhile, Calva is monitoring the output and when it sees that the app is started, it continues to hook up the REPL connection to the editor. This whole connection sequence is quite configurable, using Custom Connect Sequences . In fact, Calva's built in ClojureScript sequences (Figwheel Main, lein-figwheel, shadow-cljs, and ClojureScript built-ins for both Browser and Node) are all built using those same settings mechanisms.","title":"Connecting"},{"location":"jack-in-guide/#shadow-cljs-is-less-managed-by-calva","text":"NB: The managed way in which Calva creates and connects the ClojureScript REPL breaks apart a bit for shadow-cljs, which works a bit differently and also outputs most of the information Calva is looking for on the stdout of the REPL start command (where Calva can't see it, remember?). We'll figure out a better way to support shadow-cljs, but for now, the user needs to do more of this figuring out than is needed with Figwheel projects.","title":"shadow-cljs is Less Managed by Calva"},{"location":"jack-in-guide/#hack-away","text":"So, there are things going on when you start Jack-In, and even more things for ClojureScript projects, but Calva tries to keep it together, so as a user it is a matter of paying attention and responding to a few prompts/menus with pre-populated options (prompts which can be configured away, even).","title":"Hack Away"},{"location":"jack-in-guide/#switch-clojurescript-builds","text":"Once the REPL is connected you might want to change which ClojureScript build you have Calva connected to. For this Calva has the Select CLJS Build Connection command. Please note that you can only switch between builds that you have started.","title":"Switch ClojureScript Builds"},{"location":"jack-in-guide/#play-with-starting-the-cljs-repl-yourself","text":"To get a good grip on what is going on when creating and connecting the ClojureScript REPL, I can recommend making a custom connect sequence which leaves the REPL unpromoted (e.g. give it nil as connectCode ), and then evaluate the cljs-repl start commands yourself. So for instance, promoting it to a ClojureScript Node.js REPL looks something like so: user=> ( require 'cljs.repl.node ) user=> ( cider.piggieback/cljs-repl ( cljs.repl.node/repl-env )) ClojureScript 1.10 .844 To quit , type : :cljs/quit nil cljs.user=> | It is the piggieback middleware there telling you that you can unpromote the REPL by \u201devaluating\u201d :cljs/quit .","title":"Play With Starting the cljs-repl Yourself"},{"location":"jack-in-guide/#about-full-stack-applications","text":"Because Calva uses the Clojure REPL connection to spawn the ClojureScript REPL, and because Calva only handles one Clojure REPL per VS Code window, some projects need special handling by the user. If your full stack project is using shadow-cljs for the frontend, like this Fulcro template project does, maybe you first try to Jack-In to your backend Clojure REPL, and then to your shadow-cljs frontend. This works if you do it in separate VS Code windows, but if you do it in the same window, the second Jack-In will kill the backend session! See Workspace Layouts for tips about how to open the same project folder in two separate VS Code windows.","title":"About Full Stack Applications"},{"location":"jack-in-guide/#please-grab-your-calva-jack-in-certificate","text":"There, you now know all there is to know about Calva Jack-In. Just kidding, there are a few more details to it, some of which might find their way into this article at a later time. To really get to know it all, you will need to spend some time with the Calva Jack-In code. Head over to the Calva Development Wiki to learn how to hack on Calva.","title":"Please Grab your Calva Jack-In Certificate"},{"location":"krell/","text":"Using Calva With Krell Krell is \u00e0 la carte ClojureScript tooling for React Native. Even if Calva does not yet have built-in support, all is not lost. You can add support yourself by way of a Custom REPL Connect Sequence . Here's how; Starting the Krell ClojureScript REPL Add this REPL Connect Sequence to your workspace settings.json : \"calva.replConnectSequences\" : [ { \"name\" : \"deps.edn + Krell\" , \"projectType\" : \"deps.edn\" , \"cljsType\" : { \"connectCode\" : \"(require '[clojure.edn :as edn] \\n '[clojure.java.io :as io]\\n '[cider.piggieback] \\n '[krell.api :as krell]\\n '[krell.repl])\\n\\n(def config (edn/read-string (slurp (io/file \\\"build.edn\\\"))))\\n(apply cider.piggieback/cljs-repl (krell.repl/repl-env) (mapcat identity config))\" , \"dependsOn\" : \"User provided\" } } ] Then issue the command Start a Project REPL and Connect (aka Jack-In) . It start the project and connect to the Krell REPL once the app is running on a device (wether real or virtual/emulated). Additional VS Code Tips For a smooth workflow you can also: Install the React Native Tools extension Install the Debugger for Chrome extension, and add this Launch Configuration { \"type\" : \"chrome\" , \"request\" : \"launch\" , \"name\" : \"Launch Debugger\" , \"url\" : \"http://localhost:8081/debugger-ui/\" , \"webRoot\" : \"${workspaceFolder}\" } Together with the connect sequence this will make for a start of a Krell session like this: Open the project root in VS Code Issue the Jack-in command Issue the React Native; Run Android on Emulator (or Run iOS on Simulator ) command. (Disable Fast Refresh from the *React Native dev menu, if it is enabled.) Issue the React Native: Run Element Inspector command (You might need to install the React Native inspector globally): ```sh yarn global add react-devtools ```` Launch Debugger ( F5 ) Hack away, with hot reload and interactive REPL Once the debugger (a Chrome session) is running, you probably will want to enable Custom Formatters in order for clojure structures to be logged conveniently.","title":"Using Calva With Krell"},{"location":"krell/#using-calva-with-krell","text":"Krell is \u00e0 la carte ClojureScript tooling for React Native. Even if Calva does not yet have built-in support, all is not lost. You can add support yourself by way of a Custom REPL Connect Sequence . Here's how;","title":"Using Calva With Krell"},{"location":"krell/#starting-the-krell-clojurescript-repl","text":"Add this REPL Connect Sequence to your workspace settings.json : \"calva.replConnectSequences\" : [ { \"name\" : \"deps.edn + Krell\" , \"projectType\" : \"deps.edn\" , \"cljsType\" : { \"connectCode\" : \"(require '[clojure.edn :as edn] \\n '[clojure.java.io :as io]\\n '[cider.piggieback] \\n '[krell.api :as krell]\\n '[krell.repl])\\n\\n(def config (edn/read-string (slurp (io/file \\\"build.edn\\\"))))\\n(apply cider.piggieback/cljs-repl (krell.repl/repl-env) (mapcat identity config))\" , \"dependsOn\" : \"User provided\" } } ] Then issue the command Start a Project REPL and Connect (aka Jack-In) . It start the project and connect to the Krell REPL once the app is running on a device (wether real or virtual/emulated).","title":"Starting the Krell ClojureScript REPL"},{"location":"krell/#additional-vs-code-tips","text":"For a smooth workflow you can also: Install the React Native Tools extension Install the Debugger for Chrome extension, and add this Launch Configuration { \"type\" : \"chrome\" , \"request\" : \"launch\" , \"name\" : \"Launch Debugger\" , \"url\" : \"http://localhost:8081/debugger-ui/\" , \"webRoot\" : \"${workspaceFolder}\" } Together with the connect sequence this will make for a start of a Krell session like this: Open the project root in VS Code Issue the Jack-in command Issue the React Native; Run Android on Emulator (or Run iOS on Simulator ) command. (Disable Fast Refresh from the *React Native dev menu, if it is enabled.) Issue the React Native: Run Element Inspector command (You might need to install the React Native inspector globally): ```sh yarn global add react-devtools ```` Launch Debugger ( F5 ) Hack away, with hot reload and interactive REPL Once the debugger (a Chrome session) is running, you probably will want to enable Custom Formatters in order for clojure structures to be logged conveniently.","title":"Additional VS Code Tips"},{"location":"linting/","text":"Linting Calva does no linting, yet with Calva you get excellent linting. That is because Calva uses clojure-lsp , which provides linting powered by clj-kondo. You might want to read about how to configure clj-kondo . These two sections might be of extra interest: Unrecognized macros Lint a custom macro like a built-in macro If you see a linting squiggle under the first character of the file with an error you don't quite understand, it is probably something wrong with your clj-kondo configuration. Files are linted as they're being edited. If you want to lint the whole project, use the clj-kondo cli command. See https://github.com/borkdude/clj-kondo for more info on that. Windows users might like to know that they too can get a clj-kondo cli command now, via npm install -g clj-kondo . It'll be a bit slower to start than the native build, but for sure it's better than not having a clj-kondo command! See https://github.com/borkdude/clj-kondo/blob/master/doc/install.md#npm-linux-macos-windows for more on this. Resolve Macro As When your cursor is on a macro form in the editor, you may notice a code action (click the light bulb that appears) called Resolve Macro As. Running this code action will ask you what macro you'd like to resolve the current macro as, and then what clj-kondo config file you want the macro to be saved to. This code action is also available as a command.","title":"Linting"},{"location":"linting/#linting","text":"Calva does no linting, yet with Calva you get excellent linting. That is because Calva uses clojure-lsp , which provides linting powered by clj-kondo. You might want to read about how to configure clj-kondo . These two sections might be of extra interest: Unrecognized macros Lint a custom macro like a built-in macro If you see a linting squiggle under the first character of the file with an error you don't quite understand, it is probably something wrong with your clj-kondo configuration. Files are linted as they're being edited. If you want to lint the whole project, use the clj-kondo cli command. See https://github.com/borkdude/clj-kondo for more info on that. Windows users might like to know that they too can get a clj-kondo cli command now, via npm install -g clj-kondo . It'll be a bit slower to start than the native build, but for sure it's better than not having a clj-kondo command! See https://github.com/borkdude/clj-kondo/blob/master/doc/install.md#npm-linux-macos-windows for more on this.","title":"Linting"},{"location":"linting/#resolve-macro-as","text":"When your cursor is on a macro form in the editor, you may notice a code action (click the light bulb that appears) called Resolve Macro As. Running this code action will ask you what macro you'd like to resolve the current macro as, and then what clj-kondo config file you want the macro to be saved to. This code action is also available as a command.","title":"Resolve Macro As"},{"location":"live-share/","text":"Using Calva with Live Share Live Share is a Microsoft provided VS Code extension. It allows you to share the workspace that you have open in your computer with somebody else. Everybody is then working on the same source code files, namely those on your computer. You can edit files at the same time, everyone has their own caret. You can follow each other (i.e. when someone switches to a different file, you will as well). This is great for remote pair programming, for example. An extra nice thing is that each participant is using their own VSCode configuration, including fonts, colors, keyboard shortcuts, etc. Calva Supports Live Share When using Calva, you can use Live Share as well. Editing works exactly the same as for any other programming language. What makes Calva a bit special, is the REPL. When using Live Share, Calva allows the host to share the REPL with guests as well. If you use any of the supported configuration, this will be pretty much automatic. This is what a typical scenario looks like: The host jacks-in. The host shares its workspace using Live Share. Calva will detect that the workspace is being shared, so it will offer to share the REPL port that was opened when jacking in. The host clicks \"Allow\" to start sharing the port. (Note: steps 1 and two can also be done in the reverse order.) The host sends the Live Share URL to the guest(s). The guest joins the Live Share session using the URL it received. The guest connects to the host's REPL using the command \"Connect to a running REPL server in the project\". If needed, the guest chooses the same build configuration as the host. Voila! Both the guest and the host can now use the REPL that is running on the host. Things like documentation lookup now also work on the guest's machine. Control Visibility of .calva Folder Calva depends on the output.calva-repl file to be available. If you have the .calva folder listed in your .gitignore , this also causes the folder to be hidden from guests in Live Share by default. In order to make the folder visible, you can put a file called .vsls.json in your project. In its simplest form, the contents can be this: { \"$schema\" : \"http://json.schemastore.org/vsls\" , \"hideFiles\" : [ \"!.calva\" ] } Now the .calva folder is shared as well. But also any other file and folder that you may have in your .gitignore . If you want to have more fine-grained control, please refer to the section Controlling file access and visibility of the Live Share documentation. Some Things To Keep In Mind As a guest, you're connected to a REPL running on the host's machine. With power comes responsibility; be nice, and be careful ! There is only one output.calva-repl file, which all participants are sharing. It may work better to evaluate things in the source code editors instead of from the REPL window. Otherwise you will end up in a situation where one person is typing something in the output.calva-repl window, and somebody else is evaluating something (hence sending the output there) at the same time. That gets confusing quickly. When you're working on a CLJS-based web development project, things may get extra confusing. By default, Live Share will share any HTTP ports on the host automatically, and also offer to open the URL on the guest. (You can disable using the setting \"Liveshare: Open Shared Servers\".) As a guest, you do not want to open that browser window normally. Think about it: where is the REPL running? Yes: in the browser! But Calva connects to the REPL running in the browser on the host's machine, so if you open a browser as a guest, you will also get a REPL there, but you won't be connected to it in Calva. Currently Live Share does not allow Calva to know whether the workspace is shared read-only or read-write. If you share read-only, and you don't want the guests to have access to your REPL, don't click \"Allow\" when VSCode asks you to share the REPL port.","title":"Using Calva with Live Share"},{"location":"live-share/#using-calva-with-live-share","text":"Live Share is a Microsoft provided VS Code extension. It allows you to share the workspace that you have open in your computer with somebody else. Everybody is then working on the same source code files, namely those on your computer. You can edit files at the same time, everyone has their own caret. You can follow each other (i.e. when someone switches to a different file, you will as well). This is great for remote pair programming, for example. An extra nice thing is that each participant is using their own VSCode configuration, including fonts, colors, keyboard shortcuts, etc.","title":"Using Calva with Live Share"},{"location":"live-share/#calva-supports-live-share","text":"When using Calva, you can use Live Share as well. Editing works exactly the same as for any other programming language. What makes Calva a bit special, is the REPL. When using Live Share, Calva allows the host to share the REPL with guests as well. If you use any of the supported configuration, this will be pretty much automatic. This is what a typical scenario looks like: The host jacks-in. The host shares its workspace using Live Share. Calva will detect that the workspace is being shared, so it will offer to share the REPL port that was opened when jacking in. The host clicks \"Allow\" to start sharing the port. (Note: steps 1 and two can also be done in the reverse order.) The host sends the Live Share URL to the guest(s). The guest joins the Live Share session using the URL it received. The guest connects to the host's REPL using the command \"Connect to a running REPL server in the project\". If needed, the guest chooses the same build configuration as the host. Voila! Both the guest and the host can now use the REPL that is running on the host. Things like documentation lookup now also work on the guest's machine.","title":"Calva Supports Live Share"},{"location":"live-share/#control-visibility-of-calva-folder","text":"Calva depends on the output.calva-repl file to be available. If you have the .calva folder listed in your .gitignore , this also causes the folder to be hidden from guests in Live Share by default. In order to make the folder visible, you can put a file called .vsls.json in your project. In its simplest form, the contents can be this: { \"$schema\" : \"http://json.schemastore.org/vsls\" , \"hideFiles\" : [ \"!.calva\" ] } Now the .calva folder is shared as well. But also any other file and folder that you may have in your .gitignore . If you want to have more fine-grained control, please refer to the section Controlling file access and visibility of the Live Share documentation.","title":"Control Visibility of .calva Folder"},{"location":"live-share/#some-things-to-keep-in-mind","text":"As a guest, you're connected to a REPL running on the host's machine. With power comes responsibility; be nice, and be careful ! There is only one output.calva-repl file, which all participants are sharing. It may work better to evaluate things in the source code editors instead of from the REPL window. Otherwise you will end up in a situation where one person is typing something in the output.calva-repl window, and somebody else is evaluating something (hence sending the output there) at the same time. That gets confusing quickly. When you're working on a CLJS-based web development project, things may get extra confusing. By default, Live Share will share any HTTP ports on the host automatically, and also offer to open the URL on the guest. (You can disable using the setting \"Liveshare: Open Shared Servers\".) As a guest, you do not want to open that browser window normally. Think about it: where is the REPL running? Yes: in the browser! But Calva connects to the REPL running in the browser on the host's machine, so if you open a browser as a guest, you will also get a REPL there, but you won't be connected to it in Calva. Currently Live Share does not allow Calva to know whether the workspace is shared read-only or read-write. If you share read-only, and you don't want the guests to have access to your REPL, don't click \"Allow\" when VSCode asks you to share the REPL port.","title":"Some Things To Keep In Mind"},{"location":"luminus/","text":"How to Use Calva with Luminus Luminus is a powerful and versatile Leiningen template for creating web development projects. It comes with built in configuration which makes it easy to use Calva as your Clojure(Script) editor. Server + shadow-cljs Basically this is the same wokflow as with Server only . Behind the scenes there is more happening, though. Such as the ClojureScript app being built and the CLJS REPL connected once the web app is running. If you haven't created the project yet, create a new shadow-cljs Luminus project. E.g.: $ lein new luminus my-luminus-shadow +reagent +re-frame +shadow-cljs Install npm dependencies $ npm i (Or yarn if you prefer.) This creates the folder my-luminus-shadow . Open it in VS Code: $ code my-luminus-shadow Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j Select to start my-luminus-shadow Server + Client , and wait for the Terminal Calva Jack-in output to say [:app] Build completed. Open 127.0.0.1:3000 in your web browser and start hacking. Note Currently Calva has troubles following the app-start with shadow-cljs, so Calva will report Jack-in done. in the output window before shadow-cljs is actually done building the app. If you open the app page at that stage, you will see a message to \u201cPlease run lein shadow watch app \u201d. Rest assured that this is already underway. Follow the Jack-in process in the Terminal tab in VS Code for the message that the app is built, then reload the app page in the web browser. Server Only The workflow here is really just: Jack-in and start hacking. However, the first time it will involve these steps: If you haven't created the project yet, create a new server only Luminus project. For a all-defaults setup it is like so: $ lein new luminus my-luminus-server This creates the folder my-luminus-server . Open it in VS Code: $ code my-luminus-server Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j Select to start my-luminus-shadow Server and wait until you see Jack-in done. in the output window. Open 127.0.0.1:3000 in your web browser and start hacking. Server + Figwheel This is Legacy Figwheel (lein-figwheel), so the recommendation is to use the shadow-cljs setup instead. As with the server only, the workflow here is really just: Jack-in and start hacking. The first time it involves these steps: If you haven't created the project yet, create a new server only Luminus project. E.g.: $ lein new luminus my-fw +reagent This creates the folder my-fw . Open it in VS Code: $ code my-fw Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j , select Server + Client - my-fw in the Project type picker menu, and wait for the web app to pop open in your web browser. Start hacking. If you prefer to open the web app yourself, open .vscode/settings.json and change \"shouldOpenUrl\" to false in the pre-configured Calva connect sequence. Calva will then print the URL 127.0.0.1:3000 in the output, so that you can click it open. Etcetera You will have three Calva Custom Command Snippets configured. Invoke them by issuing the Run Custom REPL Command , ctrl+alt+c . (that's a dot). These commands control the Luminus server: Start <project> Server Stop <project> Server Restart <project> Server When used, Calva will open its REPL window and execute the command, if it is not already opened. You can close this window if you prefer to use the REPL directly from the Clojure files. Calva also opens the REPL window, and starts the Luminus server, as part of the Jack-in process.","title":"How to Use Calva with Luminus"},{"location":"luminus/#how-to-use-calva-with-luminus","text":"Luminus is a powerful and versatile Leiningen template for creating web development projects. It comes with built in configuration which makes it easy to use Calva as your Clojure(Script) editor.","title":"How to Use Calva with Luminus"},{"location":"luminus/#server-shadow-cljs","text":"Basically this is the same wokflow as with Server only . Behind the scenes there is more happening, though. Such as the ClojureScript app being built and the CLJS REPL connected once the web app is running. If you haven't created the project yet, create a new shadow-cljs Luminus project. E.g.: $ lein new luminus my-luminus-shadow +reagent +re-frame +shadow-cljs Install npm dependencies $ npm i (Or yarn if you prefer.) This creates the folder my-luminus-shadow . Open it in VS Code: $ code my-luminus-shadow Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j Select to start my-luminus-shadow Server + Client , and wait for the Terminal Calva Jack-in output to say [:app] Build completed. Open 127.0.0.1:3000 in your web browser and start hacking. Note Currently Calva has troubles following the app-start with shadow-cljs, so Calva will report Jack-in done. in the output window before shadow-cljs is actually done building the app. If you open the app page at that stage, you will see a message to \u201cPlease run lein shadow watch app \u201d. Rest assured that this is already underway. Follow the Jack-in process in the Terminal tab in VS Code for the message that the app is built, then reload the app page in the web browser.","title":"Server + shadow-cljs"},{"location":"luminus/#server-only","text":"The workflow here is really just: Jack-in and start hacking. However, the first time it will involve these steps: If you haven't created the project yet, create a new server only Luminus project. For a all-defaults setup it is like so: $ lein new luminus my-luminus-server This creates the folder my-luminus-server . Open it in VS Code: $ code my-luminus-server Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j Select to start my-luminus-shadow Server and wait until you see Jack-in done. in the output window. Open 127.0.0.1:3000 in your web browser and start hacking.","title":"Server Only"},{"location":"luminus/#server-figwheel","text":"This is Legacy Figwheel (lein-figwheel), so the recommendation is to use the shadow-cljs setup instead. As with the server only, the workflow here is really just: Jack-in and start hacking. The first time it involves these steps: If you haven't created the project yet, create a new server only Luminus project. E.g.: $ lein new luminus my-fw +reagent This creates the folder my-fw . Open it in VS Code: $ code my-fw Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j , select Server + Client - my-fw in the Project type picker menu, and wait for the web app to pop open in your web browser. Start hacking. If you prefer to open the web app yourself, open .vscode/settings.json and change \"shouldOpenUrl\" to false in the pre-configured Calva connect sequence. Calva will then print the URL 127.0.0.1:3000 in the output, so that you can click it open.","title":"Server + Figwheel"},{"location":"luminus/#etcetera","text":"You will have three Calva Custom Command Snippets configured. Invoke them by issuing the Run Custom REPL Command , ctrl+alt+c . (that's a dot). These commands control the Luminus server: Start <project> Server Stop <project> Server Restart <project> Server When used, Calva will open its REPL window and execute the command, if it is not already opened. You can close this window if you prefer to use the REPL directly from the Clojure files. Calva also opens the REPL window, and starts the Luminus server, as part of the Jack-in process.","title":"Etcetera"},{"location":"merch/","text":"Calva Merch In this video, there is a question about where you can buy the Calva T-shirt: You couldn't, then. But now you can! On Amazon. Zero profit To keep the admin of this shop to a minimum the merch is sold at production prize. There is no royalty going to anyone in the Calva team when you buy one of these t-shirts. You will represent, which is certainly a way to support the project. You are of course encouraged to support us via sponsoring as well: Sponsor Peter Str\u00f6mberg Sponsor Brandon Ringe The designs There are four design, all featuring the Calva symbol (the Calva glass), which are all available for a Standard T-shirt, in men's, women's and kid's cut, and in some different colors. In the .com store there are also Premium T-shirts**. Symbol + Logo Available at: https://www.amazon.com/dp/B09BCVH9SC (Premium T-shirt) https://www.amazon.com/dp/B097TB5QFW https://www.amazon.de/dp/B098GWQC6M https://www.amazon.co.uk/dp/B098KM9XMF https://www.amazon.fr/dp/B0994TYXTN https://www.amazon.it/dp/B099KLJJV1 https://www.amazon.es/dp/B099NXR71Y https://www.amazon.co.jp/dp/B097YZVMC4 Symbol + Logo + We do it with Rich Comments The Calva symbol and Logo front, Rich Comments back. Available at: https://www.amazon.com/dp/B09C4PBH5N (Premium T-shirt) https://www.amazon.com/dp/B09BFMRCHL https://www.amazon.de/dp/B09C3VYZH8 https://www.amazon.co.uk/dp/B09BLD2BVJ https://www.amazon.fr/dp/B09C3X1H7K https://www.amazon.it/dp/B09C3WV2JQ https://www.amazon.es/dp/B09C4P1GD1 https://www.amazon.co.jp/dp/B09C4P45MR Symbol Only Available at: https://www.amazon.com/dp/B09B83481D (Premium T-shirt) https://www.amazon.com/dp/B097TB5QFW https://www.amazon.de/dp/B098434W9M https://www.amazon.co.uk/dp/B098KNGPBB https://www.amazon.fr/dp/B099RZGNN7 https://www.amazon.it/dp/B099WYH94Z https://www.amazon.es/dp/B09B2TFCSR https://www.amazon.co.jp/dp/B09B4XN3HY Symbol + We do it with Rich Comments The Calva symbol front, Rich Comments Back. Available at: https://www.amazon.com/dp/B098M34FKJ (Premium T-shirt) https://www.amazon.com/dp/B0993VCG7P https://www.amazon.de/dp/B098MF14PV https://www.amazon.co.uk/dp/B098P1MV44 https://www.amazon.fr/dp/B098TPQFCJ https://www.amazon.it/dp/B098YP33ZL https://www.amazon.es/dp/B098RDPK55 https://www.amazon.co.jp/dp/B0992MQYG6 Note What's available on this or that Amazon site will vary a bit and it is a bit slow to add a particular design to a particular market. Eventually I hope to have both designs up on these markets: .com , .co.uk , .de , .fr , .it , .es , and .co.jp","title":"Calva Merch"},{"location":"merch/#calva-merch","text":"In this video, there is a question about where you can buy the Calva T-shirt: You couldn't, then. But now you can! On Amazon.","title":"Calva Merch"},{"location":"merch/#zero-profit","text":"To keep the admin of this shop to a minimum the merch is sold at production prize. There is no royalty going to anyone in the Calva team when you buy one of these t-shirts. You will represent, which is certainly a way to support the project. You are of course encouraged to support us via sponsoring as well: Sponsor Peter Str\u00f6mberg Sponsor Brandon Ringe","title":"Zero profit"},{"location":"merch/#the-designs","text":"There are four design, all featuring the Calva symbol (the Calva glass), which are all available for a Standard T-shirt, in men's, women's and kid's cut, and in some different colors. In the .com store there are also Premium T-shirts**.","title":"The designs"},{"location":"merch/#symbol-logo","text":"Available at: https://www.amazon.com/dp/B09BCVH9SC (Premium T-shirt) https://www.amazon.com/dp/B097TB5QFW https://www.amazon.de/dp/B098GWQC6M https://www.amazon.co.uk/dp/B098KM9XMF https://www.amazon.fr/dp/B0994TYXTN https://www.amazon.it/dp/B099KLJJV1 https://www.amazon.es/dp/B099NXR71Y https://www.amazon.co.jp/dp/B097YZVMC4","title":"Symbol + Logo"},{"location":"merch/#symbol-logo-we-do-it-with-rich-comments","text":"The Calva symbol and Logo front, Rich Comments back. Available at: https://www.amazon.com/dp/B09C4PBH5N (Premium T-shirt) https://www.amazon.com/dp/B09BFMRCHL https://www.amazon.de/dp/B09C3VYZH8 https://www.amazon.co.uk/dp/B09BLD2BVJ https://www.amazon.fr/dp/B09C3X1H7K https://www.amazon.it/dp/B09C3WV2JQ https://www.amazon.es/dp/B09C4P1GD1 https://www.amazon.co.jp/dp/B09C4P45MR","title":"Symbol + Logo + We do it with Rich Comments"},{"location":"merch/#symbol-only","text":"Available at: https://www.amazon.com/dp/B09B83481D (Premium T-shirt) https://www.amazon.com/dp/B097TB5QFW https://www.amazon.de/dp/B098434W9M https://www.amazon.co.uk/dp/B098KNGPBB https://www.amazon.fr/dp/B099RZGNN7 https://www.amazon.it/dp/B099WYH94Z https://www.amazon.es/dp/B09B2TFCSR https://www.amazon.co.jp/dp/B09B4XN3HY","title":"Symbol Only"},{"location":"merch/#symbol-we-do-it-with-rich-comments","text":"The Calva symbol front, Rich Comments Back. Available at: https://www.amazon.com/dp/B098M34FKJ (Premium T-shirt) https://www.amazon.com/dp/B0993VCG7P https://www.amazon.de/dp/B098MF14PV https://www.amazon.co.uk/dp/B098P1MV44 https://www.amazon.fr/dp/B098TPQFCJ https://www.amazon.it/dp/B098YP33ZL https://www.amazon.es/dp/B098RDPK55 https://www.amazon.co.jp/dp/B0992MQYG6 Note What's available on this or that Amazon site will vary a bit and it is a bit slow to add a particular design to a particular market. Eventually I hope to have both designs up on these markets: .com , .co.uk , .de , .fr , .it , .es , and .co.jp","title":"Symbol + We do it with Rich Comments"},{"location":"namespace-form-auto-creation/","text":"Namespace Form Auto-creation When you create a new clojure file, a file with .clj , .cljc or .cljs extension, an appropriate namespace form will be added to the file. This feature is provided by clojure-lsp .","title":"Namespace Form Auto-creation"},{"location":"namespace-form-auto-creation/#namespace-form-auto-creation","text":"When you create a new clojure file, a file with .clj , .cljc or .cljs extension, an appropriate namespace form will be added to the file. This feature is provided by clojure-lsp .","title":"Namespace Form Auto-creation"},{"location":"output/","text":"The Output/REPL Window/File When Calva evaluates Clojure/ClojureScript code, the results are displayed inline as well as printed to the results output window/file. This file is created and opened when Calva is connected to a REPL. In ClojureScript projects the window will be associated with the cljs REPL once this one is connected. It will then look something like so: The first prompt is from when the clj REPL is connected, the second when Calva has a cljs REPL connection. The first part of the prompt tells you which REPL type the window is currently connected to. This gets important when the file/window is used as an interactive REPL. Find the Output/REPL Window If you quickly want to open and switch to the output window there is the command Calva: Show Output Window , ctrl+alt+c o . To sync the Output/REPL window namespace with the current file before switching, use the Switch Namespace of the Output/REPL Window to Current Namespace command, ctrl+alt+c alt+n . Find the File for the Current REPL Window Namespace When you are working from the Output/REPL window, and want to open the file that defines its current namespace, use the Show File for the Current Output/REPL Window Namespace command, ctrl+alt+c o . Note This also works for Clojure core and library namespaces. Evaluating Code The window will be automatically associated with the REPL and the namespace of any project Clojure/ClojureScript file you evaluate code in. So for instance if you evaluate this code in a clj file with the namespace fresh-reagent.handler : ( def mount-target [ :div#app [ :h2 \"Welcome to fresh-reagent\" ] [ :p \"please wait while Figwheel is waking up ...\" ] [ :p \"(Check the js console for hints if nothing exciting happens.)\" ]]) The output window will print the defined var and then a new prompt reflecting the current REPL connection and namespace: If you then switch to the output window ( ctrl+alt+c o ), and enter this at the prompt: mount-target then evaluate it using alt+enter , you'll get: This, since the namespace \u201dfollowed\u201d the first evaluation over to the output window. REPL History Recently evaluated forms in the REPL file are persisted and can easily be shown again for modifying and re-evaluating. Navigate REPL History You can navigate up and down the last forms evaluated in the REPL file by using alt+up and alt+down , provided your cursor is at the end of the last form after the prompt. If the cursor is not at the end of the last form, then alt+up and alt+down will do what they are mapped to, which is by default \"Move Line Up\" and \"Move Line Down,\" respectively. If you have typed some text after the prompt before you start traversing up the history, this text will be preserved and will display when you traverse back down the history. If you modify some text in the history while traversing, the modification will be saved at that location in history. Clear REPL History You can clear the repl history by running the command \"Clear REPL History\" from the command palette. Stack Traces When an evaluation produces an error, the output window will automatically print the the error message. If there is a stack trace associated with the error, this can now be printed on demand using the Calva: Print Last Stacktrace to the Output Window command. The output window will also have a Codelense button below the error message that will print the stack trace.. For printed stacktraces, when source locations are available (Clojure files) you will be able to navigate to them by pressing ctrl+click ( cmd+click on Mac) on the file name. You can also hover over symbols in the stack trace to see the symbol's documentation, and ctrl+click ( cmd+click on Mac) the symbol to Peek Definition. Load Current Namespace When navigating namespaces it is easy to forget to first require them and that can be a bit tricky to fix. To help with this Calva's command Load Current File also works in the output window, but then acts like Load Current Namespace . Consider you have two files, pez/xxx.clj and pez/yyy.clj , where pez.yyy requires pez.xxx . ( ns pez.xxx ) ( def a :xxx-a ) ( def b :xxx-b ) ( ns pez.yyy ( :require [ pez.xxx ])) ( def a :yyy-a ) ( println \"Hello\" pez.xxx/a ) Then with a freshly jacked-in REPL you do (ns pez.yyy) and want to work with the vars defined there. Clojure will complain. But if you Load Current File , it will start working. Something like so: Note This currently suffers from a limitation in Calva where it won't reload dependencies, so you will sometimes have to do this \u201dmanually\u201d anyway (by opening the files and loading them). See Calva issue #907 Peek Current Namespace A somewhat hidden feature: You can see documentation for, peek and navigate to a namespace by hovering on the namespace symbol in one of the repl window prompts (just like you would if it was not in the prompt \ud83d\ude04). Paredit Enabled The output window is mostly a regular Calva Clojure/ClojureScript file, which make everything that works in a regular file work in this file, including Paredit . This makes it easy to navigate the input and output. For instance, to select the last evaluation results you can press ctrl+w ( shift+alt+right on Windows and Linux): Debugger Enabled The output window is mostly a regular... (you get it), which means you also have the Calva debugger at your command at the REPL prompt (only for clj sessions, so far). So instead of evaluating a function definition using alt+enter you can evaluate it and instrument it for debugging using ctrl+alt+c i . Then call the function. It is Ephemeral The contents of the output/REPL window is written to a file named output.repl in the .calva/output-window directory of your project. The file is recreated at every new session. And you should copy anything you want to keep from this file to wherever you want to keep it. You probably want to add .calva/output-window/ to your .<something>ignore files. (There are some more files in that directory that you shouldn't keep under source control.) Choose CLJ or CLJS REPL Connection In full stack projects, you will probably use the window as a REPL for both clj and cljs . You can toggle which REPL the window is connected to using the command Calva: Toggle REPL Connection for CLJC files . There is a button for this in the status bar: Known Quirks Due to limitations in the VS Code API it is hard for Calva to know if the output file is opened, and also if it is opened more than once. Make it a habit to leave this window opened. And if it is opened in several tabs, expect evaluation printouts to be a bit unpredictable. If you save the output/REPL file (which most often does not make much sense, but anyway) you will sometimes be presented with a message about VS Code being confused about the file contents being out of sync. Just choose to Overwrite the currently saved version and you should be fine.","title":"The Output/REPL Window/File"},{"location":"output/#the-outputrepl-windowfile","text":"When Calva evaluates Clojure/ClojureScript code, the results are displayed inline as well as printed to the results output window/file. This file is created and opened when Calva is connected to a REPL. In ClojureScript projects the window will be associated with the cljs REPL once this one is connected. It will then look something like so: The first prompt is from when the clj REPL is connected, the second when Calva has a cljs REPL connection. The first part of the prompt tells you which REPL type the window is currently connected to. This gets important when the file/window is used as an interactive REPL.","title":"The Output/REPL Window/File"},{"location":"output/#find-the-outputrepl-window","text":"If you quickly want to open and switch to the output window there is the command Calva: Show Output Window , ctrl+alt+c o . To sync the Output/REPL window namespace with the current file before switching, use the Switch Namespace of the Output/REPL Window to Current Namespace command, ctrl+alt+c alt+n .","title":"Find the Output/REPL Window"},{"location":"output/#find-the-file-for-the-current-repl-window-namespace","text":"When you are working from the Output/REPL window, and want to open the file that defines its current namespace, use the Show File for the Current Output/REPL Window Namespace command, ctrl+alt+c o . Note This also works for Clojure core and library namespaces.","title":"Find the File for the Current REPL Window Namespace"},{"location":"output/#evaluating-code","text":"The window will be automatically associated with the REPL and the namespace of any project Clojure/ClojureScript file you evaluate code in. So for instance if you evaluate this code in a clj file with the namespace fresh-reagent.handler : ( def mount-target [ :div#app [ :h2 \"Welcome to fresh-reagent\" ] [ :p \"please wait while Figwheel is waking up ...\" ] [ :p \"(Check the js console for hints if nothing exciting happens.)\" ]]) The output window will print the defined var and then a new prompt reflecting the current REPL connection and namespace: If you then switch to the output window ( ctrl+alt+c o ), and enter this at the prompt: mount-target then evaluate it using alt+enter , you'll get: This, since the namespace \u201dfollowed\u201d the first evaluation over to the output window.","title":"Evaluating Code"},{"location":"output/#repl-history","text":"Recently evaluated forms in the REPL file are persisted and can easily be shown again for modifying and re-evaluating.","title":"REPL History"},{"location":"output/#navigate-repl-history","text":"You can navigate up and down the last forms evaluated in the REPL file by using alt+up and alt+down , provided your cursor is at the end of the last form after the prompt. If the cursor is not at the end of the last form, then alt+up and alt+down will do what they are mapped to, which is by default \"Move Line Up\" and \"Move Line Down,\" respectively. If you have typed some text after the prompt before you start traversing up the history, this text will be preserved and will display when you traverse back down the history. If you modify some text in the history while traversing, the modification will be saved at that location in history.","title":"Navigate REPL History"},{"location":"output/#clear-repl-history","text":"You can clear the repl history by running the command \"Clear REPL History\" from the command palette.","title":"Clear REPL History"},{"location":"output/#stack-traces","text":"When an evaluation produces an error, the output window will automatically print the the error message. If there is a stack trace associated with the error, this can now be printed on demand using the Calva: Print Last Stacktrace to the Output Window command. The output window will also have a Codelense button below the error message that will print the stack trace.. For printed stacktraces, when source locations are available (Clojure files) you will be able to navigate to them by pressing ctrl+click ( cmd+click on Mac) on the file name. You can also hover over symbols in the stack trace to see the symbol's documentation, and ctrl+click ( cmd+click on Mac) the symbol to Peek Definition.","title":"Stack Traces"},{"location":"output/#load-current-namespace","text":"When navigating namespaces it is easy to forget to first require them and that can be a bit tricky to fix. To help with this Calva's command Load Current File also works in the output window, but then acts like Load Current Namespace . Consider you have two files, pez/xxx.clj and pez/yyy.clj , where pez.yyy requires pez.xxx . ( ns pez.xxx ) ( def a :xxx-a ) ( def b :xxx-b ) ( ns pez.yyy ( :require [ pez.xxx ])) ( def a :yyy-a ) ( println \"Hello\" pez.xxx/a ) Then with a freshly jacked-in REPL you do (ns pez.yyy) and want to work with the vars defined there. Clojure will complain. But if you Load Current File , it will start working. Something like so: Note This currently suffers from a limitation in Calva where it won't reload dependencies, so you will sometimes have to do this \u201dmanually\u201d anyway (by opening the files and loading them). See Calva issue #907","title":"Load Current Namespace"},{"location":"output/#peek-current-namespace","text":"A somewhat hidden feature: You can see documentation for, peek and navigate to a namespace by hovering on the namespace symbol in one of the repl window prompts (just like you would if it was not in the prompt \ud83d\ude04).","title":"Peek Current Namespace"},{"location":"output/#paredit-enabled","text":"The output window is mostly a regular Calva Clojure/ClojureScript file, which make everything that works in a regular file work in this file, including Paredit . This makes it easy to navigate the input and output. For instance, to select the last evaluation results you can press ctrl+w ( shift+alt+right on Windows and Linux):","title":"Paredit Enabled"},{"location":"output/#debugger-enabled","text":"The output window is mostly a regular... (you get it), which means you also have the Calva debugger at your command at the REPL prompt (only for clj sessions, so far). So instead of evaluating a function definition using alt+enter you can evaluate it and instrument it for debugging using ctrl+alt+c i . Then call the function.","title":"Debugger Enabled"},{"location":"output/#it-is-ephemeral","text":"The contents of the output/REPL window is written to a file named output.repl in the .calva/output-window directory of your project. The file is recreated at every new session. And you should copy anything you want to keep from this file to wherever you want to keep it. You probably want to add .calva/output-window/ to your .<something>ignore files. (There are some more files in that directory that you shouldn't keep under source control.)","title":"It is Ephemeral"},{"location":"output/#choose-clj-or-cljs-repl-connection","text":"In full stack projects, you will probably use the window as a REPL for both clj and cljs . You can toggle which REPL the window is connected to using the command Calva: Toggle REPL Connection for CLJC files . There is a button for this in the status bar:","title":"Choose CLJ or CLJS REPL Connection"},{"location":"output/#known-quirks","text":"Due to limitations in the VS Code API it is hard for Calva to know if the output file is opened, and also if it is opened more than once. Make it a habit to leave this window opened. And if it is opened in several tabs, expect evaluation printouts to be a bit unpredictable. If you save the output/REPL file (which most often does not make much sense, but anyway) you will sometimes be presented with a message about VS Code being confused about the file contents being out of sync. Just choose to Overwrite the currently saved version and you should be fine.","title":"Known Quirks"},{"location":"paredit/","text":"Paredit \u2013 a Visual Guide Structural editing and navigation for Clojure. What is Paredit? Calva Paredit helps you navigate, select and edit Clojure code in a structural way. LISP isn't line or character oriented, it is based around S-expressions , a.k.a forms. We strongly recommend that you take advantage of the structural nature of Clojure, and have therefore put a lot of work into making Calva Paredit extra awesome. If you are new to Paredit, consider starting with learning the Slurp Forward (pull in the next form into this form) and Barf Forward (push the last form out of this form). It will take you quite far. Strict Mode To protect the integrity of your code, Strict mode is enabled by default. Strict mode keybinding Action Description backspace Delete Backward Deletes one character backwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it will remove both open and close brackets. delete Delete Forward Deletes one character forwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it is removed. alt+backspace Force Delete Backward Deletes one character backwards, even if it will unbalance a form. alt+delete Force Delete Forward Deletes one character forwards, even if it will unbalance a form. Disable at your own peril. Strict mode can be toggled on/off using the Toggle Paredit Mode command, and there is a status bar indicator telling you: Indicator Paredit Mode [\u03bb] Strict (\u03bb) Cave Man (strict mode off) \u03bb No default key bindings Toggle between Strict and Cave Man using: ctrl+alt+p ctrl+alt+m Prevent Unbalanced Closing Brackets There is also a setting, calva.paredit.strictPreventUnmatchedClosingBracket , that will help you to not enter unbalanced closing brackets into the code. Commands The Paredit commands are sorted into Navigation , Selection , and Edit . As mentioned, Slurp and Barf are power commands, which go into the editing category. Learning to navigate structurally, using shortcuts, also saves time and adds precision to your editing. It has the double effect that you at the same time learn how to select structurally, because that is the same, just adding the shift key. To make the command descriptions a bit clearer, each entry is animated. When you try to figure out what is going on in the GIFs, focus on where the cursor is at the start of the animation loop. Strings are not Lists, but Anyway... In Calva Paredit, strings are treated in much the same way as lists are. Here's an example showing Slurp and Barf , Forward/Backward List , and Grow Selection . Navigating (Modify these with shift to select rather than move, see below.) Default keybinding Action Description ctrl+right (win/linux) alt+right (mac) Forward Sexp Moves the cursor forward, to the end of the current form. If at the end, moves to the end of the next form. Will not move out of lists. ctrl+left (win/linux) alt+left (mac) Backward Sexp Moves the cursor backward, to the start of the current form. If at the start, moves to the start of the previous form. Will not move out of lists. ctrl+down Forward Down Sexp Moves the cursor into the following list. ctrl+alt+up Backward Down Sexp Moves the cursor into the preceding list. ctrl+alt+down Forward Up Sexp Moves the cursor forwards, out of the current list. ctrl+up Backward Up Sexp Moves the cursor backwards, out of the current list. ctrl+end Forward to List End/Close Moves the cursor forwards, staying within the current list. ctrl+home Backward to List Start/Open Moves the cursor backwards, staying within the current list. Selecting Most of these commands are selecting \u201dversions\u201d of the navigation commands above. Repeated use will grow the current selection step by step. Default keybinding Action Description shift+alt+right (win/linux) ctrl+w (mac) Expand Selection Starts from the cursor and selects the current form. Then will keep expanding to enclosing forms. shift+alt+left (win/linux) ctrl+shift+w (mac) Shrink Selection Contracts back from an expanded selection performed by any Paredit selection command. (In the animation the selection is first grown using a combination of Grow Selection and some lateral selection commands, then shrunk all the way back down to no selection.) ctrl+alt+w space Select Top Level Form Top level in a structural sence. Typically where your (def ...) / (defn ...) type forms. Please note that (comment ...) forms create a new top level. shift+ctrl+right (win/linux) shift+alt+right (mac) Select Forward Sexp shift+ctrl+left (win/linux) shift+alt+left (mac) Select Backward Sexp ctrl+shift+down Select Forward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+up Select Backward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+down Select Forward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+up Select Backward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+end Select Forward to List End/Close ctrl+shift+home Select Backward to List Start/Open Editing Default keybinding Action Description ctrl+alt+right (mac/win) ctrl+alt+. (linux) Slurp Forward Moves the closing bracket forward , away from the cursor, past the following form, if any. ctrl+alt+left (mac/win) ctrl+alt+, (linux) Barf Forward Moves the closing bracket backward , towards the cursor, past the preceding form. ctrl+alt+shift+left Slurp Backward Moves the opening bracket backward , away from the cursor, past the preceding form, if any. ctrl+alt+shift+right Barf Backward Moves the opening bracket forward , towards the cursor, past the following form. ctrl+alt+s Splice Sexp Remove enclosing brackets. ctrl+shift+s Split Sexp Splits a string, or a list, into two strings, or lists of the same type as the current. ctrl+shift+j Join Sexps/Forms Joins two strings, or two lists of the same type, into one form (string/list). ctrl+alt+p ctrl+alt+r Raise Sexp Replaces the enclosing list with the current form. ctrl+alt+t Transpose Sexps/Forms Swaps place of the two forms surrounding the cursor. alt+up alt+down Drag Sexp Backward/Forward Moves the current form to the behind/in front of the previous/next one. (See below about behavior in maps and binding boxes.) ctrl+alt+shift u ctrl+alt+shift d Drag Sexp Backward Up Drag Sexp Forward Down Moves the current form up/out of the current list, backwards , and down/in to the following list, forwards , keeping the cursor within the sexpr being dragged. ctrl+alt+shift k ctrl+alt+shift j Drag Sexp Forward Up Drag Sexp Backward Down Moves the current form up/out of the current list, forwards , and down/in to the preceding list, backwards , keeping the cursor within the sexpr being dragged. ctrl+shift+c Convolute \u00af\\_(\u30c4)_/\u00af ctrl+shift+delete Kill Sexp Forward Deletes the next form in the same enclosing form as the cursor. ctrl+alt+backspace Kill Sexp Backward Deletes the previous form in the same enclosing form as the cursor. ctrl+delete Kill List Forward Deletes everything from the cursor to the closing of the current enclosing form. ctrl+backspace Kill List Backward Deletes everything from the cursor to the opening of the current enclosing form. ctrl+alt+shift+delete Splice Killing Forward Delete forward to end of the list, then Splice. ctrl+alt+shift+backspace Splice Killing Backwards Delete backward to the start of the list, then Splice. ctrl+alt+shift+p Wrap Around () Wraps the current form, or selection, with parens. ctrl+alt+shift+s Wrap Around [] Wraps the current form, or selection, with square brackets. ctrl+alt+shift+c Wrap Around {} Wraps the current form, or selection, with curlies. ctrl+alt+shift+q Wrap Around \"\" Wraps the current form, or selection, with double quotes. Inside strings it will quote the quotes. ctrl+alt+r ctrl+alt+p / s / c / q Rewrap Changes enclosing brackets of the current form to parens/square brackets/curlies/double quotes.. Copy to Clipboard when killing text You can have the kill commands always copy the deleted code to the clipboard by setting calva.paredit.killAlsoCutsToClipboard to true . If you want to do this more on-demand, you can kill text by using the selection commands and then Cut once you have the selection. Drag bindings forward/backward When dragging forms inside maps and binding boxes, such as with let , for , binding , etcetera, it often makes most sense to drag each binding as a pair. And this is what Calva will do. Like so: And like so (wait for it): About the Keyboard Shortcuts Care has been put in to making the default keybindings somewhat logical, easy to use, and work with most keyboard layouts. Slurp and barf forward are extra accessible to go with the recommendation to learn using these two super handy editing commands. You can choose to disable all default key bindings by configuring calva.paredit.defaultKeyMap to none . (Then you probably also want to register your own shortcuts for the commands you often use.) You can relax how Paredit's shortcuts replace VS Code built in shortcuts a bit by setting calva.paredit.hijackVSCodeDefaults to false . There are some context keys you can utilize to configure keyboard shortcuts with precision. See Customizing Keyboard Shortcuts . The Nuclear Option : You can choose to disable all default key bindings by configuring calva.paredit.defaultKeyMap to none . (Then you probably also want to register your own shortcuts for the commands you often use.) In some instances built-in command defaults are the same as Paredit's defaults, and Paredit's functionality in a particular case is less than what the default is. This is true of Expand Selection and Shrink Selection for Windows/Linux when multiple lines are selected. In this particular case adding !editorHasMultipleSelections to the when clause of the binding makes for a better workflow. The point is that when the bindings overlap and default functionality is desired peaceful integration can be achieved with the right when clause. This is left out of Paredit's defaults to respect user preference, and ease of maintenance. Happy Editing! \u2764\ufe0f","title":"Paredit \u2013 a Visual Guide"},{"location":"paredit/#paredit-a-visual-guide","text":"Structural editing and navigation for Clojure.","title":"Paredit \u2013 a Visual Guide"},{"location":"paredit/#what-is-paredit","text":"Calva Paredit helps you navigate, select and edit Clojure code in a structural way. LISP isn't line or character oriented, it is based around S-expressions , a.k.a forms. We strongly recommend that you take advantage of the structural nature of Clojure, and have therefore put a lot of work into making Calva Paredit extra awesome. If you are new to Paredit, consider starting with learning the Slurp Forward (pull in the next form into this form) and Barf Forward (push the last form out of this form). It will take you quite far.","title":"What is Paredit?"},{"location":"paredit/#strict-mode","text":"To protect the integrity of your code, Strict mode is enabled by default. Strict mode keybinding Action Description backspace Delete Backward Deletes one character backwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it will remove both open and close brackets. delete Delete Forward Deletes one character forwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it is removed. alt+backspace Force Delete Backward Deletes one character backwards, even if it will unbalance a form. alt+delete Force Delete Forward Deletes one character forwards, even if it will unbalance a form. Disable at your own peril. Strict mode can be toggled on/off using the Toggle Paredit Mode command, and there is a status bar indicator telling you: Indicator Paredit Mode [\u03bb] Strict (\u03bb) Cave Man (strict mode off) \u03bb No default key bindings Toggle between Strict and Cave Man using: ctrl+alt+p ctrl+alt+m","title":"Strict Mode"},{"location":"paredit/#prevent-unbalanced-closing-brackets","text":"There is also a setting, calva.paredit.strictPreventUnmatchedClosingBracket , that will help you to not enter unbalanced closing brackets into the code.","title":"Prevent Unbalanced Closing Brackets"},{"location":"paredit/#commands","text":"The Paredit commands are sorted into Navigation , Selection , and Edit . As mentioned, Slurp and Barf are power commands, which go into the editing category. Learning to navigate structurally, using shortcuts, also saves time and adds precision to your editing. It has the double effect that you at the same time learn how to select structurally, because that is the same, just adding the shift key. To make the command descriptions a bit clearer, each entry is animated. When you try to figure out what is going on in the GIFs, focus on where the cursor is at the start of the animation loop.","title":"Commands"},{"location":"paredit/#strings-are-not-lists-but-anyway","text":"In Calva Paredit, strings are treated in much the same way as lists are. Here's an example showing Slurp and Barf , Forward/Backward List , and Grow Selection .","title":"Strings are not Lists, but Anyway..."},{"location":"paredit/#navigating","text":"(Modify these with shift to select rather than move, see below.) Default keybinding Action Description ctrl+right (win/linux) alt+right (mac) Forward Sexp Moves the cursor forward, to the end of the current form. If at the end, moves to the end of the next form. Will not move out of lists. ctrl+left (win/linux) alt+left (mac) Backward Sexp Moves the cursor backward, to the start of the current form. If at the start, moves to the start of the previous form. Will not move out of lists. ctrl+down Forward Down Sexp Moves the cursor into the following list. ctrl+alt+up Backward Down Sexp Moves the cursor into the preceding list. ctrl+alt+down Forward Up Sexp Moves the cursor forwards, out of the current list. ctrl+up Backward Up Sexp Moves the cursor backwards, out of the current list. ctrl+end Forward to List End/Close Moves the cursor forwards, staying within the current list. ctrl+home Backward to List Start/Open Moves the cursor backwards, staying within the current list.","title":"Navigating"},{"location":"paredit/#selecting","text":"Most of these commands are selecting \u201dversions\u201d of the navigation commands above. Repeated use will grow the current selection step by step. Default keybinding Action Description shift+alt+right (win/linux) ctrl+w (mac) Expand Selection Starts from the cursor and selects the current form. Then will keep expanding to enclosing forms. shift+alt+left (win/linux) ctrl+shift+w (mac) Shrink Selection Contracts back from an expanded selection performed by any Paredit selection command. (In the animation the selection is first grown using a combination of Grow Selection and some lateral selection commands, then shrunk all the way back down to no selection.) ctrl+alt+w space Select Top Level Form Top level in a structural sence. Typically where your (def ...) / (defn ...) type forms. Please note that (comment ...) forms create a new top level. shift+ctrl+right (win/linux) shift+alt+right (mac) Select Forward Sexp shift+ctrl+left (win/linux) shift+alt+left (mac) Select Backward Sexp ctrl+shift+down Select Forward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+up Select Backward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+down Select Forward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+up Select Backward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+end Select Forward to List End/Close ctrl+shift+home Select Backward to List Start/Open","title":"Selecting"},{"location":"paredit/#editing","text":"Default keybinding Action Description ctrl+alt+right (mac/win) ctrl+alt+. (linux) Slurp Forward Moves the closing bracket forward , away from the cursor, past the following form, if any. ctrl+alt+left (mac/win) ctrl+alt+, (linux) Barf Forward Moves the closing bracket backward , towards the cursor, past the preceding form. ctrl+alt+shift+left Slurp Backward Moves the opening bracket backward , away from the cursor, past the preceding form, if any. ctrl+alt+shift+right Barf Backward Moves the opening bracket forward , towards the cursor, past the following form. ctrl+alt+s Splice Sexp Remove enclosing brackets. ctrl+shift+s Split Sexp Splits a string, or a list, into two strings, or lists of the same type as the current. ctrl+shift+j Join Sexps/Forms Joins two strings, or two lists of the same type, into one form (string/list). ctrl+alt+p ctrl+alt+r Raise Sexp Replaces the enclosing list with the current form. ctrl+alt+t Transpose Sexps/Forms Swaps place of the two forms surrounding the cursor. alt+up alt+down Drag Sexp Backward/Forward Moves the current form to the behind/in front of the previous/next one. (See below about behavior in maps and binding boxes.) ctrl+alt+shift u ctrl+alt+shift d Drag Sexp Backward Up Drag Sexp Forward Down Moves the current form up/out of the current list, backwards , and down/in to the following list, forwards , keeping the cursor within the sexpr being dragged. ctrl+alt+shift k ctrl+alt+shift j Drag Sexp Forward Up Drag Sexp Backward Down Moves the current form up/out of the current list, forwards , and down/in to the preceding list, backwards , keeping the cursor within the sexpr being dragged. ctrl+shift+c Convolute \u00af\\_(\u30c4)_/\u00af ctrl+shift+delete Kill Sexp Forward Deletes the next form in the same enclosing form as the cursor. ctrl+alt+backspace Kill Sexp Backward Deletes the previous form in the same enclosing form as the cursor. ctrl+delete Kill List Forward Deletes everything from the cursor to the closing of the current enclosing form. ctrl+backspace Kill List Backward Deletes everything from the cursor to the opening of the current enclosing form. ctrl+alt+shift+delete Splice Killing Forward Delete forward to end of the list, then Splice. ctrl+alt+shift+backspace Splice Killing Backwards Delete backward to the start of the list, then Splice. ctrl+alt+shift+p Wrap Around () Wraps the current form, or selection, with parens. ctrl+alt+shift+s Wrap Around [] Wraps the current form, or selection, with square brackets. ctrl+alt+shift+c Wrap Around {} Wraps the current form, or selection, with curlies. ctrl+alt+shift+q Wrap Around \"\" Wraps the current form, or selection, with double quotes. Inside strings it will quote the quotes. ctrl+alt+r ctrl+alt+p / s / c / q Rewrap Changes enclosing brackets of the current form to parens/square brackets/curlies/double quotes.. Copy to Clipboard when killing text You can have the kill commands always copy the deleted code to the clipboard by setting calva.paredit.killAlsoCutsToClipboard to true . If you want to do this more on-demand, you can kill text by using the selection commands and then Cut once you have the selection.","title":"Editing"},{"location":"paredit/#drag-bindings-forwardbackward","text":"When dragging forms inside maps and binding boxes, such as with let , for , binding , etcetera, it often makes most sense to drag each binding as a pair. And this is what Calva will do. Like so: And like so (wait for it):","title":"Drag bindings forward/backward"},{"location":"paredit/#about-the-keyboard-shortcuts","text":"Care has been put in to making the default keybindings somewhat logical, easy to use, and work with most keyboard layouts. Slurp and barf forward are extra accessible to go with the recommendation to learn using these two super handy editing commands. You can choose to disable all default key bindings by configuring calva.paredit.defaultKeyMap to none . (Then you probably also want to register your own shortcuts for the commands you often use.) You can relax how Paredit's shortcuts replace VS Code built in shortcuts a bit by setting calva.paredit.hijackVSCodeDefaults to false . There are some context keys you can utilize to configure keyboard shortcuts with precision. See Customizing Keyboard Shortcuts . The Nuclear Option : You can choose to disable all default key bindings by configuring calva.paredit.defaultKeyMap to none . (Then you probably also want to register your own shortcuts for the commands you often use.) In some instances built-in command defaults are the same as Paredit's defaults, and Paredit's functionality in a particular case is less than what the default is. This is true of Expand Selection and Shrink Selection for Windows/Linux when multiple lines are selected. In this particular case adding !editorHasMultipleSelections to the when clause of the binding makes for a better workflow. The point is that when the bindings overlap and default functionality is desired peaceful integration can be achieved with the right when clause. This is left out of Paredit's defaults to respect user preference, and ease of maintenance. Happy Editing! \u2764\ufe0f","title":"About the Keyboard Shortcuts"},{"location":"parinfer/","text":"Using Calva with Parinfer Yes, you can use Calva with with the Parinfer extension. The only conflict here is that Calva's auto-formatting (that which happens as you type) is going to risk clash with Parinfer's. However, Calva's Paredit is carefully crafted. We suggest you consider that Clojure is a LISP, and therefore structural. There is power in this structure that other languages can not let you wield. Take advantage of this and make Paredit your friend. It takes only some few minutes to learn two or three basic Paredit commands: Select form Slurp Barf Besides letting you benefit from auto-formatting, working this way will quickly bring you in better contact with the structural nature of the Clojure code. You'll thank yourself later. Also, if you find yourself having deleted or added a bracket out of structure, despite Calva Paredit's Strict mode (which you are using, right?) there is a command that might help you heal the structure: Infer Parens from Indentation . That command is actually implemented using the Parinfer library, so it will let you recover from quite many situations. This command is bound to shift+tab by default, making it a good companion to tab which indents based on bracket structure. All that said, what was said first is true: if you want to use the Parinfer extension, you can. You'll probably want to disable Calva's auto-formatting. The setting for controlling this is named calva.fmt.formatAsYouType .","title":"Using Calva with Parinfer"},{"location":"parinfer/#using-calva-with-parinfer","text":"Yes, you can use Calva with with the Parinfer extension. The only conflict here is that Calva's auto-formatting (that which happens as you type) is going to risk clash with Parinfer's. However, Calva's Paredit is carefully crafted. We suggest you consider that Clojure is a LISP, and therefore structural. There is power in this structure that other languages can not let you wield. Take advantage of this and make Paredit your friend. It takes only some few minutes to learn two or three basic Paredit commands: Select form Slurp Barf Besides letting you benefit from auto-formatting, working this way will quickly bring you in better contact with the structural nature of the Clojure code. You'll thank yourself later. Also, if you find yourself having deleted or added a bracket out of structure, despite Calva Paredit's Strict mode (which you are using, right?) there is a command that might help you heal the structure: Infer Parens from Indentation . That command is actually implemented using the Parinfer library, so it will let you recover from quite many situations. This command is bound to shift+tab by default, making it a good companion to tab which indents based on bracket structure. All that said, what was said first is true: if you want to use the Parinfer extension, you can. You'll probably want to disable Calva's auto-formatting. The setting for controlling this is named calva.fmt.formatAsYouType .","title":"Using Calva with Parinfer"},{"location":"polylith/","text":"How to Use Calva with Polylith Polylith is an architecture for backend projects that maximizes development ergonomics and code reuse. When developing a Polylith application you use one REPL for everything. And as such it is a rather vanilla deps.edn project, so there is really not much more to using Calva with Polylith than: Jack in, selecting the deps.edn project type Select aliases, most often :dev and :test Hack away! The RealWorld Example To make it easy to try Polylith out with Calva, the Polylith RealWorld example implementation has some Calva config to get the server started and Calva connected to its REPL quickly: Fork the project and open it in VS Code Jack-in, selecting the Polylith RealWorld Server REPL project type Wait for the REPL prompt to read clj\ua789dev.server\ua789> Evaluate (start! 6003) Hack away! Try it with a Frontend A ClojureScript frontend, of course: Fork the jacekschae/conduit project and open it in VS Code Edit the api-url definition in events.cljs file to be ( def api-url \"http://localhost:6003/api\" ) Jack-in, selecting to start and connect to the :app build Wait for it to compile and then open http://localhost:3000 Hack away!","title":"How to Use Calva with Polylith"},{"location":"polylith/#how-to-use-calva-with-polylith","text":"Polylith is an architecture for backend projects that maximizes development ergonomics and code reuse. When developing a Polylith application you use one REPL for everything. And as such it is a rather vanilla deps.edn project, so there is really not much more to using Calva with Polylith than: Jack in, selecting the deps.edn project type Select aliases, most often :dev and :test Hack away!","title":"How to Use Calva with Polylith"},{"location":"polylith/#the-realworld-example","text":"To make it easy to try Polylith out with Calva, the Polylith RealWorld example implementation has some Calva config to get the server started and Calva connected to its REPL quickly: Fork the project and open it in VS Code Jack-in, selecting the Polylith RealWorld Server REPL project type Wait for the REPL prompt to read clj\ua789dev.server\ua789> Evaluate (start! 6003) Hack away!","title":"The RealWorld Example"},{"location":"polylith/#try-it-with-a-frontend","text":"A ClojureScript frontend, of course: Fork the jacekschae/conduit project and open it in VS Code Edit the api-url definition in events.cljs file to be ( def api-url \"http://localhost:6003/api\" ) Jack-in, selecting to start and connect to the :app build Wait for it to compile and then open http://localhost:3000 Hack away!","title":"Try it with a Frontend"},{"location":"pprint/","text":"Pretty Printing In Calva, pretty printing is a mode. Prettiness is on by default and all your evaluation results will get that treatment. Toggle it There is a pprint indicator to the right in the status bar which shows the status of the mode. Click the indicator to toggle prettification on and off. There is also a Calva: Toggle Pretty Printing for All Evaluations command. Tip: If you have evaluated something time consuming, or that is not idempotent, with pretty printing mistakenly off: toggle it on and evaluate *1 . Configuration For most people the defaults will probably work, but Calva pretty printing comes a few knobs you can turn, and they are all available through the calva.prettyPrintingOptions settings. Things you can set are: Setting Type Effect enabled boolean So this is a third way you can change this mode \ud83d\ude04 printEngine enum Which printer function that will be used. Default is pprint , more about this setting below width number The maximum line length of printed output (or at least the printers will try) maxLength number The maximum number of elements printed in nested nodes, good for evaluating something like (iterate inc 0) , which you shouldn't do without setting maxLength . Most printers will indicate truncated lists with ... at the end. maxDepth number The maximum number of levels deep that will get printed. Different printers mark a stop different ways. puget doesn't support it at all. See Customizing Calva for some tips on adding settings like these. Here's an example of how zprint handles maxDepth (from the Calva implementation of it's client side pretty printing.). ( pretty-print [[[[[[[[ :deeper ]]]]]]]] { :max-depth 4 }) ;; => {:value \"[[[[##]]]]\"} Your Selection of Prettifiers Pretty printing can happen on the server (i.e. in the JVM, via nREPL), or on the client (i.e. in node, via VS Code/Calva). Client side always uses zprint . Server side you can choose from these printers: Print Engine Client or Server Side Comments calva client The nREPL server will plain print the results, and then Calva will pretty it. pprint server Current Calva default ( clojure.core/pprint is a bit basic, but it's tried and tested, and has none of the server side printing issues mentioned below. fipp server puget server Lacks maxDepth option. zprint server Recommended. Will need to be configured before Jack-in if you want Calva's help to inject its dependencies These particular server side functions were chosen because they have pre-configured print-functions in cider-nrepl . Why does Server or Client Side Matter? This matters because on the server all pretty printers, except pprint does more than just pretty print the result that would be printed with plain printing. Pretty printing results on the server causes some results to get expanded. This can have huge implications depending on the results and which printer is used. E.g. for Datomic transaction results, you will get the whole database printed. Twice. Depending on the database, you could be so unlucky that nothing gets printed, and instead you will soon have a very hot computer. Note: With the help of zprint creator, Kim Kinnear , we have found ways to compensate for this problem. Ways that are not yet implemented, but please stay tuned. Then why not always do it client side? It turns out that on the client side there are also things going on. Calva gets the results back as a string and therefore it needs to first be parsed back to EDN , before it can be pretty printed by zprint . And \u2013 here's the catch \u2013 all results are not valid EDN and therefore can't be pretty printed by zprint . Datomic transaction results are one example. Need More Configurability? The current options are limited, because our time developing Calva is limited. But cider-nrepl really allows for fully configurable pretty printing, so it is within reach. Please feel invited to give us feedback on what you would want to configure for the printing of results. File issues and/or chat us up in #calva in the Clojurians slack. Troubleshooting pprint is not working If pprint is not working, try a different pprint engine or use Calva's jack-in to make sure the necessary dependencies are loaded in your REPL. If you are starting your REPL without jack-in and want to continue doing so, you can use the command Copy Jack-in Command to Clipboard then paste the command somewhere to see what dependencies it injects. You can then add these dependencies to your REPL in whatever way suits your needs. Enjoy Prettiful Printing! \u2764\ufe0f","title":"Pretty Printing"},{"location":"pprint/#pretty-printing","text":"In Calva, pretty printing is a mode. Prettiness is on by default and all your evaluation results will get that treatment.","title":"Pretty Printing"},{"location":"pprint/#toggle-it","text":"There is a pprint indicator to the right in the status bar which shows the status of the mode. Click the indicator to toggle prettification on and off. There is also a Calva: Toggle Pretty Printing for All Evaluations command. Tip: If you have evaluated something time consuming, or that is not idempotent, with pretty printing mistakenly off: toggle it on and evaluate *1 .","title":"Toggle it"},{"location":"pprint/#configuration","text":"For most people the defaults will probably work, but Calva pretty printing comes a few knobs you can turn, and they are all available through the calva.prettyPrintingOptions settings. Things you can set are: Setting Type Effect enabled boolean So this is a third way you can change this mode \ud83d\ude04 printEngine enum Which printer function that will be used. Default is pprint , more about this setting below width number The maximum line length of printed output (or at least the printers will try) maxLength number The maximum number of elements printed in nested nodes, good for evaluating something like (iterate inc 0) , which you shouldn't do without setting maxLength . Most printers will indicate truncated lists with ... at the end. maxDepth number The maximum number of levels deep that will get printed. Different printers mark a stop different ways. puget doesn't support it at all. See Customizing Calva for some tips on adding settings like these. Here's an example of how zprint handles maxDepth (from the Calva implementation of it's client side pretty printing.). ( pretty-print [[[[[[[[ :deeper ]]]]]]]] { :max-depth 4 }) ;; => {:value \"[[[[##]]]]\"}","title":"Configuration"},{"location":"pprint/#your-selection-of-prettifiers","text":"Pretty printing can happen on the server (i.e. in the JVM, via nREPL), or on the client (i.e. in node, via VS Code/Calva). Client side always uses zprint . Server side you can choose from these printers: Print Engine Client or Server Side Comments calva client The nREPL server will plain print the results, and then Calva will pretty it. pprint server Current Calva default ( clojure.core/pprint is a bit basic, but it's tried and tested, and has none of the server side printing issues mentioned below. fipp server puget server Lacks maxDepth option. zprint server Recommended. Will need to be configured before Jack-in if you want Calva's help to inject its dependencies These particular server side functions were chosen because they have pre-configured print-functions in cider-nrepl .","title":"Your Selection of Prettifiers"},{"location":"pprint/#why-does-server-or-client-side-matter","text":"This matters because on the server all pretty printers, except pprint does more than just pretty print the result that would be printed with plain printing. Pretty printing results on the server causes some results to get expanded. This can have huge implications depending on the results and which printer is used. E.g. for Datomic transaction results, you will get the whole database printed. Twice. Depending on the database, you could be so unlucky that nothing gets printed, and instead you will soon have a very hot computer. Note: With the help of zprint creator, Kim Kinnear , we have found ways to compensate for this problem. Ways that are not yet implemented, but please stay tuned. Then why not always do it client side? It turns out that on the client side there are also things going on. Calva gets the results back as a string and therefore it needs to first be parsed back to EDN , before it can be pretty printed by zprint . And \u2013 here's the catch \u2013 all results are not valid EDN and therefore can't be pretty printed by zprint . Datomic transaction results are one example.","title":"Why does Server or Client Side Matter?"},{"location":"pprint/#need-more-configurability","text":"The current options are limited, because our time developing Calva is limited. But cider-nrepl really allows for fully configurable pretty printing, so it is within reach. Please feel invited to give us feedback on what you would want to configure for the printing of results. File issues and/or chat us up in #calva in the Clojurians slack.","title":"Need More Configurability?"},{"location":"pprint/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"pprint/#pprint-is-not-working","text":"If pprint is not working, try a different pprint engine or use Calva's jack-in to make sure the necessary dependencies are loaded in your REPL. If you are starting your REPL without jack-in and want to continue doing so, you can use the command Copy Jack-in Command to Clipboard then paste the command somewhere to see what dependencies it injects. You can then add these dependencies to your REPL in whatever way suits your needs. Enjoy Prettiful Printing! \u2764\ufe0f","title":"pprint is not working"},{"location":"quirks/","text":"Quirks Here's a shocker for ya': Calva isn't perfect. \ud83d\ude04 There are quirks and things that flat out do not work. We'll try to collect info about such things here, providing workarounds when available (or, rather, known to us). Test features not available with ClojureScript Currently cider-nrepl does not provide its test functionality for ClojureScript code. Please consider contributing to fixing that. Using with Parinfer See Using with Parinfer Calva and the VIM Extension See Using Calva with the VIM Extension . \u201dCommand not found\u201d Errors on Jack-in Jack-in starts by running a command in a new terminal. You will need the commands used installed on your computer: clojure for tools.deps/deps.edn lein for Leiningen npx for shadow-cljs Also, in some circumstances VS Code is not spawned from a shell with the environment variables, especially $PATH , which might mean that even though you have the tools installed, they are not found when VS Code/Calva tries to execute them. To fix this you will need to do one of these two things: Figure out from where VS Code is spawned, and make sure the $PATH there includes the directoy with the needed binary. Start VS Code from a terminal where the $PATH is correctly configured. (Using the code commmand.) See this issue for more clues on this problem. Strange linting errors? This is not really a quirk, and most linting errors are not strange when you learn about why they are there. Calva does not do any linting, btw, see also linting .","title":"Quirks"},{"location":"quirks/#quirks","text":"Here's a shocker for ya': Calva isn't perfect. \ud83d\ude04 There are quirks and things that flat out do not work. We'll try to collect info about such things here, providing workarounds when available (or, rather, known to us).","title":"Quirks"},{"location":"quirks/#test-features-not-available-with-clojurescript","text":"Currently cider-nrepl does not provide its test functionality for ClojureScript code. Please consider contributing to fixing that.","title":"Test features not available with ClojureScript"},{"location":"quirks/#using-with-parinfer","text":"See Using with Parinfer","title":"Using with Parinfer"},{"location":"quirks/#calva-and-the-vim-extension","text":"See Using Calva with the VIM Extension .","title":"Calva and the VIM Extension"},{"location":"quirks/#command-not-found-errors-on-jack-in","text":"Jack-in starts by running a command in a new terminal. You will need the commands used installed on your computer: clojure for tools.deps/deps.edn lein for Leiningen npx for shadow-cljs Also, in some circumstances VS Code is not spawned from a shell with the environment variables, especially $PATH , which might mean that even though you have the tools installed, they are not found when VS Code/Calva tries to execute them. To fix this you will need to do one of these two things: Figure out from where VS Code is spawned, and make sure the $PATH there includes the directoy with the needed binary. Start VS Code from a terminal where the $PATH is correctly configured. (Using the code commmand.) See this issue for more clues on this problem.","title":"\u201dCommand not found\u201d Errors on Jack-in"},{"location":"quirks/#strange-linting-errors","text":"This is not really a quirk, and most linting errors are not strange when you learn about why they are there. Calva does not do any linting, btw, see also linting .","title":"Strange linting errors?"},{"location":"re-frame-template/","text":"How to Use Calva With the re-frame Template To make it easy to start the app created by the re-frame template use the +calva option when creating your project. In its plainest form that becomes: $ lein new re-frame <app-name> +calva If you have a re-frame project created from the template w/o the +calva option and want to get the ease, add this Connect Sequence in the .vscode/settings.json of the project: \"calva.replConnectSequences\" : [ { \"name\" : \"Leiningen -> shadow-cljs\" , \"projectType\" : \"lein-shadow\" , \"cljsType\" : \"shadow-cljs\" , \"menuSelections\" : { \"leinAlias\" : null , \"leinProfiles\" : [ \"dev\" ], \"cljsLaunchBuilds\" : [ \"app\" ], \"cljsDefaultBuild\" : \"app\" } } ], Then Jack-In .","title":"How to Use Calva With the re-frame Template"},{"location":"re-frame-template/#how-to-use-calva-with-the-re-frame-template","text":"To make it easy to start the app created by the re-frame template use the +calva option when creating your project. In its plainest form that becomes: $ lein new re-frame <app-name> +calva If you have a re-frame project created from the template w/o the +calva option and want to get the ease, add this Connect Sequence in the .vscode/settings.json of the project: \"calva.replConnectSequences\" : [ { \"name\" : \"Leiningen -> shadow-cljs\" , \"projectType\" : \"lein-shadow\" , \"cljsType\" : \"shadow-cljs\" , \"menuSelections\" : { \"leinAlias\" : null , \"leinProfiles\" : [ \"dev\" ], \"cljsLaunchBuilds\" : [ \"app\" ], \"cljsDefaultBuild\" : \"app\" } } ], Then Jack-In .","title":"How to Use Calva With the re-frame Template"},{"location":"rebl/","text":"How to Use Calva and REBL Together REBL is a graphical, interactive tool for browsing Clojure data. deps.edn Add the following aliases to your deps.edn file. Use the deps.edn file in the ~/.clojure directory to enable alias reuse across multiple projects. This is the configuration for REBL on openjdk 12. Check out the REBL github page for more info. ;; REBL Base :rebl { :extra-deps { org.clojure/core.async { :mvn/version \"0.4.490\" } ;; deps for file datafication (0.9.149 or later) org.clojure/data.csv { :mvn/version \"0.1.4\" } org.clojure/data.json { :mvn/version \"0.2.3\" } org.yaml/snakeyaml { :mvn/version \"1.23\" } com.cognitect/rebl ;; adjust to match your install location { :local/root \"/Users/ozimos/REBL/latest/REBL.jar\" }}} ;; REBL 12 :rebl-12 { :extra-deps { org.openjfx/javafx-fxml { :mvn/version \"12.0.1\" } org.openjfx/javafx-controls { :mvn/version \"12.0.1\" } org.openjfx/javafx-graphics { :mvn/version \"12.0.1\" } org.openjfx/javafx-media { :mvn/version \"12.0.1\" } org.openjfx/javafx-swing { :mvn/version \"12.0.1\" } org.openjfx/javafx-base { :mvn/version \"12.0.1\" } org.openjfx/javafx-web { :mvn/version \"12.0.1\" }}} ;; nREBL :nrebl { :extra-deps { rickmoynihan/nrebl.middleware { :mvn/version \"0.2.0\" }} :main-opts [ \"-e\" \"((requiring-resolve,'cognitect.rebl/ui))\" \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[nrebl.middleware/wrap-nrebl]\" \"-I\" ]} Create a Calva custom connect sequence for your VSCode editor. (Read Custom REPL Connect Sequences if you haven't.) Add the following to your vscode settings.json: { \"calva.replConnectSequences\" : [ { \"name\" : \"Rebl Connect\" , \"projectType\" : \"deps.edn\" , \"menuSelections\" : { \"cljAliases\" : [ \"rebl\" , \"rebl-12\" , \"nrebl\" ] } } ] } Leiningen Add rebl profiles to your user-wide profiles so that they will be available for all your projects. Here's a sample user profile (located at ~/.lein/profiles.clj on mac): { :user { :plugins [[ lein-ancient \"0.6.15\" ]]} ;; REBL Base :rebl { :resource-paths [ \"/Users/ozimos/REBL/latest/REBL.jar\" ] :dependencies [[ org.clojure/core.async \"0.4.490\" ] [ org.clojure/data.csv \"0.1.4\" ] [ org.clojure/data.json \"0.2.3\" ] [ cljfmt \"0.6.4\" ] [ org.yaml/snakeyaml \"1.23\" ]]} ;; REBL 12 for JDK 12.0.1. Swap out for your JDK vaersion :rebl-12 { :dependencies [[ org.openjfx/javafx-fxml \"12.0.1\" ] [ org.openjfx/javafx-controls \"12.0.1\" ] [ org.openjfx/javafx-graphics \"12.0.1\" ] [ org.openjfx/javafx-media \"12.0.1\" ] [ org.openjfx/javafx-swing \"12.0.1\" ] [ org.openjfx/javafx-base \"12.0.1\" ] [ org.openjfx/javafx-web \"12.0.1\" ]]} ;; NREBL https://github.com/RickMoynihan/nrebl.middleware :nrebl { :repl-options { :nrepl-middleware [ nrebl.middleware/wrap-nrebl ]} :dependencies [[ rickmoynihan/nrebl.middleware \"0.3.1\" ]]}} More info here Create a Calva custom connect sequence for your VSCode editor. (Read Custom REPL Connect Sequences if you haven't.) Add the following to your vscode settings.json: { \"calva.replConnectSequences\" : [ { \"name\" : \"Lein REBL\" , \"projectType\" : \"Leiningen\" , \"menuSelections\" : { \"leinProfiles\" : [ \"rebl\" , \"rebl-12\" , \":nrebl\" ] }, \"afterCLJReplJackInCode\" : \"((requiring-resolve 'cognitect.rebl/ui))\" } ] } shadow-cljs (TBD) TBD. If you know how to do it, please update this page.","title":"How to Use Calva and REBL Together"},{"location":"rebl/#how-to-use-calva-and-rebl-together","text":"REBL is a graphical, interactive tool for browsing Clojure data.","title":"How to Use Calva and REBL Together"},{"location":"rebl/#depsedn","text":"Add the following aliases to your deps.edn file. Use the deps.edn file in the ~/.clojure directory to enable alias reuse across multiple projects. This is the configuration for REBL on openjdk 12. Check out the REBL github page for more info. ;; REBL Base :rebl { :extra-deps { org.clojure/core.async { :mvn/version \"0.4.490\" } ;; deps for file datafication (0.9.149 or later) org.clojure/data.csv { :mvn/version \"0.1.4\" } org.clojure/data.json { :mvn/version \"0.2.3\" } org.yaml/snakeyaml { :mvn/version \"1.23\" } com.cognitect/rebl ;; adjust to match your install location { :local/root \"/Users/ozimos/REBL/latest/REBL.jar\" }}} ;; REBL 12 :rebl-12 { :extra-deps { org.openjfx/javafx-fxml { :mvn/version \"12.0.1\" } org.openjfx/javafx-controls { :mvn/version \"12.0.1\" } org.openjfx/javafx-graphics { :mvn/version \"12.0.1\" } org.openjfx/javafx-media { :mvn/version \"12.0.1\" } org.openjfx/javafx-swing { :mvn/version \"12.0.1\" } org.openjfx/javafx-base { :mvn/version \"12.0.1\" } org.openjfx/javafx-web { :mvn/version \"12.0.1\" }}} ;; nREBL :nrebl { :extra-deps { rickmoynihan/nrebl.middleware { :mvn/version \"0.2.0\" }} :main-opts [ \"-e\" \"((requiring-resolve,'cognitect.rebl/ui))\" \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[nrebl.middleware/wrap-nrebl]\" \"-I\" ]} Create a Calva custom connect sequence for your VSCode editor. (Read Custom REPL Connect Sequences if you haven't.) Add the following to your vscode settings.json: { \"calva.replConnectSequences\" : [ { \"name\" : \"Rebl Connect\" , \"projectType\" : \"deps.edn\" , \"menuSelections\" : { \"cljAliases\" : [ \"rebl\" , \"rebl-12\" , \"nrebl\" ] } } ] }","title":"deps.edn"},{"location":"rebl/#leiningen","text":"Add rebl profiles to your user-wide profiles so that they will be available for all your projects. Here's a sample user profile (located at ~/.lein/profiles.clj on mac): { :user { :plugins [[ lein-ancient \"0.6.15\" ]]} ;; REBL Base :rebl { :resource-paths [ \"/Users/ozimos/REBL/latest/REBL.jar\" ] :dependencies [[ org.clojure/core.async \"0.4.490\" ] [ org.clojure/data.csv \"0.1.4\" ] [ org.clojure/data.json \"0.2.3\" ] [ cljfmt \"0.6.4\" ] [ org.yaml/snakeyaml \"1.23\" ]]} ;; REBL 12 for JDK 12.0.1. Swap out for your JDK vaersion :rebl-12 { :dependencies [[ org.openjfx/javafx-fxml \"12.0.1\" ] [ org.openjfx/javafx-controls \"12.0.1\" ] [ org.openjfx/javafx-graphics \"12.0.1\" ] [ org.openjfx/javafx-media \"12.0.1\" ] [ org.openjfx/javafx-swing \"12.0.1\" ] [ org.openjfx/javafx-base \"12.0.1\" ] [ org.openjfx/javafx-web \"12.0.1\" ]]} ;; NREBL https://github.com/RickMoynihan/nrebl.middleware :nrebl { :repl-options { :nrepl-middleware [ nrebl.middleware/wrap-nrebl ]} :dependencies [[ rickmoynihan/nrebl.middleware \"0.3.1\" ]]}} More info here Create a Calva custom connect sequence for your VSCode editor. (Read Custom REPL Connect Sequences if you haven't.) Add the following to your vscode settings.json: { \"calva.replConnectSequences\" : [ { \"name\" : \"Lein REBL\" , \"projectType\" : \"Leiningen\" , \"menuSelections\" : { \"leinProfiles\" : [ \"rebl\" , \"rebl-12\" , \":nrebl\" ] }, \"afterCLJReplJackInCode\" : \"((requiring-resolve 'cognitect.rebl/ui))\" } ] }","title":"Leiningen"},{"location":"rebl/#shadow-cljs-tbd","text":"TBD. If you know how to do it, please update this page.","title":"shadow-cljs (TBD)"},{"location":"refactoring/","text":"Refactoring There are two \u201dflavours\u201d to refactoring support. Some (just a few) refactorings are made available as Quick Fix suggestions (the light bulb), the rest are regular commands in the Calva Refactoring category. You can enable or disable the Quick Fix suggestion lightbulb using the VS Code setting editor.lightbulb.enabled . The refactoring commands do not have default keyboard shortcuts. You find them all by typing \u201dCalva Refactor\u201d in the Command Palette. Commands Command Title Command Key Description Clean NS Form calva.refactor.cleanNs Add Missing Require calva.refactor.addMissingLibspec Extract to New Function calva.refactor.extractFunction Cycle/Toggle Privacy calva.refactor.cyclePrivacy Inline Symbol calva.refactor.inlineSymbol Introduce let calva.refactor.introduceLet Creates a new let box with the binding. Follow up with \u201dExpand let\u201d to move it upwards. Expand Let calva.refactor.expandLet Move to Previous let Box calva.refactor.moveToLet Thread First calva.refactor.threadFirst Thread First All calva.refactor.threadFirstAll Thread Last calva.refactor.threadLast Thread Last All calva.refactor.threadLastAll Unwind All calva.refactor.unwindAll Unwind Thread calva.refactor.unwindThread Formatting The way that some of the refactorings are applied to the document, makes it difficult for Calva to format the results. So, sometimes you'll need to navigate the cursor to the enclosing form and hit tab to tidy up the formatting after a refactoring. See also Formatting . Thanks to clojure-lsp Most of Calva's refactoring support is sourced directly from clojure-lsp . This also means that most often, if you find issues with refactoring, or have suggestions about it, the clojure-lsp repo is where to direct your reporting.","title":"Refactoring"},{"location":"refactoring/#refactoring","text":"There are two \u201dflavours\u201d to refactoring support. Some (just a few) refactorings are made available as Quick Fix suggestions (the light bulb), the rest are regular commands in the Calva Refactoring category. You can enable or disable the Quick Fix suggestion lightbulb using the VS Code setting editor.lightbulb.enabled . The refactoring commands do not have default keyboard shortcuts. You find them all by typing \u201dCalva Refactor\u201d in the Command Palette.","title":"Refactoring"},{"location":"refactoring/#commands","text":"Command Title Command Key Description Clean NS Form calva.refactor.cleanNs Add Missing Require calva.refactor.addMissingLibspec Extract to New Function calva.refactor.extractFunction Cycle/Toggle Privacy calva.refactor.cyclePrivacy Inline Symbol calva.refactor.inlineSymbol Introduce let calva.refactor.introduceLet Creates a new let box with the binding. Follow up with \u201dExpand let\u201d to move it upwards. Expand Let calva.refactor.expandLet Move to Previous let Box calva.refactor.moveToLet Thread First calva.refactor.threadFirst Thread First All calva.refactor.threadFirstAll Thread Last calva.refactor.threadLast Thread Last All calva.refactor.threadLastAll Unwind All calva.refactor.unwindAll Unwind Thread calva.refactor.unwindThread Formatting The way that some of the refactorings are applied to the document, makes it difficult for Calva to format the results. So, sometimes you'll need to navigate the cursor to the enclosing form and hit tab to tidy up the formatting after a refactoring. See also Formatting .","title":"Commands"},{"location":"refactoring/#thanks-to-clojure-lsp","text":"Most of Calva's refactoring support is sourced directly from clojure-lsp . This also means that most often, if you find issues with refactoring, or have suggestions about it, the clojure-lsp repo is where to direct your reporting.","title":"Thanks to clojure-lsp"},{"location":"remote-development/","text":"Using Calva with Remote Development VS Code Remote Development is a new feature in version 1.35 of VS Code that allows a developer to use a container, remote machine, or the Windows Subsystem for Linux (WSL) as a full-featured development environment. I would recommend reading the introductory blog post and watching the videos. I find the feature extremely exciting and wish more IDEs would implement something like it. From a Clojure perspective it allows you to have VS Code installed on your Java-less, Clojure-less hardware and still use it to develop Clojure through it. A use-case For some reason your physical computer has to be running Windows (organizational rules etc.) Your deployment environment is Linux You want to edit files in an editor running on your physical computer Most Clojure tooling is made with *nix first in mind and there are incompatibilities with Windows WSL See Using Calva with WSL","title":"Using Calva with Remote Development"},{"location":"remote-development/#using-calva-with-remote-development","text":"VS Code Remote Development is a new feature in version 1.35 of VS Code that allows a developer to use a container, remote machine, or the Windows Subsystem for Linux (WSL) as a full-featured development environment. I would recommend reading the introductory blog post and watching the videos. I find the feature extremely exciting and wish more IDEs would implement something like it. From a Clojure perspective it allows you to have VS Code installed on your Java-less, Clojure-less hardware and still use it to develop Clojure through it.","title":"Using Calva with Remote Development"},{"location":"remote-development/#a-use-case","text":"For some reason your physical computer has to be running Windows (organizational rules etc.) Your deployment environment is Linux You want to edit files in an editor running on your physical computer Most Clojure tooling is made with *nix first in mind and there are incompatibilities with Windows","title":"A use-case"},{"location":"remote-development/#wsl","text":"See Using Calva with WSL","title":"WSL"},{"location":"reveal/","text":"How to use Calva and Reveal together Reveal is a \"Read Eval Visualize Loop for Clojure\". This page describes how to use Reveal in your development setup based on Calva. When using tools.deps You can go for the nrepl middleware or just add the dependency. Use Reveal nrepl middleware This will make Reveal to start together with your project. Note This will make all Calva evaluations go to Reveal. Too chatty for you? Take the dependencies only approach. Add this alias deps.edn : :aliases { :reveal-nrepl-middleware { :extra-deps { vlaaad/reveal { :mvn/version \"1.3.194\" }} :main-opts [ \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,cider.nrepl/cider-middleware]\" ]}} And then jack-in choosing the deps.edn option and then pick the :reveal-nrepl-middleware alias. Dependencies only If you don't want to use the nrepl-middleware you can configure just the dependency and then start Reveal yourself. The alias: :reveal-dep-only { :extra-deps { vlaaad/reveal { :mvn/version \"1.3.194\" }}} A custom REPL command for starting Reveal in your project: \"calva.customREPLCommandSnippets\" : [ ... { \"name\" : \"Start Reveal Tapper\" , \"snippet\" : \"(require '[vlaaad.reveal :as reveal])(add-tap (reveal/ui))\" , \"key\" : \"sr\" }, ... ] See Custom REPL Command for how to configure more commands, and bind shortcuts to them, to make Reveal integration nice for you. When using Leiningen In your project.clj , add a profile named \"reveal\": :profiles { :reveal { :dependencies [[ vlaaad/reveal \"1.3.194\" ]] :repl-options { :nrepl-middleware [ vlaaad.reveal.nrepl/middleware ]}}} Now when you jack-in using Calva, you enable this profile and Reveal will be started automatically. Please note that Reveal requires Java 8 or higher, and uses JavaFX. Depending on your setup, you may need to make sure it is available. Tips about font size If you find the font to small you can add a :jvm-opts key to make it a little bigger: :aliases { :reveal { :extra-deps { vlaaad/reveal { :mvn/version \"1.3.194\" }} :jvm-opts [ \"-Dvlaaad.reveal.prefs={:font-size,17}\" ] :main-opts [ \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,cider.nrepl/cider-middleware]\" ]}}","title":"How to use Calva and Reveal together"},{"location":"reveal/#how-to-use-calva-and-reveal-together","text":"Reveal is a \"Read Eval Visualize Loop for Clojure\". This page describes how to use Reveal in your development setup based on Calva.","title":"How to use Calva and Reveal together"},{"location":"reveal/#when-using-toolsdeps","text":"You can go for the nrepl middleware or just add the dependency.","title":"When using tools.deps"},{"location":"reveal/#use-reveal-nrepl-middleware","text":"This will make Reveal to start together with your project. Note This will make all Calva evaluations go to Reveal. Too chatty for you? Take the dependencies only approach. Add this alias deps.edn : :aliases { :reveal-nrepl-middleware { :extra-deps { vlaaad/reveal { :mvn/version \"1.3.194\" }} :main-opts [ \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,cider.nrepl/cider-middleware]\" ]}} And then jack-in choosing the deps.edn option and then pick the :reveal-nrepl-middleware alias.","title":"Use Reveal nrepl middleware"},{"location":"reveal/#dependencies-only","text":"If you don't want to use the nrepl-middleware you can configure just the dependency and then start Reveal yourself. The alias: :reveal-dep-only { :extra-deps { vlaaad/reveal { :mvn/version \"1.3.194\" }}} A custom REPL command for starting Reveal in your project: \"calva.customREPLCommandSnippets\" : [ ... { \"name\" : \"Start Reveal Tapper\" , \"snippet\" : \"(require '[vlaaad.reveal :as reveal])(add-tap (reveal/ui))\" , \"key\" : \"sr\" }, ... ] See Custom REPL Command for how to configure more commands, and bind shortcuts to them, to make Reveal integration nice for you.","title":"Dependencies only"},{"location":"reveal/#when-using-leiningen","text":"In your project.clj , add a profile named \"reveal\": :profiles { :reveal { :dependencies [[ vlaaad/reveal \"1.3.194\" ]] :repl-options { :nrepl-middleware [ vlaaad.reveal.nrepl/middleware ]}}} Now when you jack-in using Calva, you enable this profile and Reveal will be started automatically. Please note that Reveal requires Java 8 or higher, and uses JavaFX. Depending on your setup, you may need to make sure it is available.","title":"When using Leiningen"},{"location":"reveal/#tips-about-font-size","text":"If you find the font to small you can add a :jvm-opts key to make it a little bigger: :aliases { :reveal { :extra-deps { vlaaad/reveal { :mvn/version \"1.3.194\" }} :jvm-opts [ \"-Dvlaaad.reveal.prefs={:font-size,17}\" ] :main-opts [ \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,cider.nrepl/cider-middleware]\" ]}}","title":"Tips about font size"},{"location":"rich-comments/","text":"Rich Comments Support Why bother with Rich comments ? Read on. Consider watching this Youtube video for a demo of the workflow using the (in?)famous FizzBuzz problem as an example. Things in comment are not evaluated The Clojure comment macro is defined like so: ( defmacro comment \"Ignores body, yields nil\" { :added \"1.0\" } [ & body ]) It has no forms in its body and will therefore always (as long as the Clojure Reader can read it) evaluate to nil . That is: nothing in the (comment ...) form will get evaluated when the file is loaded . This makes it a very good \u201dplace\u201d where you can develop code, experiment with code, and keep example code. Since you will be able to load/evaluate the current file without worrying that the code in the comment form will get evaluated. This also holds true when using tools that hot-reload the code on save, such as Figwheel , shadow-cljs and Krell . To develop or refine a function you might: Open up a (comment ...) form Inside this form, type a first, super simple, version (or refinement) of your function and evaluate it Inside the same comment form, type some code to test your function and evaluate that Or type and evaluate some code you might need for your function Repeat from 2. , until the function does what you want it to do Move the function definition out of the comment form Clean up the comment form to keep some of the test code as example use, or \u201ddesign decision log\u201d for the function. Note Using (comment ...) forms for developing code is very common among Clojure coders. Rich Hickey is known for using it, which is why they are called Rich comments to begin with (even if it also is a very rich experience). Calva encourages Rich comments Calva has several features to facilitate the Rich comments workflow, e.g. Special Syntax highlight . By default comment forms are rendered in italics Special top-level form context Special formatting comment is top-level To make it easy to evaluate forms in (comment ...) forms, they create a new top-level context. Instead of you having to place the cursor with precision before evaluating the current form , you can have the cursor anywhere within a comment enclosed form and Evaluate Top-Level Form . This carries over to all commands in Calva which deal with the top level form. Including custom command snippets . Special formatting To invite a Rich comments workflow, the Calva command Format Current Form will not fold the closing bracket of the (comment ...) form. Instead it will place this bracket on a line of its own (or keep it there). ( comment ) With the cursor somewhere directly inside the comment form (denoted with a | ): ( comment ( def foo :foo ) | ) tab ( comment ( def foo :foo ) | ) Thinking space is kept The formatter will not remove newlines between the cursor and the closing bracket. So if you have entered a few lines to get \u201dthinking\u201d room: ( comment ( def foo :foo ) | ) tab ( comment ( def foo :foo ) | ) Fold when done To fold the trailing paren automatically, place the cursor immediately outside (before or after) the form: ( comment ( def foo :foo )) | tab ( comment ( def foo :foo )) | Enabled by default You can disable this behavior with the setting: calva.fmt.keepCommentTrailParenOnOwnLine . But why would you? It is awesome! \ud83d\ude04 Only for the Current Form Note This treatment only applies to formatting of the current form . With fold when done as an exception.","title":"Rich Comments Support"},{"location":"rich-comments/#rich-comments-support","text":"Why bother with Rich comments ? Read on. Consider watching this Youtube video for a demo of the workflow using the (in?)famous FizzBuzz problem as an example.","title":"Rich Comments Support"},{"location":"rich-comments/#things-in-comment-are-not-evaluated","text":"The Clojure comment macro is defined like so: ( defmacro comment \"Ignores body, yields nil\" { :added \"1.0\" } [ & body ]) It has no forms in its body and will therefore always (as long as the Clojure Reader can read it) evaluate to nil . That is: nothing in the (comment ...) form will get evaluated when the file is loaded . This makes it a very good \u201dplace\u201d where you can develop code, experiment with code, and keep example code. Since you will be able to load/evaluate the current file without worrying that the code in the comment form will get evaluated. This also holds true when using tools that hot-reload the code on save, such as Figwheel , shadow-cljs and Krell . To develop or refine a function you might: Open up a (comment ...) form Inside this form, type a first, super simple, version (or refinement) of your function and evaluate it Inside the same comment form, type some code to test your function and evaluate that Or type and evaluate some code you might need for your function Repeat from 2. , until the function does what you want it to do Move the function definition out of the comment form Clean up the comment form to keep some of the test code as example use, or \u201ddesign decision log\u201d for the function. Note Using (comment ...) forms for developing code is very common among Clojure coders. Rich Hickey is known for using it, which is why they are called Rich comments to begin with (even if it also is a very rich experience).","title":"Things in comment are not evaluated"},{"location":"rich-comments/#calva-encourages-rich-comments","text":"Calva has several features to facilitate the Rich comments workflow, e.g. Special Syntax highlight . By default comment forms are rendered in italics Special top-level form context Special formatting","title":"Calva encourages Rich comments"},{"location":"rich-comments/#comment-is-top-level","text":"To make it easy to evaluate forms in (comment ...) forms, they create a new top-level context. Instead of you having to place the cursor with precision before evaluating the current form , you can have the cursor anywhere within a comment enclosed form and Evaluate Top-Level Form . This carries over to all commands in Calva which deal with the top level form. Including custom command snippets .","title":"comment is top-level"},{"location":"rich-comments/#special-formatting","text":"To invite a Rich comments workflow, the Calva command Format Current Form will not fold the closing bracket of the (comment ...) form. Instead it will place this bracket on a line of its own (or keep it there). ( comment ) With the cursor somewhere directly inside the comment form (denoted with a | ): ( comment ( def foo :foo ) | ) tab ( comment ( def foo :foo ) | )","title":"Special formatting"},{"location":"rich-comments/#thinking-space-is-kept","text":"The formatter will not remove newlines between the cursor and the closing bracket. So if you have entered a few lines to get \u201dthinking\u201d room: ( comment ( def foo :foo ) | ) tab ( comment ( def foo :foo ) | )","title":"Thinking space is kept"},{"location":"rich-comments/#fold-when-done","text":"To fold the trailing paren automatically, place the cursor immediately outside (before or after) the form: ( comment ( def foo :foo )) | tab ( comment ( def foo :foo )) |","title":"Fold when done"},{"location":"rich-comments/#enabled-by-default","text":"You can disable this behavior with the setting: calva.fmt.keepCommentTrailParenOnOwnLine . But why would you? It is awesome! \ud83d\ude04","title":"Enabled by default"},{"location":"rich-comments/#only-for-the-current-form","text":"Note This treatment only applies to formatting of the current form . With fold when done as an exception.","title":"Only for the Current Form"},{"location":"sponsors/","text":"Calva Sponsors Calva is open source and free to use. It is actively maintained during our free time, and it keeps improving. You can contribute in many different ways, one of which is sponsoring. These are our sponsor profiles: Peter Str\u00f6mberg Brandon Ringe There you can see who are sponsoring Calva, and this is also displayed in the README of the Calva project (which means it is also displayed in the VS Code Extension Marketlace ). If you are working at a company which benefits from Calva's existence and continued development, please consider sponsoring at the Calva Gold Sponsor tier. Please see this statement from Cognitect about the importance of supporting open source developers. Patrons The right kind of different Gold Sponsors Scale your growth on mobile MAKE. DO. SHIP. Silver Sponsors","title":"Calva Sponsors"},{"location":"sponsors/#calva-sponsors","text":"Calva is open source and free to use. It is actively maintained during our free time, and it keeps improving. You can contribute in many different ways, one of which is sponsoring. These are our sponsor profiles: Peter Str\u00f6mberg Brandon Ringe There you can see who are sponsoring Calva, and this is also displayed in the README of the Calva project (which means it is also displayed in the VS Code Extension Marketlace ). If you are working at a company which benefits from Calva's existence and continued development, please consider sponsoring at the Calva Gold Sponsor tier. Please see this statement from Cognitect about the importance of supporting open source developers.","title":"Calva Sponsors"},{"location":"sponsors/#patrons","text":"The right kind of different","title":"Patrons"},{"location":"sponsors/#gold-sponsors","text":"Scale your growth on mobile MAKE. DO. SHIP.","title":"Gold Sponsors"},{"location":"sponsors/#silver-sponsors","text":"","title":"Silver Sponsors"},{"location":"static-only/","text":"Use Calva w/o the REPL Why would anyone want to use a Clojure editor without a REPL? It could be because you prefer some other REPL client over Calva's ditto , like Clover , but would be lacking Calva's clojure-lsp support, formatter , Paredit , highlighter , etcetera. As it could be a bit confusing and cluttered to have several REPL UIs active at the same time, Calva supports this use with a setting to disable most of its REPL UI elements, like statusbar items, command palette entries and editor context menus. Set calva.hideReplUi to true and the only commands still visible should be those for Connect and Jack-in. If you have the Calva REPL UI disabled and still want to connect or jack-in to a REPL using Calva , just do it. Then Calva's REPL UI will wake up and be there for the duration of the session. Consider uninstalling these extensions Without Calva, many users install other nifty extensions (some of which are old pieces of Calva) that help with this or that problem. It might sometimes work together with Calva, sometimes not. Here's a list of some common extensions you should consider to at least disable: Strict Paredit - Calva Paredit has evolved a lot since that version Calva-fmt/Calva Formatter - Same here, evolution Clojure Warrior - Calva includes it, in a much evolved way Parinfer - This one you can actually keep, at some cost , see Using Calva with Parinfer . There's only one Calva REPL, though Of course we encourage you to use Calva's REPL. It gives you easy ways to start a Clojure REPL connect to an running REPL super duper nice debugger test runner custom REPL commands enhanced symbol lookup and code navigation (keep navigating into library and Clojure core code, as well as into Java code). easy to use output with pretty printing , on-demand stack traces , and that awesome debugger.md Happy REPLing, whichever REPL client you choose. \u2764\ufe0f","title":"Use Calva w/o the REPL"},{"location":"static-only/#use-calva-wo-the-repl","text":"Why would anyone want to use a Clojure editor without a REPL? It could be because you prefer some other REPL client over Calva's ditto , like Clover , but would be lacking Calva's clojure-lsp support, formatter , Paredit , highlighter , etcetera. As it could be a bit confusing and cluttered to have several REPL UIs active at the same time, Calva supports this use with a setting to disable most of its REPL UI elements, like statusbar items, command palette entries and editor context menus. Set calva.hideReplUi to true and the only commands still visible should be those for Connect and Jack-in. If you have the Calva REPL UI disabled and still want to connect or jack-in to a REPL using Calva , just do it. Then Calva's REPL UI will wake up and be there for the duration of the session.","title":"Use Calva w/o the REPL"},{"location":"static-only/#consider-uninstalling-these-extensions","text":"Without Calva, many users install other nifty extensions (some of which are old pieces of Calva) that help with this or that problem. It might sometimes work together with Calva, sometimes not. Here's a list of some common extensions you should consider to at least disable: Strict Paredit - Calva Paredit has evolved a lot since that version Calva-fmt/Calva Formatter - Same here, evolution Clojure Warrior - Calva includes it, in a much evolved way Parinfer - This one you can actually keep, at some cost , see Using Calva with Parinfer .","title":"Consider uninstalling these extensions"},{"location":"static-only/#theres-only-one-calva-repl-though","text":"Of course we encourage you to use Calva's REPL. It gives you easy ways to start a Clojure REPL connect to an running REPL super duper nice debugger test runner custom REPL commands enhanced symbol lookup and code navigation (keep navigating into library and Clojure core code, as well as into Java code). easy to use output with pretty printing , on-demand stack traces , and that awesome debugger.md Happy REPLing, whichever REPL client you choose. \u2764\ufe0f","title":"There's only one Calva REPL, though"},{"location":"tao/","text":"The Tao of Calva Calva , the spirit, gains much of its taste and color from the Cider it is distilled from, and the oak it is matured in. I started to wonder what it is that shapes Calva, the VS Code Clojure Extension. I should know, being the master distiller, right?. Indeed. Poking some at the question, I do find that I have some answers. Please read the following to learn what Calva is, and, to some extent, is not, about. Read it to get an idea about which path Calva is following, where we are headed with the project, and how you can contribute to the journey. Why Calva? Calva's raison d\u00b4\u00eatre is to provide Visual Studio Code users with an easy to use and productive environment for Clojure and ClojureScript development. See the Why Calva? page for some evidence that we are succeeding. While Calva draws a lot of inspiration from CIDER , Cursive , Fireplace , and other Clojure development environments, it does not try to compete with them. Reading r/Clojure and elsewhere, it is easy to get the impression that the most common question is \"Which editor should I use for Clojure development?\u201d . I think a much more common question is \u201dHow do I use my favorite editor for Clojure development?\u201d . For VS Code users, that is where Calva should be a good choice. I also have an ambition to leverage VS Code for easing the path to Clojure. Given that it is the favorite editor for so many developers, it is important to have a good development environment in place on this platform, and to make it as easy to use as we possibly can, while also being productive and something that you want to stick with, once you are hooked on Clojure. That said, and therefore: For people who want to start out with Clojure, and do ask about what development environment would make it the most enjoyable, I'd like for Calva to be a really good option, an option so good that Clojurians feel they can recommend it. Design Goals Calva should be easy to start with and productive enough to stick with. It should support Clojure Best Practices , and be pleasant and enjoyable to use. It should also be easy to hack on, and to contribute to. The ClojureScript story keeps getting more important. Calva should contribute to making the development experience with ClojureScript delightful. Easy to Start With There are reasons as to why VS Code is so popular. Among those, one stands out to me: It is the most approachable code editor out there. There is nothing you need to learn when you start using it. The editor makes it obvious that you can start typing, deleting, cutting, pasting and undoing, without having to figure anything out. Then you learn how to bring up the command palette and get a boost few other environments can provide with such immediacy. A language extension for VS Code can leverage this, by recognizing that what's old is old, and that what's new should be as easy as possible to pick up. Coming to a new language, people bring with them a lot of expectations from the languages they are used to. This is also true for the editor support. Syntax highlighting and formatting should just work, as should documentation lookup, linting and other IDE commodities. Clojure brings some new concepts to the table. Chief among thise: The REPL. It does take some time to grasp it. Calva needs to remove any obstacles it can when it comes to helping the user to reach the REPL, in order to help getting it, and start loving it. To help the users to quickly focus on Clojure, we provide a package that is all-inclusive, with few knobs to turn, and with sane defaults for the knobs that still need to be there. Productive Enough to Stick With I think VS Code brings inspiration also when it comes to following up its excellent Getting Started story. You do not have to dig very deep under its surface to find that there is a lot more power to be unleashed. VS Code makes it easy to pick up more features as you get ready for it, and each little piece makes you more productive. To me, only Vim beats VS Code in this game. Most often there should be no contradiction between Easy to Start With and Productive . Quite the contrary. This story is mainly about being feature complete with the most important tools. As beginners start to pick up the first few features, they should be rewarded with finding more productive tools when they go looking for them. The VS Code way is Calva's way. Pleasant and Enjoyable Enjoyable starts with that Calva shouldn't be an experience full of pains. I think Calva is living up to this first bar of enjoyability. The next step is making it delightful! Calva has two main assets it can leverage for being delightful to use: Clojure and VS Code : Clojure is plain wonderful and also has this totally awesome REPL thing. Wherever we can, Calva should use the REPL to make the editor spark and bring joy to the developer. VS Code is a sweet development environment , offering its power in a consistent way across languages. Even if Clojure is very special, most of Calva's features are surfaced in the ways that VS Code encourages. It makes for less to learn for the user, and most often also makes it easier to implement functionality. Support Clojure Best Practices Mainly, I think Stuart Halloway is right about the REPL being best used from inside the files you are editing rather than from the prompt. It doesn't mean that Calva's REPL window should be neglected, but efforts should be directed such that the file editor REPL is our first way to improve the experience. Expect the Calva REPL window to get much less \u201din your face\u201d, than it is today, as the editor REPL gets stronger. Halloway also gives me some peace of mind with his reasoning of keeping a spartan setup . Calva does not need to pack every feature imaginable. If we can get the right features in place, in the right way, the mission is accomplished. Clojure is data centric. Calva should make it easy to examine data and how our code affects it. Today, this is not good enough when it comes to data structures larger than a few elements. Clojure is a LISP. Thus Structural Editing is possible, and TBH, desirable. Calva should support this and encourage it. There is little we can do about Parinfer not playing well with VS Code, but there is Paredit, and Paredit rocks! Calva's Paredit plays in the top league of Paredits, for this reason. Made from the Produce of the Orchard Calva is distilled from CIDER, which in turn is brewed from the products of The Orchard . This makes a lot of Calva's features thin wrappers around cider-nrepl and related middleware. It also should mean that we strive for adding features by thinking \u201dThe Orchard\u201d first. If it lacks what we need, we should assist in providing it there. We need to up this game a bit from where we are today, I think. Leveraging clojure-lsp Today, Calva draws a lot of its static power from clojure-lsp . As does a lot of other Clojure tooling out there. The Calva and the clojure-lsp teams work very nicely together, which is something we cherish and should take care to maintain. Project Stewardship Here Calva takes inspiration from many Clojure related projects, and perhaps most so from CIDER, shadow-cljs , and clojure-lsp. Bozhidar Batsov, Thomas Heller, and Eric Dallo all lead their projects with clarity and with gusto. You can feel how they really care about their products and their users. They are there. They listen. They respond. And they relentlessly keep improving their products. So we are there. We listen. We respond. And we keep trying to improve Calva. The Calva team cares deeply about the user experience. That is a major part of why we do this. When implementing a new feature, or changing a feature, Ux is always the first thing on our mind. Personally, to keep that direction I often start with the documentation of the feature. Reading the documentation before implementation reveals a lot about if the Ux design is within the ballpark or not. We have limited time on our hands, however, and we must cut some corners. We can't afford to spend very much time in Ux design. Rather we will use our Ux intuition, iterate the documentation quickly, and be fast to get things out. Then we are responsive in tweaking those things, based on user feedback. This also has impact on general quality at times. We only can do so much QA, and it happens that some releases of Calva cause disruptions in people's workflow because of things we haven't thought of, or not found during our testing. Again, we try to be attentive to feedback and quick to fix. Apologies in advance for any inconveniences caused! A super major part of our love for Ux is that Calva should be serving its users. That's why we treat feedback as a gift, listen intently, and use the feedback as a major ingredient in shaping Calva. Calva develops from user feedback in more direct ways as well. It is quite astonishing how many people have decided to improve on it by hacking it to do some small or big thing differently. That's great! We should make sure Calva is super easy to contribute to. There has been quite a lot of work put into improving the development process. Starting to hack on Calva is just a few steps, taking less than three minutes from cloning to running a dev version in the VS Code debugger. We encourage contributions, from the tiniest typo to whole new features. And we are ready to spend time helping people get their contributions integrated. However, Calva can't be what everyone wants it to be, that would make it useless. It needs direction and aim. And it is we, the Calva Team, who are the stewards. We need to be in charge of what Calva is about, and what it is not about. The Road Ahead Tying back to Stuart Halloway, I don't think he means that spartan needs to also mean poor. The products he helps to bring to the market tell another story. VS Code and Clojure brought together has the capacity to create something amazingly rich and luxurious. And I want Calva to tap into that potential. On the Calva journey we will allow ourselves to change our minds about how things work. Calva is not a library. Its an interface between Clojure and human beings. Human beings can adapt. And they will need to enjoy adapting in order to enjoy Calva. \ud83d\ude04 By now it should be clear that you can expect Calva to keep evolving, keep being tended and maintained, and keep getting ever more enjoyable to use. Lately we have been improving Calva pretty rapidly. It would be great to keep it up like that, but I think it is good to expect a more humble and sustainable pace. Calva is still quite new. A bit like freshly distilled Calvados. It will need time in those oak barrels to develop its full bouquet of flavors. And time is what we will give it. Our time, our creativity, and our passion.","title":"The Tao of Calva"},{"location":"tao/#the-tao-of-calva","text":"Calva , the spirit, gains much of its taste and color from the Cider it is distilled from, and the oak it is matured in. I started to wonder what it is that shapes Calva, the VS Code Clojure Extension. I should know, being the master distiller, right?. Indeed. Poking some at the question, I do find that I have some answers. Please read the following to learn what Calva is, and, to some extent, is not, about. Read it to get an idea about which path Calva is following, where we are headed with the project, and how you can contribute to the journey.","title":"The Tao of Calva"},{"location":"tao/#why-calva","text":"Calva's raison d\u00b4\u00eatre is to provide Visual Studio Code users with an easy to use and productive environment for Clojure and ClojureScript development. See the Why Calva? page for some evidence that we are succeeding. While Calva draws a lot of inspiration from CIDER , Cursive , Fireplace , and other Clojure development environments, it does not try to compete with them. Reading r/Clojure and elsewhere, it is easy to get the impression that the most common question is \"Which editor should I use for Clojure development?\u201d . I think a much more common question is \u201dHow do I use my favorite editor for Clojure development?\u201d . For VS Code users, that is where Calva should be a good choice. I also have an ambition to leverage VS Code for easing the path to Clojure. Given that it is the favorite editor for so many developers, it is important to have a good development environment in place on this platform, and to make it as easy to use as we possibly can, while also being productive and something that you want to stick with, once you are hooked on Clojure. That said, and therefore: For people who want to start out with Clojure, and do ask about what development environment would make it the most enjoyable, I'd like for Calva to be a really good option, an option so good that Clojurians feel they can recommend it.","title":"Why Calva?"},{"location":"tao/#design-goals","text":"Calva should be easy to start with and productive enough to stick with. It should support Clojure Best Practices , and be pleasant and enjoyable to use. It should also be easy to hack on, and to contribute to. The ClojureScript story keeps getting more important. Calva should contribute to making the development experience with ClojureScript delightful.","title":"Design Goals"},{"location":"tao/#easy-to-start-with","text":"There are reasons as to why VS Code is so popular. Among those, one stands out to me: It is the most approachable code editor out there. There is nothing you need to learn when you start using it. The editor makes it obvious that you can start typing, deleting, cutting, pasting and undoing, without having to figure anything out. Then you learn how to bring up the command palette and get a boost few other environments can provide with such immediacy. A language extension for VS Code can leverage this, by recognizing that what's old is old, and that what's new should be as easy as possible to pick up. Coming to a new language, people bring with them a lot of expectations from the languages they are used to. This is also true for the editor support. Syntax highlighting and formatting should just work, as should documentation lookup, linting and other IDE commodities. Clojure brings some new concepts to the table. Chief among thise: The REPL. It does take some time to grasp it. Calva needs to remove any obstacles it can when it comes to helping the user to reach the REPL, in order to help getting it, and start loving it. To help the users to quickly focus on Clojure, we provide a package that is all-inclusive, with few knobs to turn, and with sane defaults for the knobs that still need to be there.","title":"Easy to Start With"},{"location":"tao/#productive-enough-to-stick-with","text":"I think VS Code brings inspiration also when it comes to following up its excellent Getting Started story. You do not have to dig very deep under its surface to find that there is a lot more power to be unleashed. VS Code makes it easy to pick up more features as you get ready for it, and each little piece makes you more productive. To me, only Vim beats VS Code in this game. Most often there should be no contradiction between Easy to Start With and Productive . Quite the contrary. This story is mainly about being feature complete with the most important tools. As beginners start to pick up the first few features, they should be rewarded with finding more productive tools when they go looking for them. The VS Code way is Calva's way.","title":"Productive Enough to Stick With"},{"location":"tao/#pleasant-and-enjoyable","text":"Enjoyable starts with that Calva shouldn't be an experience full of pains. I think Calva is living up to this first bar of enjoyability. The next step is making it delightful! Calva has two main assets it can leverage for being delightful to use: Clojure and VS Code : Clojure is plain wonderful and also has this totally awesome REPL thing. Wherever we can, Calva should use the REPL to make the editor spark and bring joy to the developer. VS Code is a sweet development environment , offering its power in a consistent way across languages. Even if Clojure is very special, most of Calva's features are surfaced in the ways that VS Code encourages. It makes for less to learn for the user, and most often also makes it easier to implement functionality.","title":"Pleasant and Enjoyable"},{"location":"tao/#support-clojure-best-practices","text":"Mainly, I think Stuart Halloway is right about the REPL being best used from inside the files you are editing rather than from the prompt. It doesn't mean that Calva's REPL window should be neglected, but efforts should be directed such that the file editor REPL is our first way to improve the experience. Expect the Calva REPL window to get much less \u201din your face\u201d, than it is today, as the editor REPL gets stronger. Halloway also gives me some peace of mind with his reasoning of keeping a spartan setup . Calva does not need to pack every feature imaginable. If we can get the right features in place, in the right way, the mission is accomplished. Clojure is data centric. Calva should make it easy to examine data and how our code affects it. Today, this is not good enough when it comes to data structures larger than a few elements. Clojure is a LISP. Thus Structural Editing is possible, and TBH, desirable. Calva should support this and encourage it. There is little we can do about Parinfer not playing well with VS Code, but there is Paredit, and Paredit rocks! Calva's Paredit plays in the top league of Paredits, for this reason.","title":"Support Clojure Best Practices"},{"location":"tao/#made-from-the-produce-of-the-orchard","text":"Calva is distilled from CIDER, which in turn is brewed from the products of The Orchard . This makes a lot of Calva's features thin wrappers around cider-nrepl and related middleware. It also should mean that we strive for adding features by thinking \u201dThe Orchard\u201d first. If it lacks what we need, we should assist in providing it there. We need to up this game a bit from where we are today, I think.","title":"Made from the Produce of the Orchard"},{"location":"tao/#leveraging-clojure-lsp","text":"Today, Calva draws a lot of its static power from clojure-lsp . As does a lot of other Clojure tooling out there. The Calva and the clojure-lsp teams work very nicely together, which is something we cherish and should take care to maintain.","title":"Leveraging clojure-lsp"},{"location":"tao/#project-stewardship","text":"Here Calva takes inspiration from many Clojure related projects, and perhaps most so from CIDER, shadow-cljs , and clojure-lsp. Bozhidar Batsov, Thomas Heller, and Eric Dallo all lead their projects with clarity and with gusto. You can feel how they really care about their products and their users. They are there. They listen. They respond. And they relentlessly keep improving their products. So we are there. We listen. We respond. And we keep trying to improve Calva. The Calva team cares deeply about the user experience. That is a major part of why we do this. When implementing a new feature, or changing a feature, Ux is always the first thing on our mind. Personally, to keep that direction I often start with the documentation of the feature. Reading the documentation before implementation reveals a lot about if the Ux design is within the ballpark or not. We have limited time on our hands, however, and we must cut some corners. We can't afford to spend very much time in Ux design. Rather we will use our Ux intuition, iterate the documentation quickly, and be fast to get things out. Then we are responsive in tweaking those things, based on user feedback. This also has impact on general quality at times. We only can do so much QA, and it happens that some releases of Calva cause disruptions in people's workflow because of things we haven't thought of, or not found during our testing. Again, we try to be attentive to feedback and quick to fix. Apologies in advance for any inconveniences caused! A super major part of our love for Ux is that Calva should be serving its users. That's why we treat feedback as a gift, listen intently, and use the feedback as a major ingredient in shaping Calva. Calva develops from user feedback in more direct ways as well. It is quite astonishing how many people have decided to improve on it by hacking it to do some small or big thing differently. That's great! We should make sure Calva is super easy to contribute to. There has been quite a lot of work put into improving the development process. Starting to hack on Calva is just a few steps, taking less than three minutes from cloning to running a dev version in the VS Code debugger. We encourage contributions, from the tiniest typo to whole new features. And we are ready to spend time helping people get their contributions integrated. However, Calva can't be what everyone wants it to be, that would make it useless. It needs direction and aim. And it is we, the Calva Team, who are the stewards. We need to be in charge of what Calva is about, and what it is not about.","title":"Project Stewardship"},{"location":"tao/#the-road-ahead","text":"Tying back to Stuart Halloway, I don't think he means that spartan needs to also mean poor. The products he helps to bring to the market tell another story. VS Code and Clojure brought together has the capacity to create something amazingly rich and luxurious. And I want Calva to tap into that potential. On the Calva journey we will allow ourselves to change our minds about how things work. Calva is not a library. Its an interface between Clojure and human beings. Human beings can adapt. And they will need to enjoy adapting in order to enjoy Calva. \ud83d\ude04 By now it should be clear that you can expect Calva to keep evolving, keep being tended and maintained, and keep getting ever more enjoyable to use. Lately we have been improving Calva pretty rapidly. It would be great to keep it up like that, but I think it is good to expect a more humble and sustainable pace. Calva is still quite new. A bit like freshly distilled Calvados. It will need time in those oak barrels to develop its full bouquet of flavors. And time is what we will give it. Our time, our creativity, and our passion.","title":"The Road Ahead"},{"location":"test-runner/","text":"Test Runner Calva provides commands that make running your Clojure tests easier. Note Since the test commands utilize cider-nrepl, they only work with Clojure, not ClojureScript. See this issue for more details. Test Commands Command Shortcut Description Run All Tests ctrl+alt+c shift+t Runs all tests Run Failing Tests ctrl+alt+c ctrl+t Runs the tests that failed Run Tests for Current Namespace ctrl+alt+c t Runs the tests for the current namespace. If not a -test namespace, tests for the current namespace plus its corresponding <current-namespace>-test namespace will be run. Run Current Test ctrl+alt+c ctrl+alt+t Runs the test at the cursor. This includes a defn with a :test in its metadata, a defn defined in a with-test , and a deftest . Toggle between implementation and test - Switches the file between implementation and test, prompts to create a new file if not found. Test on Save You can enable the Calva setting \"Test on Save\" to have tests for the current namespace run on file save. Troubleshooting Tests Are Not Found If you have tests in a test directory separate from your source directory, and those tests are not being found by the test runner, make sure the test directory is included in your paths. This will not be the case by default with a tools.deps (deps.edn) project. If your project is a tools.deps project, you can create an alias in your deps.edn file with :extra-paths that includes \"test\" (or the name of your test directory). { :aliases { :dev { :extra-paths [ \"test\" ]}}} Having added the above to your deps.edn, when you jack-in, choose the :dev alias and the test directory will be added to your paths, which will allow tests located in the directory to be found by the test runner. Toggle between implementation and test command not working as intended This feature mostly works with projects that has leiningen style folder structure and makes some assumption about your folder structure and test file names. - It assumes that the test files ends with _test prefix. - It assumes that your implementation files are in src folder and the test files are in test folder. If you are using any non leiningen style folder structure, you may have to add source paths inside .lsp/config.edn .","title":"Test Runner"},{"location":"test-runner/#test-runner","text":"Calva provides commands that make running your Clojure tests easier. Note Since the test commands utilize cider-nrepl, they only work with Clojure, not ClojureScript. See this issue for more details.","title":"Test Runner"},{"location":"test-runner/#test-commands","text":"Command Shortcut Description Run All Tests ctrl+alt+c shift+t Runs all tests Run Failing Tests ctrl+alt+c ctrl+t Runs the tests that failed Run Tests for Current Namespace ctrl+alt+c t Runs the tests for the current namespace. If not a -test namespace, tests for the current namespace plus its corresponding <current-namespace>-test namespace will be run. Run Current Test ctrl+alt+c ctrl+alt+t Runs the test at the cursor. This includes a defn with a :test in its metadata, a defn defined in a with-test , and a deftest . Toggle between implementation and test - Switches the file between implementation and test, prompts to create a new file if not found.","title":"Test Commands"},{"location":"test-runner/#test-on-save","text":"You can enable the Calva setting \"Test on Save\" to have tests for the current namespace run on file save.","title":"Test on Save"},{"location":"test-runner/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"test-runner/#tests-are-not-found","text":"If you have tests in a test directory separate from your source directory, and those tests are not being found by the test runner, make sure the test directory is included in your paths. This will not be the case by default with a tools.deps (deps.edn) project. If your project is a tools.deps project, you can create an alias in your deps.edn file with :extra-paths that includes \"test\" (or the name of your test directory). { :aliases { :dev { :extra-paths [ \"test\" ]}}} Having added the above to your deps.edn, when you jack-in, choose the :dev alias and the test directory will be added to your paths, which will allow tests located in the directory to be found by the test runner.","title":"Tests Are Not Found"},{"location":"test-runner/#toggle-between-implementation-and-test-command-not-working-as-intended","text":"This feature mostly works with projects that has leiningen style folder structure and makes some assumption about your folder structure and test file names. - It assumes that the test files ends with _test prefix. - It assumes that your implementation files are in src folder and the test files are in test folder. If you are using any non leiningen style folder structure, you may have to add source paths inside .lsp/config.edn .","title":"Toggle between implementation and test command not working as intended"},{"location":"try-first/","text":"Something to Try First (After Connecting) You should start with loading the file you are working with. Do this with Load Current File and Dependencies , ctrl+alt+c enter . To get a feeling for evaluating code in the editor and get immediate response from the REPL try this: On a new line, type a comment form and put some code inside it: ( comment ( + ( * 2 2 ) 2 ) ( Math/abs -1 ) ( hello \"Calva REPL\" ) ( defn hello [ s ] ( str \"Hello \" s )) ( range 10 ) \"I \u2665\ufe0f Clojure\" ) Then: Place the cursor behind the form (* 2 2) and issue the command Calva: Evaluate Current Form , ctrl+enter . You should see the result being displayed inline. Press esc to dismiss it. Now issue the command Evaluate Current Top Level Form (defun) , alt+enter . You should see the whole form (+ (* 2 2) 2) getting highlighted and the result of that expression being displayed inline. Evaluate each form inside the comment form using the Top Level command. You should see each one of them evaluated. Evaluating the (hello \"Calva REPL\") form before the (defn hello... form should result in an error/exception. A stacktrace is then printed in the output window Try it again after having evaluated the defn form. Demo: How does this work? Calva has this notion about the current form . Issue the Evaluate Current Form command, with the cursor placed in different locations to get a feeling for how the current form is determined. There is also a concept about the current top level form . Good for evaluating various def s defn , defthis , defthat . With your cursor placed anywhere inside such a form. The Top Level command also works inside (comment ...) forms, treating the comment as creating a new top level context. It is good for in-file code experimentation. See also Calva Top 10 Commands . Code Evaluation Tips","title":"Something to Try First (After Connecting)"},{"location":"try-first/#something-to-try-first-after-connecting","text":"You should start with loading the file you are working with. Do this with Load Current File and Dependencies , ctrl+alt+c enter . To get a feeling for evaluating code in the editor and get immediate response from the REPL try this: On a new line, type a comment form and put some code inside it: ( comment ( + ( * 2 2 ) 2 ) ( Math/abs -1 ) ( hello \"Calva REPL\" ) ( defn hello [ s ] ( str \"Hello \" s )) ( range 10 ) \"I \u2665\ufe0f Clojure\" ) Then: Place the cursor behind the form (* 2 2) and issue the command Calva: Evaluate Current Form , ctrl+enter . You should see the result being displayed inline. Press esc to dismiss it. Now issue the command Evaluate Current Top Level Form (defun) , alt+enter . You should see the whole form (+ (* 2 2) 2) getting highlighted and the result of that expression being displayed inline. Evaluate each form inside the comment form using the Top Level command. You should see each one of them evaluated. Evaluating the (hello \"Calva REPL\") form before the (defn hello... form should result in an error/exception. A stacktrace is then printed in the output window Try it again after having evaluated the defn form. Demo:","title":"Something to Try First (After Connecting)"},{"location":"try-first/#how-does-this-work","text":"Calva has this notion about the current form . Issue the Evaluate Current Form command, with the cursor placed in different locations to get a feeling for how the current form is determined. There is also a concept about the current top level form . Good for evaluating various def s defn , defthis , defthat . With your cursor placed anywhere inside such a form. The Top Level command also works inside (comment ...) forms, treating the comment as creating a new top level context. It is good for in-file code experimentation.","title":"How does this work?"},{"location":"try-first/#see-also","text":"Calva Top 10 Commands . Code Evaluation Tips","title":"See also"},{"location":"vim/","text":"Calva and the VIM Extension First thing first. The VIM Extension and Calva has some friction between them. The alternative VSCode Neovim extension may fare a bit better as it unbinds keystrokes from VS Code while not in insert mode and uses Neovim as a backend. Selection commands Calva's various structural selection commands do not put VIM into VISUAL mode . This is true for many VS Code selection scenarios too, so it is not really Calva's fault, but it will be problematic for VIM Extension Calva users, regardless. Key bindings In general Calva's default key bindings are not very VI-ish. You can add these keybindings to your init.vim if you are using the VSCode Neovim extension. It is inspired by and tries to emulate the keybindings found in vim-fireplace which is the most popular vim plugin for Clojure. nmap cqp :call VSCodeNotify('calva.jackIn')<CR> nmap cqq :call VSCodeNotify('calva.disconnect')<CR> nmap cpr :call VSCodeNotify('calva.loadFile')<CR> nmap cpR :call VSCodeNotify('calva.loadNamespace')<CR> nmap cpp :call VSCodeNotify('calva.evaluateSelection')<CR> nmap cqc :call VSCodeNotify('calva.evalCurrentFormInREPLWindow')<CR> Unfortunately these key combinations will not work in the normal VIM extension as c is an operator key and cannot be remapped. This is a call for someone to share their VIM re-mappings . Expand selection Calva binds expand selection to ctrl+w ( shift+alt+right on Windows and Linux). This conflicts with the VIM Extension's default mapping of window splitting shortcuts. You'll need to remap it either with Calva or with the VIM Extension. The esc key Calva binds the esc key to dismiss the display of inline results. This gets into conflict with any vi coding since esc then is used to go back to command mode. You can either change Calva's default keybinding or the VIM extension's. Alternatively, you can use the native Vim command Ctrl + [ to escape and get back to command mode. Rebinding your keyboard's CapsLock key to Control may make this even easier. Remap Calva's clearInlineResults Open the Keyboard Shortcuts JSON file from the Command Palette Disable clearInlineResults and remap the command e.g. // Place your key bi n di n gs i n t his f ile t o override t he de faults [ { \"key\" : \"escape\" , \"command\" : \"-calva.clearInlineResults\" }, { \"key\" : \"shift+escape\" , \"command\" : \"calva.clearInlineResults\" , \"when\" : \"editorTextFocus && !editorHasMultipleSelections && !editorReadOnly && !hasOtherSuggestions && !suggestWidgetVisible && editorLangId == 'clojure'\" } ] If you run into issues, refer to the commands in the default Keyboard Shortcuts JSON file. Remap Vim's Insert Mode Remap vim's insert mode keybinding to go into command mode by adding the following to your user settings: \"vim.insertModeKeyBindings\" : [ { \"before\" : [ \"j\" , \"k\" ], \"after\" : [ \"<esc>\" ] } ] (Change before to whatever keybinding you are comfortable with!)","title":"Calva and the VIM Extension"},{"location":"vim/#calva-and-the-vim-extension","text":"First thing first. The VIM Extension and Calva has some friction between them. The alternative VSCode Neovim extension may fare a bit better as it unbinds keystrokes from VS Code while not in insert mode and uses Neovim as a backend.","title":"Calva and the VIM Extension"},{"location":"vim/#selection-commands","text":"Calva's various structural selection commands do not put VIM into VISUAL mode . This is true for many VS Code selection scenarios too, so it is not really Calva's fault, but it will be problematic for VIM Extension Calva users, regardless.","title":"Selection commands"},{"location":"vim/#key-bindings","text":"In general Calva's default key bindings are not very VI-ish. You can add these keybindings to your init.vim if you are using the VSCode Neovim extension. It is inspired by and tries to emulate the keybindings found in vim-fireplace which is the most popular vim plugin for Clojure. nmap cqp :call VSCodeNotify('calva.jackIn')<CR> nmap cqq :call VSCodeNotify('calva.disconnect')<CR> nmap cpr :call VSCodeNotify('calva.loadFile')<CR> nmap cpR :call VSCodeNotify('calva.loadNamespace')<CR> nmap cpp :call VSCodeNotify('calva.evaluateSelection')<CR> nmap cqc :call VSCodeNotify('calva.evalCurrentFormInREPLWindow')<CR> Unfortunately these key combinations will not work in the normal VIM extension as c is an operator key and cannot be remapped. This is a call for someone to share their VIM re-mappings .","title":"Key bindings"},{"location":"vim/#expand-selection","text":"Calva binds expand selection to ctrl+w ( shift+alt+right on Windows and Linux). This conflicts with the VIM Extension's default mapping of window splitting shortcuts. You'll need to remap it either with Calva or with the VIM Extension.","title":"Expand selection"},{"location":"vim/#the-esc-key","text":"Calva binds the esc key to dismiss the display of inline results. This gets into conflict with any vi coding since esc then is used to go back to command mode. You can either change Calva's default keybinding or the VIM extension's. Alternatively, you can use the native Vim command Ctrl + [ to escape and get back to command mode. Rebinding your keyboard's CapsLock key to Control may make this even easier.","title":"The esc key"},{"location":"vim/#remap-calvas-clearinlineresults","text":"Open the Keyboard Shortcuts JSON file from the Command Palette Disable clearInlineResults and remap the command e.g. // Place your key bi n di n gs i n t his f ile t o override t he de faults [ { \"key\" : \"escape\" , \"command\" : \"-calva.clearInlineResults\" }, { \"key\" : \"shift+escape\" , \"command\" : \"calva.clearInlineResults\" , \"when\" : \"editorTextFocus && !editorHasMultipleSelections && !editorReadOnly && !hasOtherSuggestions && !suggestWidgetVisible && editorLangId == 'clojure'\" } ] If you run into issues, refer to the commands in the default Keyboard Shortcuts JSON file.","title":"Remap Calva's clearInlineResults"},{"location":"vim/#remap-vims-insert-mode","text":"Remap vim's insert mode keybinding to go into command mode by adding the following to your user settings: \"vim.insertModeKeyBindings\" : [ { \"before\" : [ \"j\" , \"k\" ], \"after\" : [ \"<esc>\" ] } ] (Change before to whatever keybinding you are comfortable with!)","title":"Remap Vim's Insert Mode"},{"location":"why-calva/","text":"Why Calva? The main reason you would choose Calva for your Clojure and/or ClojureScript coding is that you want to use Visual Studio Code . Calva provides VS Code users with a comprehensive set of features to keep you productive and make it easy to follow Clojure coding best practices. This also means that if your choice of editor is not made yet, we think you should give VS Code and Calva a try. While Calva is a good choice for professional and experienced Clojure developers, great care has been taken in making Calva a really good choice for beginners of Clojure as well. We who make Calva are actively stewarding, maintaining, documenting and supporting it . We are also very active Clojure (and Calva) users, participating in the community. Clojure is dear to us, a lot because it keeps programming fun and rewarding. Calva has very happy users! Check out the Programming Languages section on the Visual Studio Code Marketplace, sorted by rating : Recently there was a thread over at ClojureVerse , asking about how Calva Compares to Emacs with CIDER . It is well worth reading. We would like to highlight the answer by Nick Cernis , which focuses on Calva. We'll even quote parts of it. \ud83d\ude0d Nick Cernis on ClojureVerse My advice to anyone starting their Clojure journey who is unsure about what editor to use: Pick something today and start writing Clojure. Probably pick an editor you are familiar with already. If you\u2019re not familiar with any editor yet or you don\u2019t have a strong allegiance to one, choose VS Code and Calva. Switch to something else only if you encounter persistent annoyances that you can\u2019t remove with plugins, code/config changes, help from the community, or more sleep. I now use VS Code with Calva every day but went through a long journey trying almost every other editor and plugin combo first. I switched from Emacs to VS Code, which might make my perspective different to others here. \u2026 I started with the jaded assumption that VS Code was probably bad because it's built by committee at Microsoft on a web-tech based Electron stack, only to find that it succeeds in embodying the spirit of a \u201chacker's editor\u201d more than even Emacs does in many ways: \u2026 On the benefits of Calva: Of all the amazing Clojure community projects, Calva seems most likely to encourage new users to try Clojure and ClojureScript . A lot of developers use VS Code. It\u2019s been tricky to convince frontend developer friends to try ClojureScript, but at least they don\u2019t have the excuse that they\u2019ll need to switch editors to even try it now. I think as a community we should try to support the projects that encourage Clojure\u2019s adoption and ease of use, including by using those products ourselves. Calva provides a better first-time experience than any other editor/plugin combo whether you\u2019re new to Clojure or not. You can install the plugin and be chatting with your REPL in under a minute without any knowledge of Elisp or VimScript/Lua or how to configure Run Configurations in IntelliJ. The default key bindings are good and the commands are easily discoverable. For its age it\u2019s surprisingly feature rich. 100% Five-star Marketplace Reviews We are super proud of the Calva reviews on the Visual Studio Code Marketplace . Please read them all. \ud83d\ude04 Here's a selection that we think captures what we focus on in when developing Calva: \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f Calva has become an essential part of my Clojure workflow. It's an incredible piece of work by the team behind it. Sean Corfield \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f Calva hits the sweet spot of being both approachable for new users and powerful for seasoned ones. The creators/maintainers are fantastic individuals that care deeply about streamlining the user experience, and it shows. Good stuff, check it out. Clay Hopperdietzel \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f I switched from IntelliJ / Cursive to VS Code and Calva and it's been amazing. ... That is the biggest thing I can say for Calva, it just works. I was never a fan of VS Code before, but VS Code + Calva for Clojure is now my favourite language / IDE experience. Plus, the #calva on the clojurians slack is brilliant, always someone there to help if you have issues (although any issue I've had has been squarely on me, and never Calva itself). I often feel we live in an age where so much software is badly written, without care, slow, buggy and just generally awful. Calva is the complete opposite. I think the maintainers want to, and have, made a wonderful piece of software for Clojure developers. Stuart Stein \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f This is great, and makes VS Code a truly viable IDE/editor for clojure development. It already has great REPL support (including inline evaluation), an extensive Paredit implementation, and excellent linting (care of the bundled clj-kondo). Calva is being improved on at an impressive clip by maintainers who appear solidly committed to its ongoing development. It's well-documented, and manages to be both approachable and capable. A no brainer if you're already a VS Code user, and well worth a look if you're not. Crispin Bennett \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f I'm using Calva now for a few months and I'm loving it. I joined the Slack channel about 2 wks ago and I must say that I'm very impressed by how active and responsive this community is. Already 2 of my issues fixed and I really like Calva (and the extensions it uses!). These are professional people and they make me very happy! Uitbeijerse, E (Eric)","title":"Why Calva?"},{"location":"why-calva/#why-calva","text":"The main reason you would choose Calva for your Clojure and/or ClojureScript coding is that you want to use Visual Studio Code . Calva provides VS Code users with a comprehensive set of features to keep you productive and make it easy to follow Clojure coding best practices. This also means that if your choice of editor is not made yet, we think you should give VS Code and Calva a try. While Calva is a good choice for professional and experienced Clojure developers, great care has been taken in making Calva a really good choice for beginners of Clojure as well. We who make Calva are actively stewarding, maintaining, documenting and supporting it . We are also very active Clojure (and Calva) users, participating in the community. Clojure is dear to us, a lot because it keeps programming fun and rewarding. Calva has very happy users! Check out the Programming Languages section on the Visual Studio Code Marketplace, sorted by rating : Recently there was a thread over at ClojureVerse , asking about how Calva Compares to Emacs with CIDER . It is well worth reading. We would like to highlight the answer by Nick Cernis , which focuses on Calva. We'll even quote parts of it. \ud83d\ude0d","title":"Why Calva?"},{"location":"why-calva/#nick-cernis-on-clojureverse","text":"My advice to anyone starting their Clojure journey who is unsure about what editor to use: Pick something today and start writing Clojure. Probably pick an editor you are familiar with already. If you\u2019re not familiar with any editor yet or you don\u2019t have a strong allegiance to one, choose VS Code and Calva. Switch to something else only if you encounter persistent annoyances that you can\u2019t remove with plugins, code/config changes, help from the community, or more sleep. I now use VS Code with Calva every day but went through a long journey trying almost every other editor and plugin combo first. I switched from Emacs to VS Code, which might make my perspective different to others here. \u2026 I started with the jaded assumption that VS Code was probably bad because it's built by committee at Microsoft on a web-tech based Electron stack, only to find that it succeeds in embodying the spirit of a \u201chacker's editor\u201d more than even Emacs does in many ways: \u2026 On the benefits of Calva: Of all the amazing Clojure community projects, Calva seems most likely to encourage new users to try Clojure and ClojureScript . A lot of developers use VS Code. It\u2019s been tricky to convince frontend developer friends to try ClojureScript, but at least they don\u2019t have the excuse that they\u2019ll need to switch editors to even try it now. I think as a community we should try to support the projects that encourage Clojure\u2019s adoption and ease of use, including by using those products ourselves. Calva provides a better first-time experience than any other editor/plugin combo whether you\u2019re new to Clojure or not. You can install the plugin and be chatting with your REPL in under a minute without any knowledge of Elisp or VimScript/Lua or how to configure Run Configurations in IntelliJ. The default key bindings are good and the commands are easily discoverable. For its age it\u2019s surprisingly feature rich.","title":"Nick Cernis on ClojureVerse"},{"location":"why-calva/#100-five-star-marketplace-reviews","text":"We are super proud of the Calva reviews on the Visual Studio Code Marketplace . Please read them all. \ud83d\ude04 Here's a selection that we think captures what we focus on in when developing Calva: \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f Calva has become an essential part of my Clojure workflow. It's an incredible piece of work by the team behind it. Sean Corfield \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f Calva hits the sweet spot of being both approachable for new users and powerful for seasoned ones. The creators/maintainers are fantastic individuals that care deeply about streamlining the user experience, and it shows. Good stuff, check it out. Clay Hopperdietzel \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f I switched from IntelliJ / Cursive to VS Code and Calva and it's been amazing. ... That is the biggest thing I can say for Calva, it just works. I was never a fan of VS Code before, but VS Code + Calva for Clojure is now my favourite language / IDE experience. Plus, the #calva on the clojurians slack is brilliant, always someone there to help if you have issues (although any issue I've had has been squarely on me, and never Calva itself). I often feel we live in an age where so much software is badly written, without care, slow, buggy and just generally awful. Calva is the complete opposite. I think the maintainers want to, and have, made a wonderful piece of software for Clojure developers. Stuart Stein \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f This is great, and makes VS Code a truly viable IDE/editor for clojure development. It already has great REPL support (including inline evaluation), an extensive Paredit implementation, and excellent linting (care of the bundled clj-kondo). Calva is being improved on at an impressive clip by maintainers who appear solidly committed to its ongoing development. It's well-documented, and manages to be both approachable and capable. A no brainer if you're already a VS Code user, and well worth a look if you're not. Crispin Bennett \u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f I'm using Calva now for a few months and I'm loving it. I joined the Slack channel about 2 wks ago and I must say that I'm very impressed by how active and responsive this community is. Already 2 of my issues fixed and I really like Calva (and the extensions it uses!). These are professional people and they make me very happy! Uitbeijerse, E (Eric)","title":"100% Five-star Marketplace Reviews"},{"location":"workspace-layouts/","text":"Workspace Layouts Project directory layouts can vary quite a lot. From the \u201dtemplate\u201d projects where the Clojure project files are at the root, to, well, let's just say that the project files are not always at the root. And sometimes there is more than one project. Calva only really supports working with one project at a time per VS Code window. Here's a short guide for some different setups: You have one project in the workspace, the project files are in there somewhere. Use a regular VS Code \u201dfolder window\u201d or a Workspace proper, both will totally work. You have more than one project in the repository, but only really work with one at a tine. Use a Workspace proper and add the different project directories as seperate Workspace Folders. You can only jack-in/connect to one project at a time. You have more than one project in the repository, and need to work with them in parallell. Open each project you want to work with in a separate VS Code window. One Folder - Two Windows? As is mentioned in the Calva Jack-In Guide , if you have a full stack project using a Clojure backend and a shadow-cljs frontend, you will need to open the same project in two separate VS Code windows, one for the backend and one for the frontend. This is how you can do that: Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Server.code-workspace . Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Client.code-workspace . Now, whenever you want to Jack-in to the backend and/or frontend, do it from the Server and/or Client workspace, respectively.","title":"Workspace Layouts"},{"location":"workspace-layouts/#workspace-layouts","text":"Project directory layouts can vary quite a lot. From the \u201dtemplate\u201d projects where the Clojure project files are at the root, to, well, let's just say that the project files are not always at the root. And sometimes there is more than one project. Calva only really supports working with one project at a time per VS Code window. Here's a short guide for some different setups: You have one project in the workspace, the project files are in there somewhere. Use a regular VS Code \u201dfolder window\u201d or a Workspace proper, both will totally work. You have more than one project in the repository, but only really work with one at a tine. Use a Workspace proper and add the different project directories as seperate Workspace Folders. You can only jack-in/connect to one project at a time. You have more than one project in the repository, and need to work with them in parallell. Open each project you want to work with in a separate VS Code window.","title":"Workspace Layouts"},{"location":"workspace-layouts/#one-folder-two-windows","text":"As is mentioned in the Calva Jack-In Guide , if you have a full stack project using a Clojure backend and a shadow-cljs frontend, you will need to open the same project in two separate VS Code windows, one for the backend and one for the frontend. This is how you can do that: Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Server.code-workspace . Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Client.code-workspace . Now, whenever you want to Jack-in to the backend and/or frontend, do it from the Server and/or Client workspace, respectively.","title":"One Folder - Two Windows?"},{"location":"wsl/","text":"Calva \u2764\ufe0f WSL The use of Calva with WSL (Windows Subsystem for Linux) is fully supported through the Remote - WSL extension. Simply install the extension an open your project with one of the Remote-WSL commands. Calva will run directly in the WSL environment and no further configuration is required. Steps Involved Enable WSL Install Ubuntu in WSL Install Java in WSL Install latest Clojure in WSL Install the Remote - WSL extension in VS Code Launch remote window Install Calva (gets installed into the WSL instance) Work away See also Remote Development .","title":"Calva \u2764\ufe0f WSL"},{"location":"wsl/#calva-wsl","text":"The use of Calva with WSL (Windows Subsystem for Linux) is fully supported through the Remote - WSL extension. Simply install the extension an open your project with one of the Remote-WSL commands. Calva will run directly in the WSL environment and no further configuration is required.","title":"Calva \u2764\ufe0f WSL"},{"location":"wsl/#steps-involved","text":"Enable WSL Install Ubuntu in WSL Install Java in WSL Install latest Clojure in WSL Install the Remote - WSL extension in VS Code Launch remote window Install Calva (gets installed into the WSL instance) Work away See also Remote Development .","title":"Steps Involved"}]}