{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\._]"},"docs":[{"location":"","text":"<p>Calva is an integrated, REPL powered, development environment for enjoyable and productive Clojure and ClojureScript programming in Visual Studio Code. It is feature rich and turnkey. A lot of effort has been put into making Calva a good choice if you are new to Clojure. Calva is open source and free to use.</p>","title":"Welcome!"},{"location":"#getting-started","text":"<p>Let's start a REPL!. \ud83d\ude80 Also see Get Started with Clojure</p>","title":"Getting Started"},{"location":"#how-to-contribute-to-calva","text":"<p>I'm glad you asked! Please see How to Contribute and The Tao of Calva</p>","title":"How to Contribute to Calva?"},{"location":"#calva-patrons","text":"The right kind of different","title":"Calva Patrons"},{"location":"#calva-gold-sponsors","text":"Scale your growth on mobile    MAKE. DO. SHIP.       <p>Please see this statement from Cognitect about the importance of supporting open source developers.</p> <p>See Sponsors for information about sponsoring Calva.</p> <p>If your Company benefits from Calva's existence and you see it as an important in the Clojure and ClojureScript ecosystem. please consider sponsoring!</p>","title":"Calva Gold Sponsors \u2665\ufe0f"},{"location":"#features","text":"<p>Calva includes inline code evaluation, structural editing, code formatting, code navigation, a debugger, linting, syntax highlighting, Clojure aware rainbow brackets, a test runner, refactoring support, and more. </p>","title":"Features"},{"location":"#have-questions-and-feedback-need-help","text":"<p>Easiest way is to chat with us and other Calva users. Please join the #calva channel on the Clojurians Slack. If you haven't joined that slack workspace, you can get an invite here.</p> <p>If you're a beginner to Clojure(Script), the #beginners channel of the Clojurians Slack is very active and helpful.</p> <p>Happy coding!</p>","title":"Have Questions and Feedback? Need Help?"},{"boost":7,"location":"api/","text":"<p>Calva exposes an API for use from other VS Code extensions (such as Joyride). The API is in an experimental state, while we are figuring out what is a good shape for this API. It is also rather small, and will grow to expose more of Calva's functionality.</p>","title":"The Calva Extension API"},{"boost":7,"location":"api/#accessing","text":"<p>To access the API the Calva extension needs to be activated. The API is exposed under the <code>v0</code> key on the extension's <code>exports</code>:</p> ClojureScriptJavaScript   <pre><code>(def calva (vscode/extensions.getExtension \"betterthantomorrow.calva\"))\n\n(def calvaApi (-&gt; calva\n                  .-exports\n                  .-v0\n                  (js-&gt;clj :keywordize-keys true)))\n</code></pre>   <pre><code>const calva = vscode.extensions.getExtension(\"betterthantomorrow.calva\");\n\nconst calvaApi = calva.exports.v0;\n</code></pre>","title":"Accessing"},{"boost":7,"location":"api/#repl","text":"<p>The <code>repl</code> module contains provides access to Calva's REPL connection.</p>","title":"<code>repl</code>"},{"boost":7,"location":"api/#replcurrentsessionkey","text":"<p>Use <code>repl.currentSessionKey()</code> find out which REPL/session Calva's REPL is currently connected to (depends on the active file). Returns either <code>\"clj\"</code>, or <code>\"cljs\"</code>, or <code>nil</code> if no REPL is connected.</p> ClojureScriptJavaScript   <pre><code>(def session-key ((get-in [:repl :currentSessionKey] calvaApi)))\n</code></pre>   <pre><code>const sessionKey = calvaApi.repl.evaluateCode()\n</code></pre>","title":"<code>repl.currentSessionKey()</code>"},{"boost":7,"location":"api/#replevaluatecode","text":"<p>This function lets you evaluate Clojure code through Calva's nREPL connection. Calling it returns a promise that resolves to a <code>Result</code> object. It's signature looks like so (TypeScript):</p> <pre><code>export async function evaluateCode(\n  sessionKey: 'clj' | 'cljs' | 'cljc' | undefined,\n  code: string,\n  output?: {\n    stdout: (m: string) =&gt; void;\n    stderr: (m: string) =&gt; void;\n  }\n): Promise&lt;Result&gt;;\n</code></pre> <p>Where <code>Result</code> is:</p> <pre><code>type Result = {\n  result: string;\n  ns: string;\n  output: string;\n  errorOutput: string;\n};\n</code></pre> <p>As you can see, the required arguments to the function are <code>sessionKey</code> and <code>code</code>. <code>sessionKey</code> should be <code>\"clj\"</code>, <code>\"cljs\"</code>, <code>\"cljc\"</code>, or <code>undefined</code> depending on which of Calva's REPL sessions/connections that should be used. It will depend on your project, and how you connect to it, which session keys are valid. Use <code>cljc</code> to request whatever REPL session <code>\"cljc\"</code> files are connected to. Use <code>undefined</code> to use the current REPL connection Calva would use (depends on which file is active).</p> <p>An example:</p> ClojureScriptJavaScript   <pre><code>(def evaluate (get-in [:repl :evaluateCode] calvaApi))\n(-&gt; (p/let [evaluation (evaluate \"clj\" \"(+ 2 40)\")]\n      (println (.-result evaluation)))\n    (p/catch (fn [e]\n               (println \"Evaluation error:\" e))))\n</code></pre>   <pre><code>try {\n  const evaluation = await calvaApi.repl.evaluateCode(\"clj\", \"(+ 2 40)\");\n  console.log(evaluation.result);\n} catch (e) {\n  console.error(\"Evaluation error:\", e);\n}\n</code></pre>","title":"<code>repl.evaluateCode()</code>"},{"boost":7,"location":"api/#handling-output","text":"<p>The <code>output</code> member on the <code>Result</code> object will have any output produced during evaluation. (The <code>errorOutput</code> member should contain error output produced, but currently some Calva bug makes this not work.) By default the stdout and stderr output is not printed anywhere.</p> <p>If you want to do something with either regular output or error output during, or after, evaluation, you'll need to provide the <code>output</code> argument to <code>evaluateCode()</code>. (The <code>stderr</code> callback function works, so this is the only way to get at any error output, until the above mentioned Calva bug is fixed.)</p> <p>An example:</p> ClojureScriptJavaScript   <pre><code>(def oc (joyride.core/output-channel)) ;; Assuming Joyride is used\n(def evaluate (fn [code]\n                ((get-in [:repl :evaluateCode] calvaApi)\n                 \"clj\"\n                 code\n                 #js {:stdout #(.append oc %)\n                      :stderr #(.append oc (str \"Error: \" %))})))\n\n(-&gt; (p/let [evaluation (evaluate \"(println :foo) (+ 2 40)\")]\n      (.appendLine oc (str \"=&gt; \" (.-result evaluation))))\n    (p/catch (fn [e]\n               (.appendLine oc (str \"Evaluation error: \" e)))))\n</code></pre>   <pre><code>const evaluate = (code) =&gt;\n  calvaApi.repl.evaluateCode(\"clj\", code, {\n    stdout: (s) =&gt; {\n      console.log(s);\n    },\n    stderr: (s) =&gt; {\n      console.error(s);\n    },\n  });\n\ntry {\n  const evaluation = await evaluate(\"(println :foo) (+ 2 40)\");\n  console.log(\"=&gt;\", evaluation.result);\n} catch (e) {\n  console.error(\"Evaluation error:\", e);\n}\n</code></pre>","title":"Handling Output"},{"boost":7,"location":"api/#ranges","text":"<p>The <code>ranges</code> module contains functions for retreiving vscode.Ranges and text for pieces of interest in a Clojure document.</p> <p>All functions in this module have the following TypeScript signature:</p> <pre><code>(editor = vscode.window.activeTextEditor, position = editor?.selection?.active) =&gt; [vscode.Range, string];\n</code></pre> <p>I.e. they expect a vscode.TextEditor \u2013 defaulting to the currently active editor \u2013 and a vscode.Position \u2013 defaulting to the current active position in the editor (or the first active position if multiple selections/positions exist, and will return a tuple with the range, and the text for the piece of interest requested.</p>  <p>Custom REPL Commands</p> <p>The <code>ranges</code> function have corresponding REPL Snippets/Commands substitution variables. It is the same implementation functions used in both cases.</p>  <p>The functions available are:</p>","title":"<code>ranges</code>"},{"boost":7,"location":"api/#rangescurrentform","text":"<p>Retrieves information about the current form, as determined from the editor and position.</p> <p>Corresponding REPL Snippet variable: <code>$current-form</code>.</p> <p>See also about Calva's Current Form on YouTube.</p>","title":"<code>ranges.currentForm()</code>"},{"boost":7,"location":"api/#rangescurrentenclosingform","text":"<p>The list/vector/etcetera form comtaining the current form.</p> <p>Corresponding REPL Snippet variable: <code>$enclosing-form</code>.</p>","title":"<code>ranges.currentEnclosingForm()</code>"},{"boost":7,"location":"api/#rangescurrenttoplevelform","text":"<p>The current top level form. Outside <code>(comment ...)</code> (Rich comments) forms this is most often (<code>(def ...), (defgn ...)</code>, etcetera. Inside Rich comments it will be the current immediate child to the <code>(comment ...)</code> form.</p> <p>Corresponding REPL Snippet variable: <code>$top-level-form</code>.</p>","title":"<code>ranges.currentTopLevelForm()</code>"},{"boost":7,"location":"api/#rangescurrentfunction","text":"<p>The current function, i.e. the form in \u201dcall position\u201d of the closest enclosing list.</p> <p>Corresponding REPL Snippet variable: <code>$current-fn</code>.</p>","title":"<code>ranges.currentFunction()</code>"},{"boost":7,"location":"api/#rangescurrenttopleveldef","text":"<p>The symbol being defined by the current top level form. NB: Will stupidly assume it is the second form. I.e. it does not check that it is an actual definition, and will often return nonsense if used in Rich comments.</p> <p>Corresponding REPL Snippet variable: <code>$top-level-defined-symbol</code>.</p>","title":"<code>ranges.currentTopLevelDef()</code>"},{"boost":7,"location":"api/#example-rangescurrenttoplevelform","text":"ClojureScriptJavaScript   <pre><code>(def top-level-form (get-in [:ranges :currentTopLevelForm] calvaApi))\n(def text (-&gt; (top-level-form)\n              second))\n</code></pre>   <pre><code>const text = ranges.currentTopLevelForm()[1];\n</code></pre>","title":"Example: <code>ranges.currentTopLevelForm()</code>"},{"boost":7,"location":"api/#feedback-welcome","text":"<p>Please let us know how you fare using this API. Either in the #calva or #joyride channels on Slack or via the issues/discussions sections on the repositories. (Whichever seems to apply best.)</p>","title":"Feedback Welcome"},{"location":"async-out/","text":"<p>When working on NodeJS projects with <code>shadow-cljs</code> and Calva, async output does not always appear in the Calva output window. To work around this problem, follow these steps:</p> <ol> <li>In a terminal run <code>npx shadow-cljs -d cider/cider-nrepl:0.27.4 node-repl</code></li> <li>Wait for the message <code>shadow-cljs - nREPL server started on port &lt;some-port&gt;</code></li> <li>Issue the command Calva: Connect to a running REPL server in your project, <code>ctrl+alt+c ctrl+alt+c</code>. For project type select <code>shadow-cljs</code>, accept the proposed <code>localhost:&lt;some-port&gt;</code>, and for <code>build</code> select <code>node-repl</code>.</li> <li>Load a file from your project with the command <code>ctrl+alt+c Enter.</code> Evaluating forms in Calva will show results in the output window. Synchronous <code>stdout</code> output will be printed in both the output window and in the terminal where you started the repl. Some asynchronous output may show up in the output window, but all will appear in the terminal.</li> </ol> <p>If you use an integrated VSCode terminal to start shadow-cljs, all <code>stdout</code> will appear in the Calva window with your code. Alternatively, you can use an external terminal, which is especially nice when using a second monitor.</p> <p>For a discussion of this problem and other connection options, see issue #1468.</p>","title":"Viewing Async Output While Working On Node Projects with <code>shadow-cljs</code>"},{"boost":5,"location":"babashka/","text":"<p>Since Babashka can be started such that it is an nREPL server, Calva can connect to it and a lot of the features will work.</p> <p>Calva can also start Babashka and connect its REPL for you, using the Jack-in command.</p>  <p>Don't expect complete support</p> <p>Babashka's nREPL server is still a bit limited compared to a full cider-nrepl enhanced \"regular\" Clojure nREPL server. Things like function signatures, and more do not work.</p> <p>This might of course improve in the future, especially if you provide some PRs towards the Babashka nREPL.</p>","title":"Using Calva with Babashka"},{"location":"clj-java-decompiler/","text":"<p>If you need some piece of Clojure code to execute as fast as possible you will often benefit from examining the code generated by the Clojure compiler from your code. There is a really easy to use tool for that: clj-java-decompiler. You can make the use of this tool super convenient with Calva custom command snippets.</p>","title":"Decompiling and disassembly made easy"},{"location":"clj-java-decompiler/#prerequisites","text":"<p>Add <code>com.clojure-goes-fast/clj-java-decompiler</code> as a dependency to the project.</p>","title":"Prerequisites"},{"location":"clj-java-decompiler/#the-custom-snippets","text":"<p>You can add some Calva custom commands configuration to be able to decompile or disassemble any Clojure code in your editor with a keyboard shortcut. Here's an example configuration:</p> <pre><code>    \"calva.customREPLCommandSnippets\": [\n        {\n            \"name\": \"Decompile current top level form\",\n            \"key\": \"d\",\n            \"snippet\": \"(require '[clj-java-decompiler.core :refer [decompile]]) (spit \\\"decompiled-$top-level-defined-symbol.java\\\" (with-out-str (decompile $top-level-form)))\"\n        },\n        {\n            \"name\": \"Decompile current form\",\n            \"snippet\": \"(require '[clj-java-decompiler.core :refer [decompile]]) (spit \\\"decompiled.java\\\" (with-out-str (decompile $current-form)))\"\n        },\n        {\n            \"name\": \"Disassemble current top level form\",\n            \"key\": \"b\",\n            \"snippet\": \"(require '[clj-java-decompiler.core :refer [disassemble]]) (spit \\\"bytecode-$top-level-defined-symbol.class\\\" (with-out-str (disassemble $top-level-form)))\"\n        },\n        {\n            \"name\": \"Disassemble current current form\",\n            \"snippet\": \"(require '[clj-java-decompiler.core :refer [disassemble]]) (spit \\\"bytecode.class\\\" (with-out-str (disassemble $current-form)))\"\n        }\n    ],\n</code></pre> <p>Now, with the cursor anywhere in a top level defined function, you can spit out a file with the Java code generated for that function by pressing <code>ctrl+alt+space d</code>. For the byte code, press <code>ctrl+alt+space b</code>. The files will be generated in the same folder as the Clojure file and be named <code>decompiled-&lt;function name&gt;.java</code> and <code>bytecode-&lt;function name&gt;.class</code>, respectively. </p> <p>To decompile or disassemble the current form (or selection) press <code>ctrl+alt+space space</code> and pick the desired command from the quick pick menu that pops up. You can add <code>key</code> to these too if you want even quicker access, of course. The filenames for the results will here be named without any function name suffix, because there is often no function name that can be used.</p> <p>See this video for a demo.</p>","title":"The custom snippets"},{"location":"clojure-lsp/","text":"<p>Calva uses a mix of static and dynamic analysis to power the experience. A lot of the static abilities come from clojure-lsp. This enables you to check something up in a project, with a lot of navigational and contextual support, without starting a REPL for it. (And once you do start a REPL you'll get even more capabilities, enabled by the dynamic analysis.)</p>  <p>Which clojure-lsp does Calva use?</p> <p>Calva defaults to using the <code>latest</code> clojure-lsp released. To use a different version of clojure-lsp, see the configuration section. Calva does not use the clojure-lsp installed on your system, unless you set the path for clojure-lsp to the installed binary in your settings. You can see what version is being used by running the <code>Clojure-lsp Server Info</code> command, which will also show the version of clj-kondo that's being used as well as other info. </p>","title":"Clojure-lsp"},{"location":"clojure-lsp/#the-lsp-server-starts-automatically","text":"<p>Unless you set <code>calva.enableClojureLspOnStart</code> to <code>false</code>, Calva will automatically start clojure-lsp. And you won't need to install antyting, because Calva handles that. It can take a while for clojure-lsp to start, especially the first time for a new project, when clojure-lsp (via <code>clj-kondo</code>) indexes the project files.</p>","title":"The LSP server starts automatically"},{"location":"clojure-lsp/#lsp-server-process-control","text":"<p>It is highly recommended to let clojure-lsp start automatically, and most often you can just let it do its wonderful magic without bothering with it. There are times when you might want to control and inspect the process, though. Calva has commands for:</p> <ul> <li>Inspecting the clojure-lsp server information</li> <li>Read the clojure-lsp server log</li> <li>Stopping clojure-lsp</li> <li>Starting clojure-lsp</li> <li>Download the configured clojure-lsp version</li> </ul> <p>In the status bar, Calva will show an indicator with the clojure-lsp status.</p>","title":"LSP server process control"},{"location":"clojure-lsp/#active-clojure-lsp","text":"<p>When clojure-lsp is downloaded, started and initialized the status bar indicator will look like so:</p> <p></p> <p>Clicking the item will bring up this menu:</p> <p></p> <p>See below about the server info and server log commands.</p>","title":"Active clojure-lsp"},{"location":"clojure-lsp/#stopped-clojure-lsp","text":"<p>When clojure-lsp is stopped the status bar indicator will look like so:</p> <p></p> <p>The clojure-lsp inactive menu:</p> <p></p> <p>The download option here will download the configured clojure-lsp version regardless if it is already installed or not. This can be useful when some earlier download has failed resulting in that clojure-lsp can't be started. NB: It will not download anything if <code>calva.clojureLspPath</code> is set to something non-blank.</p>","title":"Stopped clojure-lsp"},{"location":"clojure-lsp/#downloading-and-starting","text":"<p>The statusbar item also will indicate when clojure-lsp is being downloaded and while it is starting.</p>","title":"Downloading and starting"},{"location":"clojure-lsp/#ignoring-lsp-cache-files","text":"<p>Clojure-lsp stores its project analysis information in your project. Git users can add these lines to their project root directory <code>.gitignore</code>:</p> <pre><code>.clj-kondo/cache/\n.clj-kondo/.cache/\n.lsp/sqlite.*.db\n</code></pre>","title":"Ignoring LSP cache files"},{"location":"clojure-lsp/#configuration","text":"<p>For information about how to configure clojure-lsp, see the settings page of the clojure-lsp docs.</p>","title":"Configuration"},{"location":"clojure-lsp/#changing-the-version-of-clojure-lsp-used-by-calva","text":"<p>By default, Calva will use the latest released clojure-lsp. You can change the version of clojure-lsp used by Calva by setting the <code>calva.clojureLspVersion</code> property to a version of clojure-lsp found in its GitHub releases. This can be helpful if you're debugging an issue with clojure-lsp or you want to try out a feature of a new release that Calva does not yet use. However, you must remember to reset this setting in order for Calva to automatically use newer versions of clojure-lsp that are released with new versions of Calva.</p> <p>Example:</p> <pre><code>\"calva.clojureLspVersion\": \"2021.04.07-16.34.10\"\n</code></pre> <p>If you have specified a version and want to use the latest release, either remove the setting, or set it to <code>latest</code>.</p>","title":"Changing the Version of Clojure-lsp Used by Calva"},{"location":"clojure-lsp/#using-a-custom-clojure-lsp-native-binary","text":"<p>You can set a path to a clojure-lsp binary to be used by Calva by setting the <code>calva.clojureLspPath</code> setting. This should be an absolute path. When this is set, the binary at the path will be used and the <code>calva.clojureLspVersion</code> setting will be ignored.</p> <p>Example:</p> <pre><code>\"calva.clojureLspPath\": \"/usr/local/bin/clojure-lsp\"\n</code></pre>","title":"Using a Custom Clojure-lsp Native Binary"},{"location":"clojure-lsp/#clojure-lsp-drag-fwdback","text":"<p>clojure-lsp contributes two commands for dragging forms forward or backward. They are similar to Calva's Paredit corresponding commands.</p>  <p>Experimental</p> <p>Consider the addition of these commands to the command palette as an experimental feature. We might remove the commands later if they cause confusion or if Calva's commands improve about contextual support.</p>  <p>There are reasons you might prefer the clojure-lsp versions over the Calva built-ins:</p> <ul> <li>Better comment affinity. Comments stay affiliated with clauses as they're dragged.</li> <li>Better contextual support. In addition to the bindings mentioned below, also <code>assoc</code>, <code>case</code>, <code>cond</code>, and some more forms get adapted drag treatment.</li> </ul> <p>There are also reasons why you might want to stick with Calva's built-ins. See this PR and its links for a detailed discussion of the differences. TL;DR:</p> <ul> <li>clojure-lsp is not active in all Calva Clojure files, the REPL/output window being an extra noticeable example. If you bind the clojure-lsp commands in a way that replaces the key bindings for Calva's drag commands, add <code>&amp;&amp; !calva:outputWindowActive</code> to the <code>when</code> clause.</li> <li>clojure-lsp does not honor Calva's Current Form semantics. You might be in for some surprises in what gets dragged.</li> <li>The cursor does not stay in place within the dragged form when dragging, breaking with how all Paredit edit commands work, and with how VS Code built in drag-line works.</li> <li>Performance is not as as good as Calva's built-ins. This gets noticeable in large files.</li> <li>Semantic token styling gets out-of-wack, leaving symbols having several stylings and other artifacts. (With Calva's commands, the styling gets invalidated for the current enclosing form, which looks less jarring.)</li> </ul> <p>To use the clojure-lsp commands, search for \"clojure-lsp drag\" in the command palette or the keyboard shortcut preferences menu, or choose them from the Quick Fix suggestion lightbulb.</p>","title":"clojure-lsp drag fwd/back"},{"location":"clojure-lsp/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"clojure-lsp/#viewing-the-logs-between-the-client-and-server","text":"<p>If something doesn't seem to be working correctly, and you suspect the issue is related to clojure-lsp, a good place to start investigating is the request and response logs between the LSP client and server. In your settings, set <code>clojure.trace.server</code> to <code>verbose</code>, then in the VS Code output tab, select the <code>Clojure Language Client</code> output channel.</p> <p></p> <p>It may be helpful to clear the output channel, then perform the action with which you're experiencing a problem, then read through the log for clues or paste the logs into a related issue in the Calva repo.</p>","title":"Viewing the Logs Between the Client and Server"},{"location":"clojure-lsp/#server-info-command","text":"<p>You can run the <code>Clojure-lsp Server Info</code> command to get information about the running clojure-lsp server, such as the version the server being used, the version of clj-kondo it's using, and more. This info is printed to the \"Calva says\" output channel.</p>","title":"Server Info Command"},{"location":"clojure-lsp/#opening-the-server-log-file","text":"<p>You can open the clojure-lsp log file by running the command <code>Calva Diagnostics: Open Clojure-lsp Log File</code>. The log file will only be opened with this command if the clojure-lsp server is running and has finished initializing. If you need to open the file when the server is failing to run or initialize, see the clojure-lsp docs for information on the file location.</p>","title":"Opening the Server Log File"},{"location":"clojure-lsp/#related","text":"<p>See also:</p> <ul> <li>Connecting the REPL</li> <li>Refactoring</li> </ul>","title":"Related"},{"boost":4,"location":"clojuredocs/","text":"<p>clojuredocs.org is the goto place #1 for finding out more about Clojure core(-ish) functions, macros, etcetera. It contains the doc strings from the functions and adds crowd sourced examples of usage and see alsos. You can surf for quite long on that site without getting bored. \ud83d\ude04</p>   You can surf ClojureDocs in Calva  <p>Calva integrates this information in two ways:</p> <ol> <li>Commands for requesting the ClojureDocs information for a symbol under the cursor:<ul> <li>Print clojuredocs.org examples to Rich Comment, default keybinding: <code>ctrl+alt+r d</code></li> <li>Print clojuredocs.org examples to OutputWindow, <code>ctrl+alt+o d</code></li> </ul> </li> <li>ClojureDocs information is included in the symbol lookup hovers, where each example has two buttons:<ul> <li>To Rich Comment</li> <li>To Output Window </li> </ul> </li> </ol> <p>That means that if you just want to glance at the examples, you look in the hover. And when you want to bring the examples to the REPL to play with them, you can do so very easily.</p>  <p>ClojureScript support</p> <p>ClojureDocs information is available both for Clojure and ClojureScript files. However, clojuredocs.org only keeps info for Clojure. Thus: All information Calva shows about a symbol will be about the Clojure respresentation of that symbol. (The symbol might not even exist in ClojureScript.)</p>","title":"ClojureDocs integration"},{"boost":4,"location":"clojuredocs/#clojuredocs-repl-surfing","text":"<p>Since the ClojureDocs information includes see-alsos, you can go for super interactive ClojureDocs surfing right in the file you are editing. Say you have this function:</p> <pre><code>(defn trim-text\n  \"Returns text without surrounding whitespace if not empty, otherwise nil\"\n  [text]\n  (let [trimmed-text (clojure.string/trim text)]\n    (when-not (empty? trimmed-text)\n      trimmed-text)))\n</code></pre> <p>Then you hover on <code>when-not</code> and scroll down a bit in the hover:</p> <p></p> <p>That first example would be interesting to play with, right? Click To Rich Comment and you will get:</p> <pre><code>(defn trim-text\n  \"Returns text without surrounding whitespace if not empty, otherwise nil\"\n  [text]\n  (let [trimmed-text (clojure.string/trim text)]\n    (when-not (empty? trimmed-text)\n      trimmed-text)))\n\n(comment\n  ;; = when-not - Example 1 = \n\n  ;; build tuples over sets with the same cardinality \n  (map\n   #(when-not (= %2 %3) [%1 %2 %3])\n   (iterate inc 0)   ; a lazy list of indices\n   [:a :b :c]\n   [:a :a :a])\n  ;;=&gt; (nil [1 :b :a] [2 :c :a])\n\n  ;; See also:\n  when\n  when-let\n  if\n  )\n</code></pre> <p>There you can evaluate the <code>(map ...)</code> form using <code>alt+enter</code>, modify it and evaluate again. You can also hover over <code>map</code>, <code>iterate</code>, or any of the \u201dSee also:\u201d symbols to find more fun examples to play with. And so on and so forth.</p> <p>See these two tweets for some videos of early versions of this functionality:</p> <ul> <li>Rich Comments surfing ClojureDocs Examples</li> <li>Clojuredocs in #Calva WIP 2: Hover examples -&gt; RFC</li> </ul> <p>Please retweet!</p>","title":"ClojureDocs REPL Surfing"},{"boost":4,"location":"clojuredocs/#quirks","text":"<p>Some of the ClojureDocs entries have text that is not really Clojure code, and sometimes even structural errors. This can break the structural integrity of your Clojure file. If you run into trouble trying to heal things, you can always use Undo until the Rich Comment is gone.</p>","title":"Quirks"},{"location":"commands-top10/","text":"<p>There are not all that many Calva commands. You can learn them all if you like, but here are the most important ones to know about for effective Clojure/ClojureScript coding:</p> <ul> <li>Grow/expand selection: <code>ctrl+w</code> (<code>shift+alt+right</code> on Windows and Linux)</li> <li>Load/Evaluate Current File and its Requires/Dependencies: <code>alt+ctrl+c enter</code>, evaluates the namespace code in the active editor tab. This also loads any required namespaces, and generally gives Calva what it needs to work.</li> <li>Evaluate current form:  <code>ctrl+enter</code> finds the form from the cursor position, evaluates it and displays the result inline. Hit <code>esc</code> to dismiss the results display.</li> <li>Evaluate current top-level form: <code>alt+enter</code>: inline evaluate the current top-level form. This also works inside <code>(comment)</code> forms. Use it to (re)define vars and then inside comment forms you can verify that they do what you want them to do.</li> <li>Dismiss the display of results: <code>escape</code>: (VIM Extension users should read Using Calva with the VIM Extension).</li> </ul> <p>There are also two commands for bringing over the current form and the current top level form over to the repl window:</p> <ul> <li><code>ctrl+alt+c ctrl+alt+e</code> (<code>ctrl+alt+c ctrl+alt+v</code> on Windows): to paste the current form in the REPL window.</li> <li><code>ctrl+alt+c ctrl+alt+space</code>: to paste the current top-level form in this window</li> </ul> <p>You can also switch the name space of the output/repl window to that of the current file: <code>alt+ctrl+c alt+n</code></p> <ul> <li>Toggle pretty printing of results on and off: <code>ctrl+alt+c p</code>. It's on by default. There is a status bar button showing the status and that also can be used to toggle the setting.</li> </ul>","title":"The Top 10 Calva Commands"},{"location":"commands-top10/#some-more-commands-to-try","text":"<ul> <li>Code evaluation<ul> <li>Evaluate code and add as comment: <code>ctrl+alt+c c</code> (current form), <code>ctrl+alt+c ctrl+space</code> (current top level form)</li> <li>Evaluate code and replace it in the editor, inline: <code>ctrl+alt+c r</code></li> </ul> </li> <li>Integrated REPLs<ul> <li>Send current editor form to the REPL window: <code>ctrl+alt+c ctrl+alt+e</code> (<code>ctrl+alt+c ctrl+alt+v</code> on Windows)</li> <li>Send current editor top level form to the REPL window: <code>ctrl+alt+c ctrl+alt+space</code></li> </ul> </li> <li>Run tests and mark failures and errors in the Problems pane<ul> <li>Run namespace tests: <code>ctrl+alt+c t</code></li> <li>Run all tests: <code>ctrl+alt+c shift+t</code></li> <li>Run current test: <code>ctrl+alt+c ctrl+alt+t</code></li> <li>Rerun previously failing tests: <code>ctrl+alt+c ctrl+t</code></li> <li>Caveat: Right now the tests are reported only when all are run, making it painful to run all tests in larger projects. I'll fix it. Promise!</li> </ul> </li> <li>Select current form: <code>ctrl+alt+c s</code>.</li> <li>Run custom commands, i.e. code snippets, at will: <code>ctrl+alt+c .</code></li> </ul> <p>See also:</p> <ul> <li>Code Evaluation Tips</li> <li>Finding Calva Commands and Shortcuts</li> </ul>","title":"Some More Commands to Try"},{"boost":6,"location":"connect-sequences/","text":"<p>Many projects grow out of the template phase and call for custom developer workflows involving application start commands, customized REPLs, and what have you. Even some templates add this kind of complexity. To make Jack-in usable for a broader set of projects, Calva has a setting keyed <code>calva.replConnectSequences</code> which lets you configure one ore more connect sequences.</p> <p>NB: Connect sequence configuration affects Calva's Jack-in menu in the following ways:</p> <ol> <li>With no sequence configured, Calva will prompt for the built-in sequences it has that seems to match your project.</li> <li>When any number of connection sequences are configured, Calva will prompt for your custom sequences, as well as the built-in sequences. Whether built-in or custom, only sequences relevant to your project will be included in the prompt.</li> </ol>","title":"REPL Jack-in and Connect Sequences"},{"boost":6,"location":"connect-sequences/#settings-for-adding-custom-sequences","text":"<p>A connect sequence configures the following:</p> <ul> <li><code>name</code>: (required) This will show up in the Jack-in quick-pick menu when you start Jack-in (see above).</li> <li><code>projectType</code>: (required) This is either \"Leiningen\u201d, \u201ddeps.edn\u201d, \u201dshadow-cljs\u201d, \u201dlein-shadow\u201d, or \u201dgeneric\".</li> <li><code>nReplPortFile</code>: An array of path segments with the project root-relative path to the nREPL port file for this connect sequence. E.g. For shadow-cljs this would be <code>[\".shadow-cljs\", \"nrepl.port\"]</code>.</li> <li><code>afterCLJReplJackInCode</code>: Here you can give Calva some Clojure code to evaluate in the CLJ REPL, once it has been created.</li> <li><code>cljsType</code>: This can be either \"Figwheel Main\", \"shadow-cljs\", \"ClojureScript built-in for browser\", \"ClojureScript built-in for node\", \"lein-figwheel\", \"none\", or a dictionary configuring a custom type. If set to \"none\", Calva will skip connecting a ClojureScript repl. A custom type has the following fields:<ul> <li><code>dependsOn</code>: (required) Calva will use this to determine which dependencies it will add when starting the project (Jacking in). This can be either \"Figwheel Main\", \"shadow-cljs\", \"ClojureScript built-in for browser\", \"ClojureScript built-in for node\", \"lein-figwheel\", or \u201dUser provided\u201d. If it is \"User provided\", then you need to provide the dependencies in the project or launch with an alias (deps.edn), profile (Leiningen), or build (shadow-cljs) that provides the dependencies needed.</li> <li><code>isStarted</code>: Boolean. For CLJS REPLs that Calva does not need to start, set this to true. (If you base your custom cljs repl on a shadow-cljs workflow, for instance.)</li> <li><code>startCode</code>: Clojure code to be evaluated to create and/or start your custom CLJS REPL.</li> <li><code>isStartedRegExp</code>: A regular expression which, when matched in the stdout from the startCode evaluation, will make Calva continue with connecting the REPL, and to prompt the user to start the application. If omitted and there is startCode Calva will continue when that code is evaluated.</li> <li><code>openUrlRegExp</code>: A regular expression, matched against the stdout of cljsType evaluations, for extracting the URL with which the app can be started. The expression should have a capturing group named <code>url</code>. E.g. \"Open URL: (?\\&lt;url&gt;S+)\"</li> <li><code>shouldOpenUrl</code>: Choose if Calva should automatically open the URL for you or not.</li> <li><code>connectCode</code>: (required) Clojure code to be evaluated to convert the REPL to a CLJS REPL that Calva can use to connect to the application. (For some setups this could also conditionally start the CLJS REPL. If so: <code>startCode</code> should be omitted.)</li> <li><code>isConnectedRegExp</code>: (required) A regular expression which, when matched in the <code>stdout</code> from the <code>connectCode</code> evaluation, will tell Calva that the application is connected. The default is <code>To quit, type: :cljs/quit</code> and you should leave it at that unless you know it won't work.</li> <li><code>printThisLineRegExp</code>: regular expression which, when matched in the <code>stdout</code> from any code evaluations in the <code>cljsType</code>, will make the matched text be printed to the Output window.</li> <li><code>buildsRequired</code>: Boolean. If the repl type requires that builds are started in order to connect to them, set this to true.</li> </ul> </li> <li><code>menuSelections</code>: a dictionary with pre-filled-in selections for the Jack-in and Connect prompts, making Calva not prompt for that particular selection:<ul> <li><code>leinProfiles</code>: At Jack-in to a Leiningen project, use these profiles to launch the repl.</li> <li><code>leinAlias</code>: At Jack-in to a Leiningen project, launch with this alias. Set to <code>null</code> to launch with Calva's default task (a headless repl), w/o prompting.</li> <li><code>cljAliases</code>: At Jack-in to a deps.edn project, use these aliases to launch the repl.</li> <li><code>cljsLaunchBuilds</code>: The cljs builds to start/watch at Jack-in/connect.</li> <li><code>cljsDefaultBuild</code>: Which cljs build to attach to at the initial connect.</li> </ul> </li> <li><code>jackInEnv</code>: An object with environment variables that will be merged with the global <code>calva.jackInEnv</code> and then applied to the Jack-in process. The merge is very similar to how Clojure's <code>merge</code> works. So for any common keys between the global setting and this one, the ones from this setting will win.</li> </ul> <p>The Calva built-in sequences also use this format, check them out to get a clearer picture of how these settings work.</p>  <p>Apropos the ClojureScript nREPL Server built-in sequence</p> <p>Because of ancient decisions in the design of Calva session management, the current implementation of the ClojureScript nREPL Server connect sequence is a workaround. Calva will still indicate that it has a Clojure session available, which is nonsense in a pure ClojureScript nREPL environment. This session is also a ClojureScript session.</p>","title":"Settings for adding Custom Sequences"},{"boost":6,"location":"connect-sequences/#example-sequences","text":"<p>Setting for a full-stack application. It starts the backend server when the CLJ REPL has started. Then proceeds to create a custom CLJS REPL (calling in to the application code for this). And then connects to it.</p> <pre><code>{\n    \"calva.replConnectSequences\": [\n        {\n            \"name\": \"Example Sequence\",\n            \"projectType\": \"Clojure-CLI\",\n            \"afterCLJReplJackInCode\": \"(go)\",\n            \"cljsType\": {\n                \"startCode\": \"(do (require '[cljs-test.main :refer :all])(start-nrepl+fig))\",\n                \"isStartedRegExp\": \"Prompt will show\",\n                \"connectCode\": \"(do (use 'cljs-test.main) (cljs-repl))\",\n                \"isConnectedRegExp\": \"To quit, type: :cljs/quit\",\n                \"printThisLineRegExp\": \"\\\\[Figwheel\\\\] Starting Server at.*\"\n            }\n        }\n    ]\n}\n</code></pre> <p>Here is an example from the JUXT Edge project template. It adds two sequences, one for when only the Clojure REPL should be launched and one for when the customized Edge cljs repl should also be connected. The Edge backend + frontend sequence specifies that the web app should be opened by Calva, making cljs repl connection more stable, and also adds <code>menuSelections</code> to skip the launch aliases prompt.</p> <pre><code>{\n    \"calva.replConnectSequences\": [\n        {\n            \"name\": \"Edge backend only\",\n            \"projectType\": \"deps.edn\"\n        },\n        {\n            \"name\": \"Edge backend + frontend\",\n            \"projectType\": \"deps.edn\",\n            \"cljsType\": {\n                \"dependsOn\": \"Figwheel Main\",\n                \"startCode\": \"(do (require 'dev-extras) (dev-extras/go) (println \\\"Edge Figwheel Main started\\\") ((resolve 'dev-extras/cljs-repl)))\",\n                \"isReadyToStartRegExp\": \"Edge Figwheel Main started\",\n                \"openUrlRegExp\": \"Website listening on: (?&lt;url&gt;\\\\S+)\",\n                \"printThisLineRegExp\": \"\\\\[Edge\\\\]\",\n                \"shouldOpenUrl\": true,\n                \"connectCode\": \"(do (require 'dev-extras) ((resolve 'dev-extras/cljs-repl)))\",\n                \"isConnectedRegExp\": \"To quit, type: :cljs/quit\",\n                \"buildsRequired\": false\n            },\n            \"menuSelections\": {\n                \"cljAliases\": [\n                    \"dev\",\n                    \"build\",\n                    \"dev/build\"\n                ],\n            }\n        }\n    ]\n}\n</code></pre> <p>A deps.edn sequence that does not promote the ClojureScript repl at all (leaving it a Clojure REPL), and leaves that up to you to do interactively. (Could be useful while you are developing a custom cljs repl.) The example is for when adapting a Figwheel Main repl.</p> <pre><code>{\n    \"calva.replConnectSequences\": [\n        {\n            \"name\": \"Do not promote to cljs\",\n            \"projectType\": \"deps.edn\",\n            \"cljsType\": {\n                \"dependsOn\": \"Figwheel Main\",\n                \"connectCode\": \"\\\"Don't promote me bro!\\\"\",\n                \"isConnectedRegExp\": \"Don't promote me bro!\"\n            }\n        }\n    ]\n}\n</code></pre>","title":"Example Sequences"},{"boost":7,"location":"connect/","text":"<p>The recommended way is to:</p>","title":"Connect Calva to Your Project"},{"boost":7,"location":"connect/#jack-in-let-calva-start-the-repl-for-you","text":"<p>This way Calva can make sure it is started with the dependencies needed for a working Clojure and/or ClojureScript session. This is often referred to as Jack in (because that is what it is called in CIDER).</p> <p>Jack-in supports both CLJ and for CLJS, and has built-in configurations for Leiningen, deps.edn, and shadow-cljs projects, as well as for the CLJS repl types: Figwheel Main, lein-figwheel (legacy Figwheel), shadow-cljs, and ClojureScript built-ins for both browser and node.js. Using jack-in provides your development environment with all the dependencies you need for Calva to work.</p> <p>It works like so:</p> <ol> <li>Open your project in VS Code.</li> <li>Issue the command Start a Project REPL and Connect: <code>ctrl+alt+c ctrl+alt+j</code>.</li> <li>Answer the quick-pick prompts telling Calva about project types and what profiles to start. (See the Jack-in Project Types and Profiles wiki page for more info if needed.)</li> </ol> <p>See also: Workspace Layouts</p>  <p>About project roots</p> <p>You must have a project file, such as <code>project.clj</code> for Leiningen, or <code>deps.edn</code> for deps.edn, or <code>shadow-cljs.edn</code> for shadow-cljs, in the directory opened in VS Code in order for jack-in to work. If, after adding the project file, you experience an error during jack-in that says something could not be located, make sure you have the correct dependencies in your project file. For example, when using the Figwheel Main project type, you should have <code>com.bhauman/figwheel-main</code> in your project dependencies.</p> <p>See also below, regarding multiple projects in a workspace</p>","title":"Jack-in: Let Calva Start the REPL For You"},{"boost":7,"location":"connect/#aliases-profiles-builds","text":"<p>When Jack-in starts it will depend on the project type, and whether ClojureScript is involved or not, and if it is, what kind of ClojureScript project, what will happen next. Calva will analyze the project files and will then give you prompts with selections based on what is found there.</p> <p>You will need some basic knowledge about the project and the project type terminologies to answer the prompts.</p> <p>There are ways to tell Calva the answers to these prompts beforehand, so that Jack-in can be a zero-prompting command. Read on.</p>","title":"Aliases, Profiles, Builds"},{"boost":7,"location":"connect/#customizing-jack-in","text":"<p>The main mechanism for customizing your Jack-in, including automating menu selections, and custom CLJS REPL types is Custom Connect Sequences.</p> <p>There are also these settings:</p> <ul> <li><code>calva.jackInEnv</code>: An object with environment variables that will be added to the environment of the Jack-in process.</li> <li><code>calva.myCljAliases</code>: An array of <code>deps.edn</code> aliases not found in the project file. Use this to tell Calva Jack-in to launch your REPL using your user defined aliases.</li> <li><code>calva.myLeinProfiles</code>: An array of Leiningen profiles not found in <code>project.clj</code>. Use this to tell Calva Jack-in to launch your REPL using your user defined profiles.</li> <li><code>calva.openBrowserWhenFigwheelStarted</code>: For Legacy Figwheel only. A boolean controlling if Calva should automatically launch your ClojureScript app, once it is compiled by Figwheel. Defaults to <code>true</code>.</li> </ul>  <p>Note</p> <p>When processing the <code>calva.jackInEnv</code> setting you can refer to existing ENV variables with <code>${env:VARIABLE}</code>.</p>","title":"Customizing Jack-in"},{"boost":7,"location":"connect/#connecting-without-jack-in","text":"<p>If, for whatever reasons, you can't use Jack-in with your project (possibly because the REPL is started as part of some other job) all is not lost. Old fashioned Connect to a running REPL is still there for you. For all features to work in Calva while connecting to a running REPL, your environment needs to have REPL related dependencies set up.</p> <p>However, just as before it can be tricky to get the dependencies right. Consider using Jack in to inform yourself on how to start your REPL to Calva's satisfaction. When you use Jack in, Calva starts a VS Code task for it and the command line used is displayed in the terminal pane used to handle the task. Reading that command line tells you what dependencies are needed for your project.</p> <p>Even better: Copying that command line gives you the command to start the REPL with the correct dependencies.</p> <p>All this said, I still recommend you challenge the conclusion that you can't use Jack-in.</p>  <p>Note</p> <p>There is a Calva command for copying the Jack-in command line to the clipboard.</p>","title":"Connecting Without Jack-in"},{"boost":7,"location":"connect/#monorepos-multiple-clojure-projects-in-one-workspace","text":"<p>If the workspace is a monorepo, Polylith repo or just a repository with more than one Clojure project, Calva will start the connect sequence with prompting for which project to start/connect to.</p> <p></p> <p>When searching for project roots in your workspace, Calva will glob for all files matching <code>project.clj</code>, <code>deps.edn</code>, or <code>shadow-cljs.edn</code>. This is done using VS Code's workspace search engine, and is very efficient. However, in a large monorepo, it is still a substantial task. In order to not waste resources Calva will exclude any directories in the setting <code>calva.projectRootsSearchExclude</code>. </p> <p></p>  <p>Exclude entry globs</p> <p>Each entry is a partial glob and will be part of a resulting glob of the form <code>**/{glob1,glob2,...,globN}</code>. This means that all directories in the workspace matching an entry will be excluded, regardless of where in the workspace they reside.</p>","title":"Monorepos / multiple Clojure projects in one workspace"},{"boost":7,"location":"connect/#troubleshooting","text":"","title":"Troubleshooting"},{"boost":7,"location":"connect/#command-not-found-errors-when-jacking-in","text":"<p>If you get <code>command not found</code> error when Calva tries to start your project, and you know you have the command installed, it's probably because VS Code starts from an environment where the command is not on the <code>$PATH</code>. It can look like so:</p> <pre><code>lein update-in :dependencies conj '[nrepl,\"0.8.3\"]' -- update-in :plugins conj '[cider/cider-nrepl,\"0.25.8\"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- repl :headless\n/bin/sh: lein: command not found\nJack-in process exited. Status: 127\n</code></pre> <p>The fix is to always start VS Code from the command line:</p> <pre><code>$ code\n</code></pre> <p>You might need to first run the Shell Command: Install <code>code</code> command in PATH.</p> <p>This will also make sure your REPL has access to the environment you probably expect it to have access to. See below.</p>","title":"Command Not Found Errors When Jacking In"},{"boost":7,"location":"connect/#go-to-definition-not-working-for-java-definitions","text":"<p>On some systems, the Java source may not be installed along with the JDK. The source must be present on your system in order to navigate to Java definitions. See this comment for more details.</p>","title":"Go to Definition Not Working for Java Definitions"},{"boost":7,"location":"connect/#environment-variables-are-not-readable-from-repl","text":"<p>If you've added environment variables in your OS, such as in your <code>~/.bashrc</code> file (Linux), in order for them to be read in a REPL created by Calva's jackin command, VS Code must be started from a shell where the environment variables are defined. For example, if you can open a bash terminal and run <code>echo $SOME_VAR</code> and see the value there, then open VS Code from that terminal with <code>code &lt;project path&gt;</code>.</p>","title":"Environment Variables Are Not Readable From REPL"},{"boost":7,"location":"connect/#viewing-the-communication-between-nrepl-and-calva","text":"<p>It may be helpful to view the messages sent between nREPL and Calva when troubleshooting an issue related to the REPL. See how to do that here.</p>","title":"Viewing the Communication Between nREPL and Calva"},{"location":"contribute/","text":"<p>There are many ways to contribute:</p> <ul> <li>Become a sponsor</li> <li>Give us feedback:</li> <li>File issues</li> <li>Talk to us via the #calva channel at the Clojurians Slack (use the latter link to grab an invite)</li> <li>Provide PRs, see the Calva wiki about How to Hack on Calva</li> <li>Give us feedback, preferably via that <code>#calva</code> channel</li> <li>Cheer us on. (Same channel)</li> <li>Help us test things like reported issues, new features, etcetera. See Testing VSIX Packages and Smoke Testing</li> <li>Make tutorials, write blog articles, spread the word</li> <li>Star the Calva repository</li> <li>Help us help beginners with Calva and Clojure, on Slack as well as IRL and wherever.</li> </ul> <p>Be creative!</p> <p>Happy Coding! \u2764\ufe0f</p>","title":"Contribute to Calva"},{"boost":4,"location":"custom-commands/","text":"<p>Calva supports configuration of custom command snippets that you can evaluate in the REPL at will. If your workflow has you repeatedly evaluate a particular piece of code, you can use the setting <code>calva.customREPLCommandSnippets</code> to configure it. Then either bind keyboard shortcuts to them or use the command Run Custom REPL Command to access it. The command will give you a menu with the snippets you have configured.</p>  <p>Joyride</p> <p>For some use cases you might be better served by/want to combine these with using the VS Code Extension API, and that of Calva, or any other extension, through Joyride.</p>  <p>The <code>calva.customREPLCommandSnippets</code> is an array of objects with the following fields (required fields in bold):</p> <ul> <li><code>name</code>: The name of the snippet as it will appear in the picker menu</li> <li><code>snippet</code>: The code that will be evaluated</li> <li><code>key</code>: A key can be used to reference the snippet from Run Custom REPL Command keyboard shortcut arguments. It will also be used in the quick-pick menu.</li> <li><code>ns</code>: A namespace to evaluate the command in. If omitted the command will be executed in the namespace of the current editor.</li> <li><code>repl</code>: Which repl session to use for the evaluation. Either <code>\"clj\"</code> or <code>\"cljs\"</code>. Omit if you want to use the session of the current editor.</li> </ul> <p>There are also substitutions available, which will take elements from the current state of Calva and splice them in to the text of your command before executing it. They are</p> <ul> <li><code>$line</code>: Current line number in editor</li> <li><code>$column</code>: Current column number in editor</li> <li><code>$file</code>: Full name of current file edited</li> <li><code>$ns</code>: The namespace used for evaluating the command</li> <li><code>$selection</code>: The currently selected text</li> <li><code>$current-form</code>: The text of the current form</li> <li><code>$enclosing-form</code>: The text of the current enclosing form</li> <li><code>$top-level-form</code> The text of the current top level form</li> <li><code>$current-fn</code>: The sexpr/form at call position in the current list, e.g. <code>str</code> with <code>(defn foo [] (str \"foo\" \"bar|\"))</code></li> <li><code>$top-level-defined-symbol</code>: The second symbol of the top level form, e.g. <code>foo</code> with <code>(defn foo [] (str \"foo\" \"bar|\"))</code></li> <li><code>$head</code>: The text between the start of the current list to the cursor</li> <li><code>$tail</code>: The text between the cursor and the end of the current list</li> </ul>","title":"Custom REPL Commands"},{"boost":4,"location":"custom-commands/#user-and-workspace-settings","text":"<p>Settings from your User (global) level and the workspace are merged.</p> <p>With these User settings:</p> <pre><code>    \"calva.customREPLCommandSnippets\": [\n        {\n            \"name\": \"Call Current Form\",\n            \"key\": \"c\",\n            \"snippet\": \"($current-form)\"\n        },\n        {\n            \"name\": \"Call Current Top Level Form\",\n            \"key\": \"t\",\n            \"snippet\": \"($top-level-form)\"\n        },\n        {\n            \"name\": \"CLJ Test Top Level Defined Symbol\",\n            \"repl\": \"clj\",\n            \"snippet\": \"(clojure.test/test-var #'$top-level-defined-symbol)\"\n        },\n        {\n            \"name\": \"CLJS Test Top Level Defined Symbol\",\n            \"repl\": \"cljs\",\n            \"snippet\": \"(cljs.test/test-var #'$top-level-defined-symbol)\",\n            \"key\": \"tab\"\n        }\n    ],\n</code></pre> <p>And these Workspace settings:</p> <pre><code>    \"calva.customREPLCommandSnippets\": [\n        {\n            \"name\": \"Remount CLJS App\",\n            \"key\": \"r\",\n            \"repl\": \"cljs\",\n            \"ns\": \"example.app\",\n            \"snippet\": \"(start)\"\n        }\n    ],\n</code></pre> <p>Issuing Run Custom REPL Command will then render this VS Code menu:</p> <p></p> <p>The default keyboard shortcut for the command is <code>ctrl+alt+space space</code>.</p>","title":"User and Workspace settings"},{"boost":4,"location":"custom-commands/#binding-keyboard-shortcuts","text":"<p>There are three ways to bind shortcuts to custom commands:</p> <ol> <li>Use a predefined <code>key</code> shortcut. These are predefined as <code>ctrl+alt+space &lt;something&gt;</code>, where <code>&lt;something&gt;</code> is one of:<ul> <li>The digits <code>0</code> through <code>9</code></li> <li>The English letters <code>a</code> through <code>z</code></li> <li>Arrow keys <code>right</code>, <code>left</code>, <code>up</code>, or <code>down</code></li> <li>One of <code>tab</code>, <code>backspace</code>, <code>,</code>, <code>.</code>, or <code>-</code> </li> </ul> </li> <li>Bind <code>calva.runCustomREPLCommand</code> to a shortcut with whatever code you want to evaluate in <code>args</code> key. You have access to the substitution variables here as well.</li> <li>Bind <code>calva.runCustomREPLCommand</code> to a keyboard shortcut referencing the <code>key</code> of one of your <code>calva.customREPLCommandSnippets</code>. (If not using any of the <code>key</code>s mentioned in 1.)</li> </ol>","title":"Binding keyboard shortcuts"},{"boost":4,"location":"custom-commands/#custom-repl-hover-snippets","text":"<p>Calva supports custom snippets that will display their result inside the tooltip. They will only work when connected to a repl, since they eval code in it. This is mostly useful for tooling authors that want to integrate with calva. Be careful with these, since they will be executed anytime Calva displays a tooltip. So they should be fast and probably not have any side effects.</p> <p>The hover snippets accept the same inputs as the Custom REPL Commands, except for the hotkey:</p> <pre><code>    \"calva.customREPLHoverSnippets\": [\n        {\n            \"name\": \"eval text on hover\",\n            \"repl\": \"clj\",\n            \"ns\": \"example.app\",\n            \"snippet\": \"(str \\\"$hover-text\\\")\"\n        }\n    ]\n</code></pre> <p>With this setting anything the mouse is over will also be shown inside its tooltip. There are now also <code>hover-</code> versions of most substitutions. Those currently only work inside the hover snippets.</p>","title":"Custom REPL hover snippets"},{"boost":4,"location":"custom-commands/#configedn","text":"<p>Your project can have a <code>.calva/config.edn</code> file that holds a map with calva configs. Currently only <code>:customREPLCommandSnippets</code> and <code>:customREPLHoverSnippets</code> get loaded. These will not get synced through vscode settings sync.</p>","title":"config.edn"},{"boost":4,"location":"custom-commands/#snippets-inside-deps","text":"<p>A new experimental feature lets library authors ship snippets inside their jar files. These accept the same options as above but should be placed in \"resources/calva.exports/config.edn\" inside the jar.</p> <pre><code>{:customREPLCommandSnippets\n [{:name \"edn test\"\n   :key \"a\"\n   :snippet \"($current-form)\"}]\n :customREPLHoverSnippets\n [{:name \"edn hover\"\n   :snippet \"(str \\\"$hover-tex\\\")\"}\n  {:name \"edn hover show val\"\n   :snippet \"(str \\\"### EDN show val\\n```clojure\\n\\\" (pr-str (eval (symbol (str \\\"$ns\\\" \\\"/\\\" \\\"$hover-top-level-defined-symbol\\\")))) \\\"\\n```\\\")\"}]}\n</code></pre>","title":"Snippets inside deps"},{"location":"customizing/","text":"<p>Don't like the defaults? On this page we can collect some of the customizations that people have done, and maybe write a thing or two about it some day.</p> <p>Tip for VS Code newcomers: The search box in Settings is your friend. Also, some Calva settings are more complex than the Settings UI can handle. VS Code will then show you a link to <code>settings.json</code>. And VS Code's built-in <code>json</code> extension is awesome. To add settings for Calva's Pretty Printing, for example, search for \u201dprettyprint\u201d in VS Code Settings and follow the link to <code>settings.json</code>. Start typing \u201dcalvapretty\u201d until auto-complete suggests <code>calva.prettyPrintingOptions</code>. Press ENTER and VS Code will fill in these defaults:</p> <pre><code>    \"calva.prettyPrintingOptions\": {\n        \"enabled\": true,\n        \"printEngine\": \"pprint\",\n        \"width\": 40\n    },\n</code></pre>","title":"Customizing Calva"},{"location":"customizing/#clojure-defaults","text":"<p>Calva sets some VS Code settings for all Clojure files. Some of these are needed for Calva to function correctly, which should not be tampered with unless you really know what you are doing, and some of them are convenient defaults. If you add a setting to your <code>settings.json</code> and accept the snippet help you get when you type <code>\"[clojure]\"</code>, you will get the Calva defaults pasted:</p> <pre><code>    \"[clojure]\": {\n        \"editor.wordSeparators\": \"\\t ()\\\"':,;~@#$%^&amp;{}[]`\",\n        \"editor.autoClosingBrackets\": \"always\",\n        \"editor.autoClosingQuotes\": \"always\",\n        \"editor.formatOnType\": true,\n        \"editor.autoIndent\": \"full\",\n        \"editor.formatOnPaste\": true,\n        \"files.trimTrailingWhitespace\": false,\n        \"editor.matchBrackets\": \"never\",\n        \"editor.renderIndentGuides\": false,\n        \"editor.parameterHints.enabled\": false\n    }\n</code></pre>  <p>Note</p> <p>The above <code>editor.wordSeparators</code> setting establish Clojure word boundaries. E.g <code>-</code> is considered to be part of words. This affects what happens when double-clicking symbols and other things. If you want to include <code>-</code> or something else as a word boundary, just add it to the setting.</p>","title":"Clojure Defaults"},{"location":"customizing/#pretty-printing","text":"<p>Calva's pretty printing mode can be configured a bit. See Pretty Printing.</p>","title":"Pretty Printing"},{"location":"customizing/#calva-highlight","text":"<p>This is highly customizable. See Syntax highlighting</p>","title":"Calva Highlight"},{"location":"customizing/#automatic-parameter-hints-poppup","text":"<p>Calva has helpful parameter hints to aid when typing function calls. They look like so:</p> <p></p> <p>To have the hints automatically pop up when you are typing, set <code>editor.parameterHints.enabled</code> to <code>true</code> in the above <code>[clojure]</code> scoped setting. (To call them up on demand the default VS Code keybindings are <code>cmd+shift+space</code> on Mac and <code>ctrl+shift+space</code> on Linux/Windows.)</p>","title":"Automatic Parameter Hints Poppup"},{"location":"customizing/#code-formatting","text":"<p>See Formatting for information on how to configure this.</p>","title":"Code Formatting"},{"location":"customizing/#jack-in-and-connect-sequences","text":"<p>Jack-in and Connect are very customizable through Custom Connect Sequences.</p>","title":"Jack-in and Connect Sequences"},{"location":"customizing/#jack-in-dependency-versions","text":"<p>Calva Jack-in injects the following dependencies in order for the REPL session to support IDE features</p> <ul> <li>nrepl: nREPL is the wonderful piece of software that gives Calva a structured and extensible connection to the REPL in your Clojure and ClojureScript projects.</li> <li>cider-nrepl: cider-nrepl is middleware that extends the nREPL connection with all sorts of nice stuff that Calva uses to give you a delightful IDE experience.</li> <li>cider/piggieback: Piggieback is used to create nREPL sessions in ClojureScript projects. (Not with shadow-cljs projects though, which provides its own middleware for this.)</li> </ul> <p>The versions used are configurable via the VS Code settings <code>calva.jackInDependencyVersions</code>.</p>","title":"Jack-in Dependency Versions"},{"location":"customizing/#key-bindings","text":"<p>Most of Calva's commands have default keybindings. They are only defaults, though, and you can change keybindings as you wish. To facilitate precision in binding keys Calva keeps some when clause contexts updated. </p>","title":"Key bindings"},{"location":"customizing/#when-clause-contexts","text":"<p>The following contexts are available with Calva:</p> <ul> <li><code>calva:keybindingsEnabled</code>: a master switch that you find in the settings</li> <li><code>paredit:keyMap</code>: <code>strict</code>, <code>original</code>, or <code>none</code> from the corresponding Calva setting (see Paredit)</li> <li><code>calva:connected</code>: <code>true</code> when Calva is connected to a REPL (there is also <code>calva:connecting</code> || <code>calva:launching</code>)</li> <li><code>calva:outputWindowActive</code>: <code>true</code> when the Output/REPL window has input focus</li> <li><code>calva:replHistoryCommandsActive</code>: <code>true</code> when the cursor is in the Output/REPL window at the top level after the last prompt</li> <li><code>calva:outputWindowSubmitOnEnter</code>: <code>true</code> when the cursor is adjacent after the last top level form in the Output/REPL window</li> <li><code>calva:cursorInString</code>: <code>true</code> when the cursor/caret is in a string or a regexp</li> <li><code>calva:cursorInComment</code>: <code>true</code> when the cursor is in, or adjacent to a line comment</li> <li><code>calva:cursorBeforeComment</code>: <code>true</code> when the cursor is adjacent before a line comment</li> <li><code>calva:cursorAfterComment</code>: <code>true</code> when the cursor is adjacent after a line comment</li> <li><code>calva:cursorAtStartOfLine</code>: <code>true</code> when the cursor is at the start of a line including any leading whitespace</li> <li><code>calva:cursorAtEndOfLine</code>: <code>true</code> when the cursor is at the end of a line including any trailing whitespace</li> <li><code>calva:showReplUi</code>: <code>false</code> when Calva's REPL UI is disabled through the corresponding setting</li> </ul>","title":"When Clause Contexts"},{"location":"customizing/#some-custom-bindings","text":"<p>Here is a collection of custom keybindings from here and there.</p> <ul> <li>Replace all Calva <code>ctrl+alt+...</code> key bindings with <code>ctrl+shift+...</code>, for keyboards lacking <code>alt</code> key: this gist</li> <li>Replace the default Calva \u201dprefix\u201d, <code>ctrl+alt+c</code> to just <code>alt+v</code>: WebWItch's keybindings.json (Please note, that <code>alt+v</code> does not work for some locales, but for when it works it is much less clunky than the default prefix).</li> <li>Here the Calva key is switched for <code>ctrl+,</code>: manas_marthi's keybindings</li> <li>Keybindings for Emacs users</li> </ul> <p>Are you a vim extension user? See: Using with VIM extension.</p>","title":"Some Custom Bindings"},{"location":"customizing/#move-by-word","text":"<p>By default Calva changes the move-by-word key bindings to move by sexpr/form when the cursor is in structural Clojure code. Within line comments the editor default word movement is active.</p> <p>If you want the VS Code default word movement shortcuts, use these settings:</p> <pre><code>    {\n        \"key\": \"ctrl+right\",\n        \"win\": \"ctrl+right\",\n        \"mac\": \"alt+right\",\n        \"command\": \"cursorWordRight\"\n    },\n    {\n        \"key\": \"ctrl+left\",\n        \"win\": \"ctrl+left\",\n        \"mac\": \"alt+left\",\n        \"command\": \"cursorWordLeft\"\n    },\n    {\n        \"key\": \"ctrl+right\",\n        \"mac\": \"ctrl+right\",\n        \"win\": \"alt+right\",\n        \"command\": \"paredit.forwardSexp\",\n        \"when\": \"calva:keybindingsEnabled &amp;&amp; editorTextFocus &amp;&amp; editorLangId == 'clojure' &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+left\",\n        \"mac\": \"ctrl+left\",\n        \"win\": \"alt+left\",\n        \"command\": \"paredit.backwardSexp\",\n        \"when\": \"calva:keybindingsEnabled &amp;&amp; editorTextFocus &amp;&amp; editorLangId == 'clojure' &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    }\n</code></pre> <p>Use it as an inspiration for customizing things to your own liking. \ud83d\ude04</p>","title":"Move by word"},{"location":"customizing/#wrap-using-like-cursive","text":"<p>Something I use in IntelliJ/Cursive is the ability to select an expression and hit one of <code>(</code>, <code>[</code>, <code>{</code> to wrap it. And after wrapping the expression I don't want the selection anymore, so if I were wrapping <code>(foo)</code> then I would want to get <code>( | (foo))</code> where <code>|</code> would be my cursor.</p> <p>Here's how you can make this work with Calva Paredit: Update all of the <code>Paredit: Wrap Around ...</code> commands so that their respective shortcuts are the wrappers themselves and update the <code>when</code> clause to include <code>editorHasSelection</code> (otherwise when you open a paren the next expression would get slurped in).</p> <p>The change would look like this in your <code>keybindings.json</code>:</p> <pre><code>    {\n        \"key\": \"shift+9\",\n        \"command\": \"paredit.wrapAroundParens\",\n        \"when\": \"editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; !editorReadOnly &amp;&amp; editorLangId =~ /clojure|scheme|lisp/ &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"[\",\n        \"command\": \"paredit.wrapAroundSquare\",\n        \"when\": \"editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; !editorReadOnly &amp;&amp; editorLangId =~ /clojure|scheme|lisp/ &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"shift+[\",\n        \"command\": \"paredit.wrapAroundCurly\",\n        \"when\": \"editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; !editorReadOnly &amp;&amp; editorLangId =~ /clojure|scheme|lisp/ &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    }\n</code></pre>","title":"Wrap using <code>(</code>, <code>[</code>, <code>{</code> (like Cursive)"},{"location":"debugger/","text":"<p>Calva comes with a powerful expression-based debugger, inspired by Cider's debugger, and using the same underlying library, cider-nrepl. We hope you love it!</p> <p></p>  <p>Note</p> <p>The debugger currently does not support ClojureScript. Calva's debugger utilizes cider-nrepl for debugging. See this Cider issue for more information.</p>","title":"Debugger"},{"location":"debugger/#features","text":"","title":"Features"},{"location":"debugger/#current","text":"<ul> <li>Instrument functions for debugging with <code>ctrl+alt+c i</code></li> <li>Instrument a function manually with <code>#dbg</code> (as opposed to the above command)</li> <li>Set individual breakpoints with <code>#break</code></li> <li>Continue to next breakpoint</li> <li>Step over form</li> <li>Step into form</li> <li>Step out of form</li> <li>Evaluate code in the debug context</li> <li>See variable values in the debugger side pane</li> <li>See variable values on hover in the editor</li> </ul>","title":"Current"},{"location":"debugger/#future-goals","text":"<ul> <li>See structured variables in the debugger side pane (currently maps and collections are just shown as strings)</li> <li>Inject values into the debug context</li> <li>Trace: continue, printing expressions and their values</li> </ul>","title":"Future goals"},{"location":"debugger/#dependencies","text":"<p>The debugger itself relies pretty heavily on cider-nrepl, as do other parts of Calva. This library is loaded as a dependency when you use Calva Jack-in. If you are not using Calva Jack-in, you can add these dependencies in your project definition or user profile. See the Calva Jack-in guide for more information.</p>","title":"Dependencies"},{"location":"debugger/#using-the-debugger","text":"<p>If you're new to Clojure or expression-based debuggers, this debugger may function differently than what you're used to. Instead of placing breakpoints in the side margin and then hitting F5 to start debugging, you instead use Clojure reader tags, <code>#break</code> and <code>#dbg</code>, to denote breakpoints anywhere in a Clojure form. When you evaluate a call to a function that has been evaluated with that reader tag, the debugger will start when execution reaches the first breakpoint. There's also a convenience command to instrument functions. Read below about both options.</p>  <p>Note</p> <p>The debugger is not configured via a <code>launch.json</code> file, and is not started in the same way as you may be used to when working with other languages in VS Code. The debugger is used by way of the REPL. If you are new to Clojure, please visit the Getting Started section of the documentation and get familiar with evaluating code using the REPL before using the debugger.</p>","title":"Using the Debugger"},{"location":"debugger/#instrumenting-a-function","text":"<p>You can instrument a top level function for debugging with <code>ctrl+alt+c i</code>. This places invisible breakpoints throughout the function where pausing makes sense. When you evaluate a call to this function, the debugger will start and execution will pause at the first breakpoint. Annotations show the value of the form at the cursor.</p> <p>A border is placed around the definition of the instrumented function and its references to show that it's instrumented. You can remove instrumentation by evaluating the function again normally, such as with <code>alt+enter</code>.</p> <p></p>","title":"Instrumenting a Function"},{"location":"debugger/#setting-breakpoints-with-break","text":"<p>You can insert a breakpoint manually into any code by placing a <code>#break</code> in front of the form where you want execution to pause, and then evaluating the top level form with <code>alt+enter</code>. When you evaluate a call to this code the VS Code debugger will start, the cursor will move to right after the form that's preceded by <code>#break</code>, and the line will be highlighted to show execution is paused there.</p> <p></p>  <p>Note</p> <p>Code will be executed up to and including the form after the breakpoint.</p>","title":"Setting Breakpoints with <code>#break</code>"},{"location":"debugger/#conditional-breakpoints","text":"<p>You can set conditional breakpoints by adding metadata before the form that the <code>#break</code> applies to.</p> <pre><code>(defn print-nums [n]\n  (dotimes [i n]\n    #break ^{:break/when (= i 7)} ;; This breakpoint will only be hit when i equals 7\n    (prn i)))\n</code></pre>","title":"Conditional Breakpoints"},{"location":"debugger/#instrumenting-a-form-with-dbg","text":"<p>Adding <code>#dbg</code> before a form then evaluating the form with <code>alt+enter</code> will instrument the form. This has the same effect as using the instrument command.</p> <p></p> <p></p>","title":"Instrumenting a Form with <code>#dbg</code>"},{"location":"debugger/#evaluating-code-in-the-paused-context","text":"<p>When execution is paused at a breakpoint, you can evaluate code in that context. This can be done in the editor or in the REPL window, as usual.</p> <p></p>","title":"Evaluating Code in the Paused Context"},{"location":"debugger/#viewing-variable-values","text":"<p>While debugging, you can view the values of variables in VS Code's debugger side pane. You can also view values by hovering over the variables in the editor. Currently, values for collections and maps are shown as strings, but we plan to make them structured in the future. For now, if you want to see the value of a large structured variable, you can evaluate the variable from the editor or from the REPL window.</p> <p></p>","title":"Viewing Variable Values"},{"location":"debugger/#viewing-the-call-stack","text":"<p>While debugging, you can view the call stack in VS Code's call stack side pane. Clicking the stack frames will show the related line of code in an editor.</p>  <p>Note</p> <p>You may only see one stack frame in the call stack side pane, as the change for adding additional frames was rolled back due to an issue. You can follow the change for this at #1150.</p>  <p></p>","title":"Viewing the Call Stack"},{"location":"debugger/#stepping-commands","text":"<p>You can use VS Code's debugger UI to advance execution while debugging.</p> <p></p>  <p>Note</p> <p>Clicking restart does nothing, since this functionality does not make sense for our debugger.</p>  <ul> <li>Continue - Continues without stopping for the current breakpoint</li> <li>Step over - Continues to the next breakpoint</li> <li>Step in - Steps in to the function about to be called. If the next breakpoint is not around a function call, does the same as next. Note that not all functions can be stepped in to - only normal functions stored in vars, for which cider-nrepl can find the source. You cannot currently step in to multimethods, protocol functions, or functions in clojure.core (although multimethods and protocols can be instrumented manually).</li> <li>Step out - Steps to the next breakpoint that is outside of the current sexp</li> <li>Restart - Does nothing. To restart debugging, you can hit disconnect or continue execution through the final result, then re-evaluate the expression that started the debugger.</li> <li>Disconnect - Disconnects the debugger</li> </ul>","title":"Stepping Commands"},{"location":"debugger/#caveats","text":"","title":"Caveats"},{"location":"debugger/#breakpoints-in-looprecur","text":"<p>One construct where the debugger is limited is <code>loop</code>/<code>recur</code>. As recur always has to appear in a tail-position inside a <code>loop</code> or a <code>fn</code> and the debugger uses macros to interleave breakpoints in the forms, it might happen that a <code>recur</code> no longer appears in a tail position. In that case we have to avoid setting up the breakpoint. An example of such a case is:</p> <pre><code>(loop [i 0]\n  #break\n  (when (&lt; i 10)\n    (println i)\n    (recur (inc i))))\n</code></pre> <p>Here the breakpoint is exactly in front of a form that contains as its last expression a <code>recur</code> which is wrapped in a loop. This breakpoint has no effect. This does not mean you cannot use the debugger with <code>loop</code>, it just means you have to set your debug statements more carefully.</p>","title":"Breakpoints in loop/recur"},{"location":"debugger/#loading-the-file-and-eval-on-save","text":"<p>When you load a file, any breakpoints that were previously set in functions will be unset. If you have the \"Eval On Save\" setting enabled, your file is also loaded with each save, therefore saving the file will remove breakpoints previously set.</p>","title":"Loading the File and \"Eval On Save\""},{"location":"debugger/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"debugger/#debugger-hangs-when-stepping-over-infinite-seqs","text":"<p>This is because the debugger tries to evaluate the form when it's stepped over, and if <code>clojure.core/*print-length*</code> is set to <code>nil</code> as it is by default, evaluation will never complete. If you want to debug a form with an infinite seq, make sure to set <code>*print-length*</code> beforehand. For example:</p> <pre><code>(set! *print-length* 3)\n;; Or, to be more precise\n(set! clojure.core/*print-length* 3)\n</code></pre> <p>Calva does not set this for you during debug mode, instead leaving it up to you to decide the value.</p>","title":"Debugger hangs when stepping over infinite seqs"},{"location":"debugger/#my-breakpoint-isnt-being-hit","text":"<p>It's likely that your breakpoint is in a place that cider-nrepl does not see as an appropriate place to break execution. For example, if you put a breakpoint before a literal number, it will not be hit, because there's no need to show the value of a literal.</p> <pre><code>(defn simple [x]\n  (+ 1 #break 1)) ;; This breakpoint will not be hit\n</code></pre> <p>Another possible issue is that you're loading the file again after setting breakpoints, which unsets them. See Loading the File and \"Eval On Save\" under Caveats.</p>","title":"My breakpoint isn't being hit"},{"location":"debugger/#my-breakpoint-in-a-test-isnt-being-hit","text":"<p>If you're using the test commands like \"Run current test\" to run your tests, breakpoints will not be hit. This is because Calva loads the file before running the tests to make sure the latest version of test code is being run, and when the file is loaded, breakpoints are unset.</p> <p>If you want a breakpoint to work within the test, evaluate the test form with a breakpoint tag in it, then call the test directly.</p> <p></p>","title":"My breakpoint in a test isn't being hit"},{"location":"debugger/#no-reader-function-for-tag-error","text":"<p>If you get an error like this, it's likely that you connected to a REPL instead of jacking in, and you don't have the proper dependencies loaded in your REPL. You can run the command \"Copy Jack-in Command to Clipboard\" to see what command would be run if you jacked in.</p> <p>Most importantly, make sure you have <code>cider/cider-nrepl</code> as a dependency, and <code>cider.nrepl/cider-middleware</code> as middleware loaded in your REPL. For example, this is a jack-in command for a deps.edn project:</p> <pre><code>clojure -Sdeps '{:deps {nrepl/nrepl {:mvn/version,\"0.8.3\"},cider/cider-nrepl {:mvn/version,\"0.25.8\"}}}' -m nrepl.cmdline --middleware \"[cider.nrepl/cider-middleware]\"\n</code></pre>","title":"\"No reader function for tag\" error"},{"location":"debugger/#passing-options-to-the-repl-jvm","text":"<p>There are times when Clojure debugging tools are not enough or not right for the job. This is usually true when use an (open source) Java library and you want to set some breakpoints in Java code. For those cases and others, you need to start the JVM in debug mode.</p> <p>Typical use cases:</p> <ul> <li>Change Java logger configuration for the REPL via java system properties: e.g <code>-Dorg.slf4j.simpleLogger.defaultLogLevel=TRACE</code></li> <li>Enable JVM debugger, change VM memory size, etc.</li> </ul> <p>Calva supports passing environment variables via <code>jackInEnv</code>. You can set that option inside VSCode <code>settings.json</code> file.</p> <p>You can configure global <code>settings.json</code> file or a project wide version, inside <code>&lt;project-root&gt;/.vscode/settings.json</code>.</p> <p>Configuring the global option will impact all projects you work on using Calva, so be aware. See the documentation for <code>settings.json</code> for more information.</p> <p>The bellow snippet configures <code>JAVA_TOOL_OPTIONS</code> environment variable. We configure slf4j-simple logging level via a Java system property (<code>-D</code>) and JVM specific options (<code>-X</code>).</p> <p>NOTE: You can of course pass other env variables here.</p> <p>.vscode/settings.json</p> <pre><code>{\n    \"calva.jackInEnv\": {\n        \"JAVA_TOOL_OPTIONS\": \"${env:JAVA_TOOL_OPTIONS} -Dorg.slf4j.simpleLogger.defaultLogLevel=TRACE -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7896\"\n    }\n}\n</code></pre> <p>Once you saved the file, the next time you <code>Jack in</code> the project, this variable is read by the JVM and the configuration is applied accordingly.</p> <p>You should see something like the message below in the Calva terminal output window:</p> <pre><code>clojure -Sdeps '{:deps {nrepl/nrepl {:mvn/version,\"0.8.3\"},cider/cider-nrepl {:mvn/version,\"0.26.0\"}}}' -A:debug -m nrepl.cmdline --middleware \"[cider.nrepl/cider-middleware]\"\nPicked up JAVA_TOOL_OPTIONS:  -Dorg.slf4j.simpleLogger.defaultLogLevel=TRACE -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7896\nListening for transport dt_socket at address: 7896\nnREPL server started on port 46691 on host localhost - nrepl://localhost:46691\n</code></pre>","title":"Passing options to the REPL JVM"},{"location":"emacs-keybindings/","text":"<p>Some keybindings to make it easier for Emacs users <pre><code>[\n    {\n        \"key\": \"ctrl+cmd+b\",\n        \"command\": \"paredit.backwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+alt+left\",\n        \"command\": \"-paredit.backwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"shift+cmd+]\",\n        \"command\": \"-workbench.action.nextEditor\"\n    },\n    {\n        \"key\": \"ctrl+shift+]\",\n        \"command\": \"paredit.barfSexpBackward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+shift+right\",\n        \"command\": \"-paredit.barfSexpBackward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+shift+[\",\n        \"command\": \"paredit.barfSexpForward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+left\",\n        \"command\": \"-paredit.barfSexpForward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+cmd+f\",\n        \"command\": \"paredit.forwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+alt+right\",\n        \"command\": \"-paredit.forwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+cmd+f\",\n        \"command\": \"-workbench.action.toggleFullScreen\"\n    },\n    {\n        \"key\": \"ctrl+shift+backspace\",\n        \"command\": \"-paredit.killSexpForward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"shift+cmd+k\",\n        \"command\": \"-editor.action.deleteLines\",\n        \"when\": \"textInputFocus &amp;&amp; !editorReadonly\"\n    },\n    {\n        \"key\": \"ctrl+shift+0\",\n        \"command\": \"paredit.slurpSexpForward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+right\",\n        \"command\": \"-paredit.slurpSexpForward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+shift+9\",\n        \"command\": \"paredit.slurpSexpBackward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+shift+left\",\n        \"command\": \"-paredit.slurpSexpBackward\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+c ctrl+c\",\n        \"command\": \"calva.evaluateCurrentTopLevelForm\",\n        \"when\": \"calva:activated\"\n    },\n    {\n        \"key\": \"ctrl+alt+c space\",\n        \"command\": \"-calva.evaluateCurrentTopLevelForm\",\n        \"when\": \"calva:activated\"\n    },\n    {\n        \"key\": \"ctrl+x ctrl+e\",\n        \"command\": \"calva.evalCurrentTopLevelFormInREPLWindow\",\n        \"when\": \"calva:activated\"\n    },\n    {\n        \"key\": \"ctrl+alt+c ctrl+alt+space\",\n        \"command\": \"-calva.evalCurrentTopLevelFormInREPLWindow\",\n        \"when\": \"calva:activated\"\n    },\n    {\n        \"key\": \"ctrl+x ctrl+s\",\n        \"command\": \"workbench.action.files.save\"\n    },\n    {\n        \"key\": \"cmd+s\",\n        \"command\": \"-workbench.action.files.save\"\n    },\n    {\n        \"key\": \"cmd+s\",\n        \"command\": \"paredit.spliceSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+alt+s\",\n        \"command\": \"-paredit.spliceSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+cmd+k\",\n        \"command\": \"paredit.cutForwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+shift+x right\",\n        \"command\": \"-paredit.cutForwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+cmd+backspace\",\n        \"command\": \"paredit.cutBackwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+shift+x left\",\n        \"command\": \"-paredit.cutBackwardSexp\",\n        \"when\": \"calva:activated &amp;&amp; calva:pareditValid &amp;&amp; paredit:keyMap =~ /original|strict/\"\n    },\n    {\n        \"key\": \"ctrl+1\",\n        \"command\": \"-workbench.action.openEditorAtIndex1\"\n    },\n    {\n        \"key\": \"ctrl+1\",\n        \"command\": \"editor.action.quickFix\",\n        \"when\": \"editorHasCodeActionsProvider &amp;&amp; editorTextFocus &amp;&amp; !editorReadonly\"\n    },\n    {\n        \"key\": \"cmd+.\",\n        \"command\": \"-editor.action.quickFix\",\n        \"when\": \"editorHasCodeActionsProvider &amp;&amp; editorTextFocus &amp;&amp; !editorReadonly\"\n    },\n    {\n        \"key\": \"cmd+.\",\n        \"command\": \"editor.action.revealDefinition\",\n        \"when\": \"editorHasDefinitionProvider &amp;&amp; editorTextFocus &amp;&amp; !isInEmbeddedEditor\"\n    },\n    {\n        \"key\": \"f12\",\n        \"command\": \"-editor.action.revealDefinition\",\n        \"when\": \"editorHasDefinitionProvider &amp;&amp; editorTextFocus &amp;&amp; !isInEmbeddedEditor\"\n    }\n]\n</code></pre></p>","title":"Emacs Keybindings"},{"boost":7,"location":"eval-tips/","text":"<p>Calva tries to make it easy to evaluate code, supporting interactive development. The fastest path to learning about it is to use the Fire up the Getting Started REPL command, which you can learn more about in the Getting Started section.</p> <p>NB: The below assumes you have read about Finding Calva Commands and Shortcuts.</p>","title":"Code Evaluation"},{"boost":7,"location":"eval-tips/#evaluation-in-a-file-editor","text":"<p>Calva has many commands for evaluating forms, including the current form and the current top-level form.</p> <p>Some of the commands also let you choose what should happen with the results:</p> <ol> <li>Inline. This will display the results (or some of it, if it is long) inline in the editor.<ul> <li>This also creates a hover pane including the full results and a button which will copy the results to the clipboard.</li> <li>There is also a command for copying the last result to the clipboard.</li> <li>The full results are always available in the output window.<ul> <li>There is a command for showing the output window, allowing for a workflow where you either generally have it closed, or have it as one of the tabs in the same editor group as the files you are working with.</li> </ul> </li> </ul> </li> <li>To comments. This will add the results as line comments below the current line.</li> <li>Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results.</li> </ol>","title":"Evaluation in a File Editor"},{"boost":7,"location":"eval-tips/#wait-current-form-top-level-form","text":"<p>These are important concepts in Calva in order for you to create your most effective workflow. This video explains it a bit:</p>","title":"Wait, Current Form? Top-level Form?"},{"boost":7,"location":"eval-tips/#current-form","text":"<p>Default shortcut for evaluating the current form: <code>ctrl+enter</code>.</p> <p>The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form, <code>ctrl+alt+c s</code>, to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides). Generally the current form is determined like so:</p> <ol> <li>If text is selected, then that text</li> <li>If the cursor is \u201din\u201d a symbol, then that symbol     <pre><code>foob|ar ; foobar\n</code></pre></li> <li>If the cursor is adjacent to a form (a symbol or a list of some kind), then that form     <pre><code>(foo bar |(baz)) ; (baz)\n</code></pre></li> <li>If the cursor is between to forms, then the left side form     <pre><code>(foo bar | (baz)) ; bar\n</code></pre></li> <li>If the cursor is before the first form of a line, then that form     <pre><code>(foo\n| bar (baz)) ; bar\n</code></pre></li> </ol>","title":"Current Form"},{"boost":7,"location":"eval-tips/#current-top-level-form","text":"<p>Default shortcut for evaluating the current top level form: <code>alt+enter</code>.</p> <p>The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find <code>def</code> and <code>defn</code> (and <code>defwhatever</code>) forms at the top level, which also is one major intended use for evaluating top level form: to define and redefine variables. However, Calva does not check the contents of the form in order to determine it as a top-level forms: all forms not enclosed in any other form are top level forms.</p> <p>An \u201dexception\u201d is introduced by the <code>comment</code> form. It will create a new top level context, so that any forms immediately inside a <code>(comment ...)</code> form will be considered top-level by Calva. This is to support a workflow with what is often referred to the Rich Comments.</p> <p>At the top level the selection of which form is the current top level form follows the same rules as those for the current form.</p>","title":"Current Top-level Form"},{"boost":7,"location":"eval-tips/#evaluate-to-cursor","text":"<p>There is also a command for evaluating the text from the start of the current list to where the cursor is. Convenient for checking intermediate results in thread or <code>doto</code>, or similar pipelines. The cursor is right behind <code>:d</code> in this form:</p> <pre><code>  (-&gt;&gt; [1 1 2 3 5 8 13 21]\n       (partition 2)\n       (zipmap [:a :b :c :d])\n       :d| ; =&gt; (13 21)\n       (apply -)\n       (Math/abs))\n</code></pre> <p>The default shortcut for this command is <code>ctrl+alt+enter</code>.</p>","title":"Evaluate to Cursor"},{"boost":7,"location":"eval-tips/#evaluate-top-level-form-to-cursor","text":"<p>This command has a default shortcut keybinding of <code>shift+alt+enter</code>. It will create a form from the start of the current top level form, up to the cursor, then fold the form, closing all brackets, and this will then be evaluated. Good for examining code blocks up to a certain point.</p> <p>Take this example and paste it in a file loaded into the REPL, then place the cursor in front of each line comment and try the command.</p> <pre><code>(comment\n (do\n   (def colt-express\n     {:name \"Colt Express\"\n      :categories [\"Family\"\n                   \"Strategy\"]\n      :play-time 40\n      :ratings {:pez 5.0\n                :kat 5.0\n                :wiw 5.0   ; 1, then eval `colt-express`\n                :vig 3.0\n                :rex 5.0\n                :lun 4.0}})\n\n   (defn average [coll]\n     (/ (apply + coll) (count coll)))\n\n   (let [foo-express (-&gt; colt-express\n                         (assoc :name \"Foo Express\")\n                         (assoc-in [:ratings :lyr] 5.0)\n                         (update-in [:ratings :vig] inc))]\n     (-&gt;&gt; foo-express   ; 2\n          :ratings      ; 3\n          vals          ; 4\n          average       ; 5\n          ))))\n</code></pre>","title":"Evaluate Top Level Form to Cursor"},{"boost":7,"location":"eval-tips/#evaluate-enclosing-form","text":"<p>The default keyboard shortcut for evaluating the current enclosing form (the list the cursor is in) is <code>ctrl+shift+enter</code>.</p> <pre><code>(let [foo :bar]\n  (when false (str| foo))) ; =&gt; \":bar\"\n</code></pre>","title":"Evaluate Enclosing Form"},{"boost":7,"location":"eval-tips/#copying-the-inline-results","text":"<p>There is a command called Copy last evaluation results, <code>ctrl+alt+c ctrl+c</code>.</p> <p>This works regardless if you have evaluated in a file editor or in a REPL window.</p>","title":"Copying the inline results"},{"boost":7,"location":"eval-tips/#evaluating-in-a-repl-window","text":"<p>Since the REPL Window is mostly just a regular file, things work pretty similar at the REPL prompt. You use <code>alt+enter</code> to evaluate. Selecting the current form (default key binding <code>ctrl+w</code> on Mac and <code>shift+alt+right</code> on Windows and Linux) after evaluating will select the result.</p>","title":"Evaluating in a REPL window"},{"boost":7,"location":"evaluation/","text":"<p>Calva tries to make it easy to evaluate code, supporting interactive development. The fastest path to learning about it is to use the Fire up the Getting Started REPL command, which you can learn more about in the Getting Started section.</p> <p>NB: The below assumes you have read about Finding Calva Commands and Shortcuts.</p>","title":"Code Evaluation"},{"boost":7,"location":"evaluation/#evaluation-in-a-file-editor","text":"<p>Calva has many commands for evaluating forms, including the current form and the current top-level form.</p> <p>Some of the commands also let you choose what should happen with the results:</p> <ol> <li>Inline. This will display the results (or some of it, if it is long) inline in the editor.<ul> <li>This also creates a hover pane including the full results and a button which will copy the results to the clipboard.</li> <li>There is also a command for copying the last result to the clipboard.</li> <li>The full results are always available in the output window.<ul> <li>There is a command for showing the output window, allowing for a workflow where you either generally have it closed, or have it as one of the tabs in the same editor group as the files you are working with.</li> </ul> </li> </ul> </li> <li>To comments. This will add the results as line comments below the current line.</li> <li>Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results.</li> </ol>","title":"Evaluation in a File Editor"},{"boost":7,"location":"evaluation/#wait-current-form-top-level-form","text":"<p>These are important concepts in Calva in order for you to create your most effective workflow. This video explains it a bit:</p>","title":"Wait, Current Form? Top-level Form?"},{"boost":7,"location":"evaluation/#current-form","text":"<p>Default shortcut for evaluating the current form: <code>ctrl+enter</code>.</p> <p>The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form, <code>ctrl+alt+c s</code>, to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides). Generally the current form is determined like so:</p> <ol> <li>If text is selected, then that text</li> <li>If the cursor is \u201din\u201d a symbol, then that symbol     <pre><code>foob|ar ; foobar\n</code></pre></li> <li>If the cursor is adjacent to a form (a symbol or a list of some kind), then that form     <pre><code>(foo bar |(baz)) ; (baz)\n</code></pre></li> <li>If the cursor is between to forms, then the left side form     <pre><code>(foo bar | (baz)) ; bar\n</code></pre></li> <li>If the cursor is before the first form of a line, then that form     <pre><code>(foo\n| bar (baz)) ; bar\n</code></pre></li> </ol>","title":"Current Form"},{"boost":7,"location":"evaluation/#current-top-level-form","text":"<p>Default shortcut for evaluating the current top level form: <code>alt+enter</code>.</p> <p>The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find <code>def</code> and <code>defn</code> (and <code>defwhatever</code>) forms at the top level, which also is one major intended use for evaluating top level form: to define and redefine variables. However, Calva does not check the contents of the form in order to determine it as a top-level forms: all forms not enclosed in any other form are top level forms.</p> <p>An \u201dexception\u201d is introduced by the <code>comment</code> form. It will create a new top level context, so that any forms immediately inside a <code>(comment ...)</code> form will be considered top-level by Calva. This is to support a workflow with what is often referred to the Rich Comments.</p> <p>At the top level the selection of which form is the current top level form follows the same rules as those for the current form.</p>","title":"Current Top-level Form"},{"boost":7,"location":"evaluation/#evaluate-to-cursor","text":"<p>There is also a command for evaluating the text from the start of the current list to where the cursor is. Convenient for checking intermediate results in thread or <code>doto</code>, or similar pipelines. The cursor is right behind <code>:d</code> in this form:</p> <pre><code>  (-&gt;&gt; [1 1 2 3 5 8 13 21]\n       (partition 2)\n       (zipmap [:a :b :c :d])\n       :d| ; =&gt; (13 21)\n       (apply -)\n       (Math/abs))\n</code></pre> <p>The default shortcut for this command is <code>ctrl+alt+enter</code>.</p>","title":"Evaluate to Cursor"},{"boost":7,"location":"evaluation/#evaluate-top-level-form-to-cursor","text":"<p>This command has a default shortcut keybinding of <code>shift+alt+enter</code>. It will create a form from the start of the current top level form, up to the cursor, then fold the form, closing all brackets, and this will then be evaluated. Good for examining code blocks up to a certain point.</p> <p>Take this example and paste it in a file loaded into the REPL, then place the cursor in front of each line comment and try the command.</p> <pre><code>(comment\n (do\n   (def colt-express\n     {:name \"Colt Express\"\n      :categories [\"Family\"\n                   \"Strategy\"]\n      :play-time 40\n      :ratings {:pez 5.0\n                :kat 5.0\n                :wiw 5.0   ; 1, then eval `colt-express`\n                :vig 3.0\n                :rex 5.0\n                :lun 4.0}})\n\n   (defn average [coll]\n     (/ (apply + coll) (count coll)))\n\n   (let [foo-express (-&gt; colt-express\n                         (assoc :name \"Foo Express\")\n                         (assoc-in [:ratings :lyr] 5.0)\n                         (update-in [:ratings :vig] inc))]\n     (-&gt;&gt; foo-express   ; 2\n          :ratings      ; 3\n          vals          ; 4\n          average       ; 5\n          ))))\n</code></pre>","title":"Evaluate Top Level Form to Cursor"},{"boost":7,"location":"evaluation/#evaluate-enclosing-form","text":"<p>The default keyboard shortcut for evaluating the current enclosing form (the list the cursor is in) is <code>ctrl+shift+enter</code>.</p> <pre><code>(let [foo :bar]\n  (when false (str| foo))) ; =&gt; \":bar\"\n</code></pre>","title":"Evaluate Enclosing Form"},{"boost":7,"location":"evaluation/#copying-the-inline-results","text":"<p>There is a command called Copy last evaluation results, <code>ctrl+alt+c ctrl+c</code>.</p> <p>This works regardless if you have evaluated in a file editor or in a REPL window.</p>","title":"Copying the inline results"},{"boost":7,"location":"evaluation/#evaluating-in-a-repl-window","text":"<p>Since the REPL Window is mostly just a regular file, things work pretty similar at the REPL prompt. You use <code>alt+enter</code> to evaluate. Selecting the current form (default key binding <code>ctrl+w</code> on Mac and <code>shift+alt+right</code> on Windows and Linux) after evaluating will select the result.</p>","title":"Evaluating in a REPL window"},{"location":"finding-commands/","text":"<p>Calva relies a lot on that VS Code makes it really easy to find commands by opening the command palette: <code>ctrl+shift+p</code> (Windows/Linux), <code>cmd+shift+p</code> (Mac), and then start typing some words (or parts of words) that you think might be in the command.</p> <p>To leverage this, all Calva commands are prefixed with <code>Calva</code>. As an example, say you want to find commands related to evaluating the top level form. Then you can do this:</p> <ol> <li>Open the command palette</li> <li>Type <code>calevtop</code></li> </ol> <p>VS Code will match <code>cal</code> to \u201dCalva\u201d, <code>ev</code> to \u201dEvaluate\u201d, and <code>top</code> to \u201dTop\u201d. It looks like so:</p> <p></p> <p>As you can see on the screenshot, VS Code will also reveal the keyboard shortcut for each command. My advice is to make it a habit to try to remember those shortcuts and use them for a more effective workflow.</p> <p>Now might be a good time to see Calva Top 10 Commands</p>","title":"Finding Calva Commands"},{"location":"finding-commands/#all-the-settings-and-commands","text":"<p>Did you know? There is a complete list of Calva settings and commands in the Contributions tab of the Calva entry in the Extensions pane in VS Code.</p> <p></p>","title":"All the Settings and Commands"},{"location":"finding-commands/#toggling-keyboard-shortcuts-onoff","text":"<p>The command <code>calva.toggleKeybindingsEnabled</code> can be used to quickly enable and disable (almost) all keyboard shortcuts. This allows you to quickly toggle between Calva keybindings and other keybindings which would otherwise not be available when Calva is enabled. This is particularly useful with the Paredit keyboard shortcuts, whose default shortcuts conflict with the default VS Code shortcuts for textual (non-structural) editing.</p> <p>By default it is not bound to a shortcut so as not to cause confusion by users unwittingly pressing it, but if this is something you'd like to use often, you may want to bind it to a shortcut.</p>","title":"Toggling Keyboard Shortcuts On/Off"},{"location":"formatting/","text":"<p>We have tried to make Calva's formatter so that it just works. It is enabled by default for Clojure files, and with the default configuration it mostly follows Bozhidar Batsov's Clojure Style Guide. Calva uses cljfmt for the formatting.</p>  <p>Tab formats the current surrounding form</p> <p>Calva's code formatter sets the default keybinding of its Format Current Form command to <code>tab</code>. Meaning that most often when things look a bit untidy, you can press <code>tab</code> to make things look pretty. Good to know, right? For performance reasons it only formats the current enclosing form, so sometimes you want to move the cursor up/out a form (<code>ctrl+up</code>) first. See The Paredit Guide for more on moving the cursor structurally through your code.</p>  <p>With the default settings, Calva's formatting behaves like so:</p> <ul> <li>indents as you type (when entering new lines)</li> <li>formats the current enclosing form when you hit <code>tab</code></li> <li>formats pasted code</li> <li>formats according to community standards</li> <li>formats the current form, aligning map keys and values, when you press <code>ctrl+alt+l</code></li> <li>formats <code>(comment ...)</code> forms special, see rich comments</li> </ul>  <p>Infer parens at will</p> <p>Calva has a command that will \u201dheal\u201d the bracket structure if it is correctly indented using Parinfer Infer parens. This command is default bound to <code>ctrl+alt+p i</code>.</p>  <p>Also: If you have Format on Save enabled in VS Code, it will be Calva doing the formatting for Clojure files.</p> <p>Calva's formatting is mostly about indenting, but it also (again, defaults):</p> <ul> <li>trims whitespace at the end of the line</li> <li>trims whitespace inside brackets<ul> <li>this also folds trailing brackets (a k a the paren trail) up on the same line</li> </ul> </li> <li>inserts whitespace between forms</li> </ul> <p>Not a fan of some default setting? The formatter is quite configurable.</p>","title":"Formatting"},{"location":"formatting/#format-current-form-command-variants","text":"<p>There are two special commands for formatting the current form:</p>","title":"Format current form command variants"},{"location":"formatting/#format-and-align-current-form","text":"<p>Aligns associative structures and bindings in two columns. See more below.</p>","title":"Format and Align Current Form"},{"location":"formatting/#format-current-form-and-trim-space-between-forms","text":"<p>This formats the text, and trims consecutive, non-indent, whitespace on a line to just one space. Something like:</p> <pre><code>(let [a    :b]\n(str \"foo\"     \"bar\" \"baz\"\n\"a\"    a))\n</code></pre> <p>Becomes:</p> <pre><code>(let [a :b]\n  (str \"foo\" \"bar\" \"baz\"\n       \"a\" a))\n</code></pre> <p>Basically, it behaves like if <code>:remove-multiple-non-indenting-spaces? true</code> was added to the <code>cljfmt</code> config. Which, in fact, is what happens. Calva merges that onto your cljfmt config when this command is used.</p>","title":"Format Current Form and trim space between forms"},{"location":"formatting/#configuration","text":"<p>You configure Calva's formatting using cljfmt's configuration EDN. This means that you can adjust the above mentioned defaults, including the indenting.</p> <p>This configuration can either be provided via a file or via clojure-lsp (see Clojure LSP Settings).</p>  Only use the clojure-lsp config option if you need it <p>The option to read formatting config from clojure-lsp is there to let teams where some members use clojure-lsp for formatting, share the config. To provide the settings via clojure-lsp, set <code>calva.fmt.configPath</code> to <code>CLOJURE-LSP</code> (case sensitive). However, there are limitations:</p> <ol> <li>There is no config hot reloading support (see below)</li> <li>clojure-lsp's cljfmt config is special in that it does not support regular Clojure syntax for regular expressions. This can make it difficult to run cljfmt as part of a CI pipline.</li> </ol>   No Leiningen config support <p>The cljfmt docs mention the <code>:cljfmt</code> config key of Leiningen projects. Calva does not yet read the config from there, so if your Leiningen project has such a configuration, you will need to copy it out into a file.</p>  <p>If providing settings via a file, start changing the Calva formatting defaults by pasting the following map into a file and save it. It could be somewhere in the project workspace (supporting hot reload), or some other place (no hot reload), depending on your requirements:</p> <pre><code>{:remove-surrounding-whitespace? true\n :remove-trailing-whitespace? true\n :remove-consecutive-blank-lines? false\n :insert-missing-whitespace? true\n :remove-multiple-non-indenting-spaces? false}\n</code></pre> <p>Then set <code>calva.fmt.configPath</code> to the path to this file. The path should either be absolute, or relative to the project root directory. So, if you named the file <code>.cljfmt.edn</code> and saved it in the root of the project, then this setting should be <code>.cljfmt.edn</code>.</p> <p>Since you are editing the file in Calva (you are, right?), you can quickly test how different settings affect the formatting. Try:</p> <ol> <li>Adding <code>:align-associative? true</code> to the config</li> <li>then save</li> <li>then hit <code>tab</code>, and see what happens.</li> </ol>  <code>:align-associative?</code> is experimental <p>This particular setting is experimental and known to cause trouble together with namespaced keywords. Consider using <code>ctrl+alt+l</code> instead of <code>tab</code> as your formatting command, instead of enabling this setting. See below for more info about this. See more below about this.</p>   <p>Hot reloding requirements</p> <p>The hot reloading of the config file only works for config files inside the project directory structure. And if you are providing the settings via clojure-lsp: no hot-reload for you.</p>","title":"Configuration"},{"location":"formatting/#about-aligning-associative-forms","text":"<p>Calva loooks in the config map for the key <code>:align-associative?</code> and if it is <code>true</code> it will use an old version of cljfmt which is patched with functionality for doing this alignment. Note, though:</p> <ul> <li>The implementation is a bit buggy and can do a bit crazy formatting on certain forms.</li> <li>The older version of cljfmt lacks updates for some new Clojure features and also some bugs fixed since the fork are not applied.</li> </ul> <p>You are hereby warned, and let us also remind you about the Format and Align Current Form command which lets you apply this formatting a bit more surgically, and on demand.</p> <p>This old version of cljfmt is inlined in the Calva repository along with the discontinued <code>rewrite-cljs</code> project. Regard it as frozen code. If you want Calva's formatter to have full support for newer Clojure constructs and the bugs in the alignment code fixed, contribute to cljfmt. See this issue for starting to collect context.</p>","title":"About aligning associative forms"},{"location":"formatting/#indentation-rules","text":"<p>The <code>cljfmt</code> indents are highly configurable. They, and the rest of the configuration options, are masterly detailed here.</p> <p>Calva is an extra good tool for experimenting with these settings. <code>cljfmt</code> doesn't care about keys in the map that it doesn't know about so you can sneak in test code there to quickly see how it will get formatted by certain rules. Try this, for instance:</p> <pre><code>{:remove-surrounding-whitespace? true\n :remove-trailing-whitespace? true\n :remove-consecutive-blank-lines? false\n :insert-missing-whitespace? false\n :indents ^:replace {#\"^\\w\" [[:inner 0]]}\n :test-code\n (concat [2]\n         (map #(inc (* % 2))\n              (filter #(aget sieved %)\n                      (range 1 hn))))}\n</code></pre> <p>Save, then hit <code>tab</code>, and the code should get formatted like so:</p> <pre><code> :test-code\n (concat [2]\n    (map #(inc (* % 2))\n      (filter #(aget sieved %)\n        (range 1 hn))))\n</code></pre> <p>That's somewhat similar to Nikita Prokopov's Better Clojure Formatting suggestion. (Please be aware that this setting might not be sufficient to get complete Tonsky Formatting, please share any settings you use to get full compliance.)</p>","title":"Indentation rules"},{"location":"formatting/#rich-comments","text":"<p>To encourage use of <code>(comment ...)</code> forms for development, the deafult settings give these forms get a special treatment when formatting. Use the <code>calva.fmt.keepCommentTrailParenOnOwnLine</code> setting to control this behaviour. See Rich Comments first.</p>","title":"Rich Comments"},{"boost":10,"location":"get-started-with-clojure/","text":"<p></p> <p>Welcome to a zero-install, interactive, guide to get you started with Clojure using:</p> <ul> <li>Clojure</li> <li>Gitpod (A development environment delivered via the web browser)</li> <li>VS Code (Or Gitpod Code, actually. In your web browser.)</li> <li>Calva (A Clojure extension to VS Code. The thing this site is about.)</li> <li>Calva's Getting Started REPL</li> </ul>  I have VS Code and Java <p>Clojure runs on the JVM. How to install it is a big topic. Since you have already done that, you can, if you want, choose to install Calva in your local VS Code and fire up the Getting Started REPL. By all means read this page anyway, you can just skip the Gitpod parts.</p> <p>Also: If you are using Windows your Java might have a bug that prevents things from working. Then you might want to defer fixing that and use the zero-install option first.</p>   Is Gitpod Code exactly as VS Code? <p>Almost! But, yeah, there are some difference between regular VS Code and Gitpod's ditto. Most of it doesn't matter, but finding the main menu can be a bit tricky: </p>","title":"Get Started with Clojure"},{"boost":10,"location":"get-started-with-clojure/#what-youll-learn","text":"<ul> <li>The basics of the Clojure language (at least the start of the basics)</li> <li>The basics of the ClojureScript language (we won't be using ClojureScript, but it is same language \ud83d\ude00)</li> <li>The basics of Calva (It's a bit as a side effect. You need it to learn Clojure this way, and by learning Clojure this way, Calva knowledge trickles in.)</li> <li>What is meant by, and some ways to perform, Interactive Programming (aka REPL Driven Development)</li> <li>Where to find Clojurians, i.e. folks who use Clojure and care about it (you will thus find help, the friendliest help you have ever seen a community provide)</li> </ul>  I am not convinced I should spend time on learning Clojure <p>Fair enough. We can recommend watching any or all of these videos to get excited about Clojure and the rather unique mood of development it offers:</p> <p></p> <ul> <li>Solving Problems the Clojure Way - with Rafal Dittwald (using JavaScript, so no new syntax to grasp to get the message)</li> <li>Developer Ergonomics with VS Code, Clojure, and ClojureScript - with Peter Str\u00f6mberg</li> <li>Clojure in VS Code Workflow using FizzBuzz - with Peter Str\u00f6mberg</li> </ul>","title":"What you'll learn"},{"boost":10,"location":"get-started-with-clojure/#what-you-wont-learn","text":"<ul> <li>How to install Clojure for your operating system of choice</li> <li>About various old and new build and dependency tools</li> <li>How to create projects and do real stuff</li> </ul>  Why won't I learn about this? <p>All in due time. \ud83d\ude04 It can be a bit confusing with all the things you find out about installing Clojure and creating projects when searching for information about it. We want you to relax about all that and just enjoy learning a bit about this fantastic programming language and the wonderful mode of development it offers.</p> <p>There is a lot of info about this out there already. And since you will learn where to find Clojurians, you will also find guidance. But we suggest do these things later. First, let's focus on having fun with Interactive Programming!</p>","title":"What you won't learn"},{"boost":10,"location":"get-started-with-clojure/#what-you-need","text":"<ul> <li>Curiosity about Clojure</li> <li>A web browser</li> </ul>  The browser ate my keyboard shortcuts! <p>There is always a competition for which system gets to catch keyboard shortcuts first. This worsens a bit when an application like VS Code runs in the web browser. Remember this if some shortcut/command doesn't work.</p> <p>On some machines, with some web browsers, some shortcuts are caught by the web browser and instead re-opening a closed tab or whatever. These have been observed:</p> <ul> <li>Undo (undoing something web browser related)</li> <li>Select the line (focusing the browser URL input)</li> <li>Open the command palette (opening a private browsing window. Looking at you Firefox.)</li> <li>Escape key shortcuts (are you using VIM bindings in your browser?)</li> </ul> <p>Sometimes the workaround is to redefine the shortcuts in VS Code, sometimes making your web browser stop catching the shortcut.</p>   I am new to VS Code <p>You might want to have a look at this Getting Started with VS Code video. (You can of course ignore the parts about installing for now.) Also, have this overview of the VS Code interface handy.</p>","title":"What you need"},{"boost":10,"location":"get-started-with-clojure/#how-it-works","text":"<ol> <li>You will open an instance of VS Code in a development environment running in the browser. The environment will have Java, Clojure tools, and Calva installed.<ul> <li>  Gitpod Sign-in    You will be asked to sign in to Gitpod, if you aren't already. You need to use the \u201dSign in with GitHub\u201d option. </li> </ul> </li> <li>Instructions will be automatically displayed (very brief such, because it is mainly about firing up the Getting Started REPL)</li> <li>The guides are a mix of prose (in Clojure line comments), Clojure code, and exercises. What's extra poetic is that you will use Calva and Clojure to learn Calva and Clojure.</li> </ol> <p>Use a desktop/laptop computer. Even if it actually works on the phone, it is far from convenient.</p> <p>It sometimes takes a while (several minutes) for the environment to initialize. Take some deep breaths and be patient. \ud83d\ude0e</p>","title":"How it works"},{"boost":10,"location":"get-started-with-clojure/#lets-go","text":"<p>Ready? Awesome. Click this button to start the guide in a new browser tab.</p>   https://gitpod.io/#https://github.com/PEZ/get-started-with-clojure   Stuck? Something not working? Or just unclear? <p>Please don't hesitate to reach out for help, should you get stuck. See below for where to find Clojurians. As for the Calva team, we are almost always (true story) to be found at the Clojurians Slack, especially in the <code>#calva</code> Channel. We are <code>@pez</code> and <code>@bringe</code> there.</p>  <p>Happy Interactive Programming! \u2764\ufe0f</p>","title":"Let's go!"},{"boost":10,"location":"get-started-with-clojure/#and-where-do-i-find-those-clojurians","text":"<p>We Clojurians inhabit a lot of community platforms. I'll list some of the more popular ones here in some order of popularity.</p> <ul> <li>The Clojurians Slack - by far the largest and most active Clojure community, the <code>#beginners</code> channel is spectacularly fantastic</li> <li>ClojureVerse - a web forum. Lots of Clojurians, lots of Clojure knowledge collected, easy to search, easy to join</li> <li>/r/Clojure - Reddit when Reddit is at its best, lots of Clojurians here</li> <li>Clojurians on Zulip - An other web forum using the Zulip platform</li> <li>On Discord there are two active servers: Clojurians and Discord</li> </ul> <p>You can also ask questions, and find answers, about Clojure at ask.clojure.org</p>","title":"And where do I find those Clojurians?"},{"boost":10,"location":"get-started-with-clojure/#learn-and-practice-clojure-using-rich-4clojure","text":"<p>If you like the style of interactive learning that this guide provides, you should definitely check Rich 4Clojure out. It also can be used in the zero-installed way.</p> <p>You can regard it as a companion to this guide. It is aimed at practicing Clojure, starting at the elementary levels, bringing you to advanced stuff.</p>  Can I use Rich 4Clojure instead of this guide? <p>We suggest you start by opening up this guide and do the Calva part of the excerises. Then use the <code>welcome_to_clojure.clj</code> guide in combination with Rich 4Clojure..</p>","title":"Learn and Practice Clojure using Rich 4Clojure"},{"boost":10,"location":"get-started-with-clojure/#run-the-clojure-exercism-track-in-your-browser","text":"<p>In a similar manner to the Get Started with Clojure project, you can run the Clojure Exercism Track in your browser without installing anything and with full Interactive Programming enabled using this Template project.</p>","title":"Run the Clojure Exercism Track in your browser"},{"boost":10,"location":"get-started-with-clojure/#clojuredocs","text":"<p>Clojurians draw tremendous value from ClojureDocs. At ClojureDocs the concise documentation for Clojure core functions, etcetera, are amended with examples and advice from fellow Clojurians. Crowdsourcing at its very best! It is a big part of the reason why you won't find an abundance of Clojure information at StackOverflow.</p>","title":"ClojureDocs"},{"boost":10,"location":"get-started-with-clojure/#other-learning-resources","text":"<ul> <li>Clojure Beginner Resources - a much more comprehensive list than this one</li> <li>clojure.org Getting Started - the source of truth, includes installing and stuff</li> <li>The Exercism Clojure track - Learn solving carefully crafted Clojure exercises, get mentor feedback if you like.</li> <li>Clojure for the Brave and True - helping you from beginner to pretty advanced stuff, very popular among Clojurians</li> <li>What do beginners struggle with? - a ClojureVerse thread, where you can tell us about what you have found hard in picking up Clojure. It's what spawned the creation of this guide.</li> <li>on the code again - often features Clojure concepts, with snappy, well communicated, and entertaining videos</li> <li>CalvaTV - Calva's YouTube channel often focuses on beginning with Clojure and ClojureScript. Subscribe, please!</li> </ul>","title":"Other learning resources"},{"boost":10,"location":"get-started-with-clojure/#help-us-help-beginners","text":"<p>Give us feedback. Spread the word. Please consider:</p> <ul> <li>Join the <code>#improve-getting-started</code> channel at the Clojurian Slack</li> <li>Linking to this page from your blog</li> <li>Tweeting about this guide</li> <li>Contributing to the Calva project</li> <li>Wearing Calva and RFC T-shirts</li> <li>Starring these repositories:<ul> <li>Get Started with Clojure - (the repository powering this guide)</li> <li>Rich 4Clojure</li> <li>Clojure Exercism Track Template</li> <li>Calva</li> <li>Dram - Where this guide (the Getting Started REPL) is authored</li> </ul> </li> </ul> <p>Please also consider other ways to contribute.</p> <p>Thanks! \ud83d\ude4f</p>","title":"Help us help beginners"},{"boost":10,"location":"getting-started/","text":"<p>Depending on wether you want to just start a Clojure REPL or you have a project you want to work with, getting started looks similar but a bit different. Regardless, you need to install Calva in VS Code.</p>  I am completely new to Clojure <p>The \u201dGetting Started\u201d REPL below introduces you to Clojure as well as to Calva. You might however, not want to start with installing the right version of Java and such to run the guide. If so you should definitely check the Get Started with Clojure guide on this site.</p> <p>Three clicks will have you running Calva in your browser with the REPL ready to serve.</p>   I don't have Java installed <p>If you like, you can defer installing anything at all and still get started with Calva (not kidding).</p> <p>See Get Started with Clojure.</p>  <p>If you have a Clojure or ClojureScript project, you will be interested in how to get Calva connected to the REPL of your project. But before you run over there, you might want to familiarize yourself with Calva a bit, which you can do without a project.</p>  <p>The demo tells you about the command (and some about the Clojure Beginner's material that it makes available).</p>","title":"Getting Started"},{"boost":10,"location":"getting-started/#theres-a-getting-started-repl","text":"<p>If you are new to Calva, a good place to start is using the command Fire up the \u201dGetting Started\u201d REPL. Demo:</p> <p></p> <p>It will open up a three files in a temporary directory, and start and connect a REPL. The files are:</p> <ul> <li><code>hello_repl.clj</code> \u2013 The basics of how to evaluate code in Calva</li> <li><code>hello_paredit.clj</code> - A super brief intro to Calva structural editing</li> <li><code>welcome_to_clojure.clj</code> - The very basics of the Clojure language</li> </ul> <p></p> <p>The only prerequisite here is that you have Java installed. No pre-installed clojure tools required. (You will want to install these tools later, of course.)</p>  <p>Note</p> <p>On Windows the Oracle Java installer sets Java up in some funny way so that the Getting Started REPL fails to start. We are figuring about workarounds for this, but for now, if you are on Windows, you will need to make VS Code have some other Java in the <code>PATH</code> of its environment for this feature to work. See this issue on the Calva repo for more on this, including any progress.</p>","title":"There's a \u201dGetting Started\u201d REPL"},{"boost":10,"location":"getting-started/#there-are-standalone-clojurescript-quick-start-repls","text":"<p>Without creating a project structure or installing anything but Calva, you can start standalone ClojureScript REPLs both in a browser and for node:</p> <ul> <li>Fire up the ClojureScript Quick Start Browser REPL<ul> <li>Opens the files <code>core.cljs</code> and <code>index.html</code> and starts the ClojureScript app, opening it in the browser.</li> </ul> </li> <li>Fire up the ClojureScript Quick Start Node REPL<ul> <li>Opens a file, <code>core.cljs</code>, and starts a nodejs REPL where it loads the file.</li> </ul> </li> </ul> <p>The browser REPL app looks like so:</p> <p></p>","title":"There are standalone \u201dClojureScript Quick Start\u201d REPLs"},{"boost":10,"location":"getting-started/#you-have-a-project","text":"<p>If you are new to Calva, please consider the above option first. Then when it will be time to get Calva connected to the REPL of your project.</p>","title":"You have a Project?"},{"boost":10,"location":"getting-started/#clojure-resources","text":"<p>If you are new to Clojure or ClojureScript altogether, please check out the guide material on the respective official sites:</p> <ul> <li>Getting Started with Clojure</li> <li>ClojureScript Quick Start</li> </ul> <p>There are also many great books on Clojure. Clojure for the Brave and True can be read for free online. It is a great resource for beginners.</p>","title":"Clojure Resources"},{"boost":10,"location":"getting-started/#there-is-also-standalone-repl","text":"<p>When you are more familiar with Calva, and want a standalone REPL, there is a separate command: Start a standalone REPL (not in project). It will open up a <code>user.clj</code> in a temporary directory, containing only an <code>(ns user)</code> form, and start and connect the REPL. </p>","title":"There is also Standalone REPL"},{"boost":10,"location":"getting-started/#dram-where-the-guides-live","text":"<p>The command for starting the Getting Started REPL will download the files from this repository. It is very much work in progress, and there is not even a finished Clojure Beginner's Guide there yet. WHen you run the command again, and from then on, you will get the option to download new files or keep using your existing. Downloading new ones will not overwrite your existing ones, because they will be downloaded to a new temp directory. You can find the directory easily using VS Codes context menu command for revealing a file in the Explorer/Finder.</p>","title":"Dram - Where the Guides Live"},{"boost":10,"location":"getting-started/#one-last-thing","text":"<p>Happy coding! \u2665\ufe0f</p>","title":"One Last Thing"},{"boost":6,"location":"jack-in-guide/","text":"<p>The Calva Jack-In Academy, by @pez</p> <p>Like with CIDER Jack-in, Calva's let-me-help-you-start-your-project-and-connect feature might seem a bit mysterious. It really is helpful, but also really isn't mysterious. Here are a few things about it that is good to know about.</p>  <p>Note</p> <p>If you came here to find out how to configure the versions of the dependencies that Calva Jack-in injects, see Customizing Calva - Jack-in Dependency Versions.</p>","title":"Learn about Calva Jack-in"},{"boost":6,"location":"jack-in-guide/#what-it-solves","text":"<p>At first it might seem that something like <code>lein repl</code> in a terminal and then connecting Calva is enough. It sometimes might be, but only if you are in luck. To provide many of its IDE features, Calva relies on nREPL middleware, mainly cider-nrepl and, for ClojureScript, piggieback. When starting your Clojure(Script) app and its REPL, it needs to be started with these dependencies satisfied. There are mainly three ways this can be achieved.</p> <ol> <li>In the project definition (files like <code>project.clj</code>, <code>deps.edn</code>, <code>shadow-cljs.edn</code>, and combination of these).</li> <li>In your user profile (files like <code>~/.lein/profiles.clj</code> and <code>~/.clojure/deps.edn</code>).</li> <li>On the command line.</li> </ol> <p>Because 1 and 2 are hard to keep in sync with the various editor environments people in your project might be using, Calva Jack-In is about 3.</p> <p>Ideally, you will be able to rid your project files completely of editor dependencies when people working on the project can rely on the Jack-In features of their Clojure editor.</p>","title":"What it Solves"},{"boost":6,"location":"jack-in-guide/#a-controlled-shell-command","text":"<p>At its core Calva Jack-In is just a glorified, REPL-starting, command-line. No, it is more than that, but anyway. The command line can look like so for a Leiningen project using legacy Figwheel for its ClojureScript assistance:</p> <pre><code>lein update-in :dependencies conj '[nrepl\"0.6.0\"]' -- update-in :dependencies conj '[cider/piggieback\"0.4.1\"]' -- update-in :dependencies conj '[figwheel-sidecar\"0.5.18\"]' -- update-in :plugins conj '[cider/cider-nrepl\"0.22.4\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.piggieback/wrap-cljs-repl\"]' -- with-profile +dev repl :headless\n</code></pre> <p>Even if a bit long, it might look simple enough. But actually it has taken quite some effort to make Calva craft it. Shell quoting can be really tricky. Look at how <code>'[nrepl\"0.6.0\"]'</code> doesn't have a space between <code>nrepl</code> and the version. That was the only way I could find that was cross platform enough to make all supported shells parse the command line. (The trick relies on that the string is read by the super reliable Clojure Reader, which does not need that space to tokenize it.)</p> <p>It is awesome that Clojure is used on so many platforms, but for a tool smith this also means more work. (I think Windows and its shell hell ate up about 95% of the many hours spent on getting the quoting good enough.)</p> <p>The command-line crafted is then used to start a shell command that Calva controls, but we are getting ahead of ourselves...</p>","title":"A Controlled Shell Command"},{"boost":6,"location":"jack-in-guide/#project-types-builds-aliases-profiles-etcetera","text":"<p>In order to cook the right command for your project, Calva looks for project files, reads them, and figures out what possible project types and ClojureScript tools could be involved. Then Calva presents you with a menu with the options it has found. You need to know enough about your project to answer this question. It looks like this in a shadow-cljs project that uses a <code>deps.edn</code> file for setting up its classpath.</p> <p></p> <p>(I know enough about this particular project to know that I should choose the <code>shadow-cljs</code> project type.)</p> <p>But Calva isn't ready to cook the command-line just yet. Depending on the project type, and contents of your project files, more info is needed. E.g. in the case of shadow-cljs projects, Calva needs to know what builds to start.</p> <p></p> <p>Here you can select any combination of builds defined in the project, and Calva will cook a command line that starts them.</p> <p>You might get more prompts from Calva before it issues the command, but for this example project, Calva goes ahead, cooks the command line, and issues it. On my Mac, it looks like so:</p> <pre><code>npx shadow-cljs -d cider/piggieback:0.4.1 -d cider/cider-nrepl:0.22.4 watch :app\n</code></pre> <p>(Much shorter than the one with lein-figwheel, right? It is because shadow-cljs is aware of CIDER dependencies, so it doesn't need as many dependencies specified as some other project types do.)</p>","title":"Project Types, Builds, Aliases, Profiles, etcetera"},{"boost":6,"location":"jack-in-guide/#connecting","text":"<p>When the command is issued Calva needs to wait until the REPL Server is started, before connecting to it and possibly continuing with starting a ClojureScript REPL and connecting to that as well. It also needs to know which port to connect to.</p> <p>Because reasons, Calva can't yet read the <code>stdout</code> of the shell command it has issued, so to know when the REPL server is started, and on which port, Calva monitors the filesystem for the <code>.nrepl-port</code> file. (This file is not always named like that. shadow-cljs, for instance, creates the file <code>.shadow-cljs/nrepl.port</code>.)</p> <p>When the port file is created, Calva picks up the port number from it and connects to the nREPL server. At this point you have a Clojure REPL backing your Calva session, providing all sorts of nice IDE help for you.</p>","title":"Connecting"},{"boost":6,"location":"jack-in-guide/#starting-your-clojure-app","text":"<p>Once you have the Clojure REPL connected you can start your Clojure app/server. See Custom Connect Sequences for how to let Calva do this for you automatically. See the same article for ways to automate more of the Jack-In process. It can be brought down to a single Jack-In command/action, even for a full stack Clojure and ClojureScript application.</p>","title":"Starting Your Clojure App"},{"boost":6,"location":"jack-in-guide/#clojurescript","text":"<p>For ClojureScript, things are not done yet, though, far from it. It turns out that cooking the command line was the easy part.</p> <p>In order for Calva to provide REPL power for ClojureScript projects, several things need to happen:</p> <ol> <li>A Clojure nREPL connection needs to be established. We've covered that above. Calva makes an nREPL session clone to use for the ClojureScript REPL and then:</li> <li>Your ClojureScript app needs to be compiled.</li> <li>Your ClojureScript app needs to be started.</li> <li>The Clojure nREPL session needs to be promoted to a ClojureScript nREPL session. (This is what piggieback helps with.)</li> </ol>","title":"ClojureScript"},{"boost":6,"location":"jack-in-guide/#compiling-the-app-and-watchers","text":"<p>Depending on ClojureScript project type, Calva uses different methods to start the compilation and the watcher:</p> <ul> <li>Figwheel: The compilation and the watchers are started in the Clojure REPL session. (This is both for Figwheel Main and for lein-figwheel.)</li> <li>shadow-cljs: The compilation and the watchers are started with the Jack-In command line.</li> </ul> <p>This results in a bit of difference in the user interaction. Mainly that for shadow-cljs, the user needs to check the Jack-In Terminal tab to follow what's going on.</p>","title":"Compiling the App and Watchers"},{"boost":6,"location":"jack-in-guide/#starting-the-app","text":"<p>Number 3 above, the app needs to be started, might seem obvious, but it actually trips many people up. Because of this, Calva goes to quite some lengths to provide assistance. Many projects are configured not to spawn a browser session automatically, requesting the app once it has been compiled, so we can't rely on that.</p> <p>What Calva does instead is to monitor the output of the commands it uses for starting the compilation, looking for information that the app is ready to be requested/started. It then tells the user this, providing a URL, in case it is a browser app. (There are also settings that tell Calva to open the URL automatically for you, regardless what the project settings are.)</p>","title":"Starting the App"},{"boost":6,"location":"jack-in-guide/#connecting_1","text":"<p>Meanwhile, Calva is monitoring the output and when it sees that the app is started, it continues to hook up the REPL connection to the editor.</p> <p>This whole connection sequence is quite configurable, using Custom Connect Sequences. In fact, Calva's built in ClojureScript sequences (Figwheel Main, lein-figwheel, shadow-cljs, and ClojureScript built-ins for both Browser and Node) are all built using those same settings mechanisms.</p>","title":"Connecting"},{"boost":6,"location":"jack-in-guide/#shadow-cljs-is-less-managed-by-calva","text":"<p>NB: The managed way in which Calva creates and connects the ClojureScript REPL breaks apart a bit for shadow-cljs, which works a bit differently and also outputs most of the information Calva is looking for on the <code>stdout</code> of the REPL start command (where Calva can't see it, remember?). We'll figure out a better way to support shadow-cljs, but for now, the user needs to do more of this figuring out than is needed with Figwheel projects.</p>","title":"shadow-cljs is Less Managed by Calva"},{"boost":6,"location":"jack-in-guide/#hack-away","text":"<p>So, there are things going on when you start Jack-In, and even more things for ClojureScript projects, but Calva tries to keep it together, so as a user it is a matter of paying attention and responding to a few prompts/menus with pre-populated options (prompts which can be configured away, even).</p>","title":"Hack Away"},{"boost":6,"location":"jack-in-guide/#switch-clojurescript-builds","text":"<p>Once the REPL is connected you might want to change which ClojureScript build you have Calva connected to. For this Calva has the Select CLJS Build Connection command. Please note that you can only switch between builds that you have started.</p>","title":"Switch ClojureScript Builds"},{"boost":6,"location":"jack-in-guide/#play-with-starting-the-cljs-repl-yourself","text":"<p>To get a good grip on what is going on when creating and connecting the ClojureScript REPL, I can recommend making a custom connect sequence which leaves the REPL unpromoted (e.g. give it <code>nil</code> as <code>connectCode</code>), and then evaluate the <code>cljs-repl</code> start commands yourself. So for instance, promoting it to a ClojureScript Node.js REPL looks something like so:</p> <pre><code>user=&gt; (require 'cljs.repl.node)\nuser=&gt; (cider.piggieback/cljs-repl (cljs.repl.node/repl-env))\nClojureScript 1.10.844\nTo quit, type: :cljs/quit\nnil\ncljs.user=&gt; |\n</code></pre> <p>It is the piggieback middleware there telling you that you can unpromote the REPL by \u201devaluating\u201d <code>:cljs/quit</code>.</p>","title":"Play With Starting the <code>cljs-repl</code> Yourself"},{"boost":6,"location":"jack-in-guide/#about-full-stack-applications","text":"<p>Because Calva uses the Clojure REPL connection to spawn the ClojureScript REPL, and because Calva only handles one Clojure REPL per VS Code window, some projects need special handling by the user.</p> <p>If your full stack project is using shadow-cljs for the frontend, like this Fulcro template project does, maybe you first try to Jack-In to your backend Clojure REPL, and then to your shadow-cljs frontend. This works if you do it in separate VS Code windows, but if you do it in the same window, the second Jack-In will kill the backend session!</p> <p>See Workspace Layouts for tips about how to open the same project folder in two separate VS Code windows.</p>","title":"About Full Stack Applications"},{"boost":6,"location":"jack-in-guide/#please-grab-your-calva-jack-in-certificate","text":"<p>There, you now know all there is to know about Calva Jack-In.</p> <p>Just kidding, there are a few more details to it, some of which might find their way into this article at a later time.</p> <p>To really get to know it all, you will need to spend some time with the Calva Jack-In code. Head over to the Calva Development Wiki to learn how to hack on Calva.</p>","title":"Please Grab your Calva Jack-In Certificate"},{"location":"joyride/","text":"<p>Joyride is a VS Code extension for user space scripting of VS Code itself. You find the extension here. The scripting language for Joyride is the best you language imaginable: Clojure. And, as is proper for a Clojure implementation, it has a REPL, even an nREPL server.</p> <p>This means you can connect Calva to Joyride and interactively develop your VS Code scripts.</p> <p>This video shows Joyride in action, using Calva as the nREPL client.</p>","title":"Using Calva With Joyride"},{"location":"joyride/#how-to-connect","text":"<p>Once you have the Joyride extension installed you can start its REPL and connect Calva to it (a.k.a Jack-in).</p>  <p>Start the Joyride REPL and Connect</p> <p>This 1 minute video shows the following steps:</p> <ol> <li>Installing the Joyride Extension</li> <li>Isssuing the command Calva: Start a REPL in your Project and (a.k.a Jack-in)</li> <li>Selecting <code>joyride</code> project type</li> <li>Isssuing the command Calva: Load/Evaluate Current File and its Requires/Dependencies</li> <li>Evaluating some non-vscode code</li> <li>Evaluating code exercising something from the VS Code API</li> </ol> <p>(Right-click the video and choose Full Screeen if it is too tiny embedded.)</p>","title":"How to connect"},{"location":"joyride/#how-to-get-started-with-joyride","text":"<p>The Joyride README has some Quick Start pointers for you. Please feel invited to the <code>#joyride</code> channel on the Clojurians Slack and chat with us and other Joyride users.</p> <p>Come on, Join the Joyride! \u2764\ufe0f</p>","title":"How to Get Started with Joyride"},{"location":"krell/","text":"<p>Krell is \u00e0 la carte ClojureScript tooling for React Native.</p> <p>Even if Calva does not yet have built-in support, all is not lost. You can add support yourself by way of a Custom REPL Connect Sequence. Here's how;</p>","title":"Using Calva With Krell"},{"location":"krell/#starting-the-krell-clojurescript-repl","text":"<p>Add this REPL Connect Sequence to your workspace <code>settings.json</code>:</p> <pre><code>    \"calva.replConnectSequences\": [\n        {\n            \"name\": \"deps.edn + Krell\",\n            \"projectType\": \"deps.edn\",\n            \"cljsType\": {\n                \"connectCode\": \"(require '[clojure.edn :as edn] \\n    '[clojure.java.io :as io]\\n    '[cider.piggieback] \\n    '[krell.api :as krell]\\n    '[krell.repl])\\n\\n(def config (edn/read-string (slurp (io/file \\\"build.edn\\\"))))\\n(apply cider.piggieback/cljs-repl (krell.repl/repl-env) (mapcat identity config))\",\n                \"dependsOn\": \"User provided\"\n            }\n        }\n    ]\n</code></pre> <p>Then issue the command Start a Project REPL and Connect (aka Jack-In). It start the project and connect to the Krell REPL once the app is running on a device (wether real or virtual/emulated).</p>","title":"Starting the Krell ClojureScript REPL"},{"location":"krell/#additional-vs-code-tips","text":"<p>For a smooth workflow you can also:</p> <ul> <li>Install the React Native Tools extension</li> <li>Install the Debugger for Chrome extension, and add this Launch Configuration <pre><code>        {\n            \"type\": \"chrome\",\n            \"request\": \"launch\",\n            \"name\": \"Launch Debugger\",\n            \"url\": \"http://localhost:8081/debugger-ui/\",\n            \"webRoot\": \"${workspaceFolder}\"\n        }\n</code></pre></li> </ul> <p>Together with the connect sequence this will make for a start of a Krell session like this:</p> <ol> <li>Open the project root in VS Code</li> <li>Issue the Jack-in command</li> <li>Issue the React Native; Run Android on Emulator (or Run iOS on Simulator) command. (Disable Fast Refresh from the *React Native dev menu, if it is enabled.)</li> <li>Issue the React Native: Run Element Inspector command     (You might need to install the React Native inspector globally):     ```sh     yarn global add react-devtools     ````</li> <li>Launch Debugger (<code>F5</code>)</li> <li>Hack away, with hot reload and interactive REPL</li> </ol> <p>Once the debugger (a Chrome session) is running, you probably will want to enable Custom Formatters in order for clojure structures to be logged conveniently.</p>","title":"Additional VS Code Tips"},{"location":"linting/","text":"<p>Calva does no linting, yet with Calva you get excellent linting. That is because Calva uses clojure-lsp, which provides linting powered by clj-kondo.</p>","title":"Linting"},{"location":"linting/#get-started","text":"<p>clj-kondo comes with great default rules, and the configuration can be customized. One of your options for the configuration file is to  placed a <code>config.edn</code> file in <code>.clj-kondo/</code> at the root of your project. This folder may or may not already exist. It is safe to create it manually if it doesn't.</p> <p>The configuration will be merged with the default set of rules, you can only specify the rules you want to override. The full list of available options can be found on clj-kondo's github</p>","title":"Get Started"},{"location":"linting/#examples","text":"<p>The following examples show how to turn on/off linting rules in your configuration:</p> <p>Display missing docstring as warning: <pre><code>{:linters {:missing-docstring {:level :warning}}}\n</code></pre></p> <p>Display an error when the <code>:require</code>s are not sorted in the namespace: <pre><code>{:linters {:unsorted-required-namespaces {:level :error}}}\n</code></pre></p> <p>Turn off the 'Not empty?' idiom: <pre><code>{:linters {:not-empty? {:level :off}}}\n</code></pre></p> <p>Multiple rules in a single config: <pre><code>{:linters {:missing-docstring {:level :warning}\n           :unsorted-required-namespaces {:level :error}\n           :not-empty? {:level :off}}}\n</code></pre></p>","title":"Examples"},{"location":"linting/#exclude-entire-folders-from-the-linter","text":"<p>The linter is run by clojure-lsp. By default clojure-lsp runs on the entire classpath of the project. There are cases where you may not want that. For example when using clojurescript it is very likely that you will have a <code>target/</code> folder in your classpath which you want to exclude from linting. </p> <p>clojure-lsp is customizable, see Clojure LSP Settings for your options. It is safe to manually create the <code>.lsp</code> folder if it doesn't exist.</p> <pre><code>{:use-source-paths-from-classpath false\n :source-paths #{\"folder-you-want-1\"\n                 \"folder-you-want-2\"}}\n</code></pre>","title":"Exclude entire folders from the linter"},{"location":"linting/#to-go-further","text":"<p>You might want to read about how to configure clj-kondo. These two sections might be of extra interest:</p> <ul> <li>Unrecognized macros</li> <li>Lint a custom macro like a built-in macro</li> </ul> <p>If you see a linting squiggle under the first character of the file with an error you don't quite understand, it is probably something wrong with your clj-kondo configuration.</p> <p>Files are linted as they're being edited. If you want to lint the whole project, use the clj-kondo cli command. See https://github.com/borkdude/clj-kondo for more info on that. Windows users might like to know that they too can get a clj-kondo cli command now, via <code>npm install -g clj-kondo</code>. It'll be a bit slower to start than the native build, but for sure it's better than not having a clj-kondo command! See https://github.com/borkdude/clj-kondo/blob/master/doc/install.md#npm-linux-macos-windows for more on this.</p>","title":"To go further"},{"location":"linting/#resolve-macro-as","text":"<p>When your cursor is on a macro form in the editor, you may notice a code action (click the light bulb that appears) called Resolve Macro As. Running this code action will ask you what macro you'd like to resolve the current macro as, and then what clj-kondo config file you want the macro to be saved to. This code action is also available as a command.</p>","title":"Resolve Macro As"},{"location":"live-share/","text":"<p>Live Share is a Microsoft provided VS Code extension.  It allows you to share the workspace that you have open in your computer with somebody else. Everybody is then working on the same source code files, namely those on your computer. You can edit files at the same time, everyone has their own caret. You can follow each other (i.e. when someone switches to a different file, you will as well). This is great for remote pair programming, for example.</p> <p>An extra nice thing is that each participant is using their own VSCode configuration, including fonts, colors, keyboard shortcuts, etc.</p>","title":"Using Calva with Live Share"},{"location":"live-share/#calva-supports-live-share","text":"<p>When using Calva, you can use Live Share as well. Editing works exactly the same as for any other programming language. What makes Calva a bit special, is the REPL. When using Live Share, Calva allows the host to share the REPL with guests as well. If you use any of the supported configuration, this will be pretty much automatic.</p>  <p>You need to enable the LiveShare support</p> <p>Due to an issue in the LiveShare API, for some users, this feature stops Calva from connecting the REPL. Therefore the support is disabled by default. The setting is <code>calva.useLiveShare</code>.</p>  <p>This is what a typical scenario looks like:</p> <ol> <li>The host jacks-in.</li> <li>The host shares its workspace using Live Share. Calva will detect that    the workspace is being shared, so it will offer to share the REPL port that    was opened when jacking in. The host clicks \"Allow\" to start sharing the    port. (Note: steps 1 and two can also be done in the reverse order.)    </li> <li>The host sends the Live Share URL to the guest(s).</li> <li>The guest joins the Live Share session using the URL it received.</li> <li>The guest connects to the host's REPL using the command \"Connect to a    running REPL server in the project\". If needed, the guest chooses the same    build configuration as the host.</li> </ol> <p>Voila! Both the guest and the host can now use the REPL that is running on the host. Things like documentation lookup now also work on the guest's machine.</p>","title":"Calva Supports Live Share"},{"location":"live-share/#control-visibility-of-calva-folder","text":"<p>Calva depends on the <code>output.calva-repl</code> file to be available. If you have the <code>.calva</code> folder listed in your <code>.gitignore</code>, this also causes the folder to be hidden from guests in Live Share by default. In order to make the folder visible, you can put a file called <code>.vsls.json</code> in your project. In its simplest form, the contents can be this:</p> <pre><code>{\n  \"$schema\": \"http://json.schemastore.org/vsls\",\n  \"hideFiles\": [\n    \"!.calva\"\n  ]\n}\n</code></pre> <p>Now the <code>.calva</code> folder is shared as well. But also any other file and folder that you may have in your <code>.gitignore</code>. If you want to have more fine-grained control, please refer to the section Controlling file access and visibility of the Live Share documentation.</p>","title":"Control Visibility of <code>.calva</code> Folder"},{"location":"live-share/#some-things-to-keep-in-mind","text":"<ul> <li>As a guest, you're connected to a REPL running on the host's machine. With   power comes responsibility; be nice, and be careful!</li> <li>There is only one <code>output.calva-repl</code> file, which all participants are   sharing. It may work better to evaluate things in the source code editors   instead of from the REPL window. Otherwise you will end up in a situation   where one person is typing something in the <code>output.calva-repl</code> window, and   somebody else is evaluating something (hence sending the output there) at the   same time. That gets confusing quickly.</li> <li>When you're working on a CLJS-based web development project, things may   get extra confusing. By default, Live Share will share any HTTP ports on the   host automatically, and also offer to open the URL on the guest. (You can   disable using the setting \"Liveshare: Open Shared Servers\".) As a guest, you   do not want to open that browser window normally. Think about it: where is   the REPL running? Yes: in the browser! But Calva connects to the REPL running   in the browser on the host's machine, so if you open a browser as a guest, you   will also get a REPL there, but you won't be connected to it in Calva.</li> <li>Currently Live Share does not allow Calva to know whether the workspace is   shared read-only or read-write. If you share read-only, and you don't want the   guests to have access to your REPL, don't click \"Allow\" when VSCode asks you   to share the REPL port.</li> </ul>","title":"Some Things To Keep In Mind"},{"location":"luminus/","text":"<p>Luminus is a powerful and versatile Leiningen template for creating web development projects. It comes with built in configuration which makes it easy to use Calva as your Clojure(Script) editor.</p>","title":"How to Use Calva with Luminus"},{"location":"luminus/#server-shadow-cljs","text":"<p>Basically this is the same wokflow as with Server only. Behind the scenes there is more happening, though. Such as the ClojureScript app being built and the CLJS REPL connected once the web app is running.</p> <ol> <li>If you haven't created the project yet, create a new shadow-cljs Luminus project. E.g.:     <pre><code>$ lein new luminus my-luminus-shadow +reagent +re-frame +shadow-cljs\n</code></pre></li> <li>Install npm dependencies     <pre><code>$ npm i\n</code></pre>     (Or <code>yarn</code> if you prefer.)</li> <li>This creates the folder <code>my-luminus-shadow</code>. Open it in VS Code:     <pre><code>$ code my-luminus-shadow\n</code></pre></li> <li>Use the Calva command Start a Project REPL and Connect (aka Jack-in): <code>ctrl+alt+c ctrl+alt+j</code></li> <li>Select to start my-luminus-shadow Server + Client, and wait for the Terminal Calva Jack-in output to say <code>[:app] Build completed.</code></li> <li>Open 127.0.0.1:3000 in your web browser and start hacking.</li> </ol>  <p>Note</p> <p>Currently Calva has troubles following the app-start with shadow-cljs, so Calva will report <code>Jack-in done.</code> in the output window before shadow-cljs is actually done building the app. If you open the app page at that stage, you will see a message to \u201cPlease run <code>lein shadow watch app</code>\u201d. Rest assured that this is already underway. Follow the Jack-in process in the Terminal tab in VS Code for the message that the app is built, then reload the app page in the web browser.</p>","title":"Server + shadow-cljs"},{"location":"luminus/#server-only","text":"<p>The workflow here is really just: Jack-in and start hacking. However, the first time it will involve these steps:</p> <ol> <li>If you haven't created the project yet, create a new server only Luminus project. For a all-defaults setup it is like so:     <pre><code>$ lein new luminus my-luminus-server\n</code></pre></li> <li>This creates the folder <code>my-luminus-server</code>. Open it in VS Code:     <pre><code>$ code my-luminus-server\n</code></pre></li> <li>Use the Calva command Start a Project REPL and Connect (aka Jack-in): <code>ctrl+alt+c ctrl+alt+j</code><ul> <li>Select to start my-luminus-shadow Server and wait until you see <code>Jack-in done.</code> in the output window.</li> </ul> </li> <li>Open 127.0.0.1:3000 in your web browser and start hacking.</li> </ol>","title":"Server Only"},{"location":"luminus/#server-figwheel","text":"<p>This is Legacy Figwheel (lein-figwheel), so the recommendation is to use the shadow-cljs setup instead. As with the server only, the workflow here is really just: Jack-in and start hacking. The first time it involves these steps:</p> <ol> <li>If you haven't created the project yet, create a new server only Luminus project. E.g.:     <pre><code>$ lein new luminus my-fw +reagent\n</code></pre></li> <li>This creates the folder <code>my-fw</code>. Open it in VS Code:     <pre><code>$ code my-fw\n</code></pre></li> <li>Use the Calva command Start a Project REPL and Connect (aka Jack-in): <code>ctrl+alt+c ctrl+alt+j</code>, select Server + Client - my-fw in the Project type picker menu, and wait for the web app to pop open in your web browser.</li> <li>Start hacking.</li> </ol> <p>If you prefer to open the web app yourself, open <code>.vscode/settings.json</code> and change <code>\"shouldOpenUrl\"</code> to <code>false</code> in the pre-configured Calva connect sequence. Calva will then print the URL 127.0.0.1:3000 in the output, so that you can click it open.</p>","title":"Server + Figwheel"},{"location":"luminus/#etcetera","text":"<p>You will have three Calva Custom Command Snippets configured. Invoke them by issuing the Run Custom REPL Command, <code>ctrl+alt+c .</code> (that's a dot). These commands control the Luminus server:</p> <ol> <li><code>Start &lt;project&gt; Server</code></li> <li><code>Stop &lt;project&gt; Server</code></li> <li><code>Restart &lt;project&gt; Server</code></li> </ol> <p>When used, Calva will open its REPL window and execute the command, if it is not already opened. You can close this window if you prefer to use the REPL directly from the Clojure files.</p> <p>Calva also opens the REPL window, and starts the Luminus server, as part of the Jack-in process.</p>","title":"Etcetera"},{"boost":10,"location":"merch/","text":"<p>In this video, there is a question about where you can buy the Calva T-shirt:</p>  <p>You couldn't, then. But now you can! On Amazon.</p>","title":"Calva Merch"},{"boost":10,"location":"merch/#zero-profit","text":"<p>To keep the admin of this shop to a minimum the merch is sold at production prize. There is no royalty going to anyone in the Calva team when you buy one of these t-shirts. You will represent, which is certainly a way to support the project. You are of course encouraged to support us via sponsoring as well:</p> <ul> <li>Sponsor Peter Str\u00f6mberg</li> <li>Sponsor Brandon Ringe</li> </ul>","title":"Zero profit"},{"boost":10,"location":"merch/#the-designs","text":"<p>There are four design, all featuring the Calva symbol (the Calva glass), which are all available for a Standard T-shirt, in men's, women's and kid's cut, and in some different colors. In the <code>.com</code> store there are also Premium T-shirts**.</p>","title":"The designs"},{"boost":10,"location":"merch/#symbol-logo","text":"<p></p> <p>Available at:</p> <ul> <li>https://www.amazon.com/dp/B09BCVH9SC (Premium T-shirt)</li> <li>https://www.amazon.com/dp/B097TB5QFW</li> <li>https://www.amazon.de/dp/B098GWQC6M</li> <li>https://www.amazon.co.uk/dp/B098KM9XMF</li> <li>https://www.amazon.fr/dp/B0994TYXTN</li> <li>https://www.amazon.it/dp/B099KLJJV1</li> <li>https://www.amazon.es/dp/B099NXR71Y</li> <li>https://www.amazon.co.jp/dp/B097YZVMC4</li> </ul>","title":"Symbol + Logo"},{"boost":10,"location":"merch/#symbol-logo-we-do-it-with-rich-comments","text":"<p>The Calva symbol and Logo front, Rich Comments back.</p> <p></p> <p>Available at:</p> <ul> <li>https://www.amazon.com/dp/B09C4PBH5N (Premium T-shirt)</li> <li>https://www.amazon.com/dp/B09BFMRCHL</li> <li>https://www.amazon.de/dp/B09C3VYZH8</li> <li>https://www.amazon.co.uk/dp/B09BLD2BVJ</li> <li>https://www.amazon.fr/dp/B09C3X1H7K</li> <li>https://www.amazon.it/dp/B09C3WV2JQ</li> <li>https://www.amazon.es/dp/B09C4P1GD1</li> <li>https://www.amazon.co.jp/dp/B09C4P45MR</li> </ul>","title":"Symbol + Logo + We do it with Rich Comments"},{"boost":10,"location":"merch/#symbol-only","text":"<p></p> <p>Available at:</p> <ul> <li>https://www.amazon.com/dp/B09B83481D (Premium T-shirt)</li> <li>https://www.amazon.com/dp/B097TB5QFW</li> <li>https://www.amazon.de/dp/B098434W9M</li> <li>https://www.amazon.co.uk/dp/B098KNGPBB</li> <li>https://www.amazon.fr/dp/B099RZGNN7</li> <li>https://www.amazon.it/dp/B099WYH94Z</li> <li>https://www.amazon.es/dp/B09B2TFCSR</li> <li>https://www.amazon.co.jp/dp/B09B4XN3HY</li> </ul>","title":"Symbol Only"},{"boost":10,"location":"merch/#symbol-we-do-it-with-rich-comments","text":"<p>The Calva symbol front, Rich Comments Back.</p> <p></p> <p>Available at:</p> <ul> <li>https://www.amazon.com/dp/B098M34FKJ (Premium T-shirt)</li> <li>https://www.amazon.com/dp/B0993VCG7P</li> <li>https://www.amazon.de/dp/B098MF14PV</li> <li>https://www.amazon.co.uk/dp/B098P1MV44</li> <li>https://www.amazon.fr/dp/B098TPQFCJ</li> <li>https://www.amazon.it/dp/B098YP33ZL</li> <li>https://www.amazon.es/dp/B098RDPK55</li> <li>https://www.amazon.co.jp/dp/B0992MQYG6</li> </ul>  <p>Note</p> <p>What's available on this or that Amazon site will vary a bit and it is a bit slow to add a particular design to a particular market. Eventually I hope to have both designs up on these markets: <code>.com</code>, <code>.co.uk</code>, <code>.de</code>, <code>.fr</code>, <code>.it</code>, <code>.es</code>, and <code>.co.jp</code></p>","title":"Symbol + We do it with Rich Comments"},{"location":"namespace-form-auto-creation/","text":"<p>When you create a new clojure file, a file with <code>.clj</code>, <code>.cljc</code> or <code>.cljs</code> extension, an appropriate namespace form will be added to the file. This feature is provided by clojure-lsp.</p> <p></p>","title":"Namespace Form Auto-creation"},{"boost":4,"location":"nbb/","text":"<p>Since nbb can be started such that it is an nREPL server, Calva can connect to it and a lot of the features will work.</p> <p>Calva can also start nbb and connect its REPL for you, using the Jack-in command. This will start an nbb nREPL server on a random port and connect Calva to it. Check out this video where they use Calva and nbb to create a CLI tool as an executable npm module:</p>  <p>In that video they ask for a JavaScript to ClojureScript converter. And there is one: https://mauricioszabo.gitlab.io/js2cljs/</p> <p>Though if you are using Calva, this converter is easier to use directly via the command Calva: Convert JavaScript to ClojureScript:</p>   <p>Errors jacking in to nbb on Windows?</p> <p>On some machines it seems necessary to first run <code>npx nbb</code> from the <code>CMD</code> prompt to make jack-in work. Or try first install it <code>npm i -g nbb</code>. (You probabl want nbb installed globally anyway.)</p>   <p>Don't expect complete support</p> <p>nbb's nREPL server is completely new and and WIP. It will be a bit limited compared to a full cider-nrepl enhanced \"regular\" Clojure nREPL server. Things like function signatures, and more do not work.</p>   <p>It's a bit hacky</p> <p>The nbb nREPL server is the first ClojureScript nREPL server around and throws Calva's assumption that an nREPL server is always started in a Clojure process out the window. The nbb Jack-in/connect option \u201dpretends\u201d it is connecting to a Clojure nREPL and then the code fro promoting the nREPL session to a ClojureScript one is just dummy code.</p> <p>This means that if you open a Clojure (<code>.clj</code>) file while connected to an nbb nREPL server, it will still be a ClojureScript session serving even though Calva will indicate that it is a Clojure one. Bare with us until we can fix this properly in Calva.</p>","title":"Using Calva with nbb"},{"boost":2,"location":"nrepl_and_cider-nrepl/","text":"<p>nREPL and cider-nrepl middleware enable Calva to support full Interactive Programming.</p>","title":"nREPL and cider-nrepl"},{"boost":2,"location":"nrepl_and_cider-nrepl/#about-nrepl","text":"<p>The REPL is a Clojurists quintessential tool, it\u2019s what we use to do Interactive Development, the hallmark of the LISP style of development.</p> <p>In Interactive Development (more commonly but somewhat imprecisely referred to as REPL-driven development), the programmer\u2019s editor has a direct connection with the running application process. This allows evaluating pieces of code in the context of a running program, directly from where the code is written (and so not in some separate \u201cREPL place\u201d), inspecting and manipulating the innards of the process. This is helped along by the dynamic nature of Clojure in which any var can be redefined at any point, allowing for quick incremental and iterative experimentation and development.</p> <p>This is why it\u2019s essential to the Clojure development experience to have proper editor support, a plugin which bridges the gap between where the code is written and where the code is run. So we have CIDER for Emacs, Calva for VS Code, Cursive for IntelliJ, Conjure or Iced for Vim, and so forth. Often these will also leverage the same (or a parallel) connection into the process for other editor affordances, like navigation and completion.</p> <p>But for these editor plugins to connect to the Clojure process something needs to be listening on the other side, accepting connections, allowing the initiation of a program-to-program dialogue. The most common way to achieve this is by leveraging the nREPL protocol, an asynchronous message-based network protocol for driving interactive development. The application process is started with an embedded nREPL server, so that the editor can connect as an nREPL client.</p>  <p>From: Lambda Island</p>","title":"About nREPL"},{"boost":2,"location":"nrepl_and_cider-nrepl/#about-the-nrepl-server-and-middleware","text":"<p>nREPL is an extensible protocol, the reference server implementation understands certain core operation types like \"eval\". More operations can be supported, or existing operations can be modified or augmented, through nREPL middleware. For example: the Piggieback middleware can intercept \"eval\" messages, and forward them to a ClojureScript environment, rather than evaluating them in the Clojure process itself.</p> <p>Which middleware to use will mostly depend on the editor you are using. You\u2019ll typically find that the Clojure-specific functionality for a given editor is partly implemented as a typical editor extension, for instance CIDER written in Emacs LISP, or Calva written in Typescript, and partly as nREPL middleware, providing the functionality the editor extension relies on. For instance, both CIDER and Calva rely on functionality provided by cider-nrepl.</p>  <p>Also from: Lambda Island</p>","title":"About the nREPL Server and Middleware"},{"boost":2,"location":"nrepl_and_cider-nrepl/#viewing-the-communication-between-calva-and-nrepl","text":"<p>You can view the messages sent between Calva and nREPL by running the command <code>Toggle nREPL Logging Enabled</code>. Enabling nREPL message logging triggers the creation of a VS Code output channel called <code>nREPL Messages</code> where the messages will be logged. Messages sent to nREPL from Calva will have <code>-&gt; sent</code> above them, and messages sent from nREPL to Calva will have <code>&lt;- received</code> above them. Disabling nREPL message logging causes the <code>nREPL Messages</code> channel to be removed and messages will no longer be logged.</p> <p>Each message is logged as JSON. If you find a need for the messages to be logged as EDN (for example, to transform and analyze them with Clojure) please open a GitHub issue for this change. A PR would be welcome too!</p> <p>The example below shows two messages logged when the cursor hovers over <code>println</code> in a Clojure file while a REPL is connected.</p> <pre><code>-&gt; sent\n{\n  op: 'info',\n  ns: 'test-lein.core',\n  symbol: 'println',\n  id: '7',\n  session: '1a080b66-b1b6-4b8c-8206-c4af2cc02747'\n}\n\n&lt;- received\n{\n  added: '1.0',\n  'arglists-str': '[&amp; more]',\n  column: 1,\n  doc: 'Same as print followed by (newline)',\n  file: 'jar:file:/Users/brandon/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj',\n  id: '7',\n  line: 3733,\n  name: 'println',\n  ns: 'clojure.core',\n  resource: 'clojure/core.clj',\n  'see-also': [\n    'clojure.core/prn',\n    'clojure.core/print',\n    'clojure.core/println-str',\n    'clojure.pprint/pprint'\n  ],\n  session: '1a080b66-b1b6-4b8c-8206-c4af2cc02747',\n  static: 'true',\n  status: [ 'done' ]\n}\n</code></pre>","title":"Viewing the Communication Between Calva and nREPL"},{"location":"output/","text":"<p>When Calva evaluates Clojure/ClojureScript code, the results are displayed inline as well as printed to the results output window/file. This file is created and opened when Calva is connected to a REPL.</p> <p>In ClojureScript projects the window will be associated with the <code>cljs</code> REPL once this one is connected. It will then look something like so:</p> <p></p> <p>The first prompt is from when the <code>clj</code> REPL is connected, the second when Calva has a <code>cljs</code> REPL connection. The first part of the prompt tells you which REPL type the window is currently connected to. This gets important when the file/window is used as an interactive REPL.</p>","title":"The Output/REPL Window/File"},{"location":"output/#find-the-outputrepl-window","text":"<p>If you quickly want to open and switch to the output window there is the command Calva: Show Output Window, <code>ctrl+alt+o o</code>.</p> <p>To sync the Output/REPL window namespace with the current file before switching, use the Switch Namespace of the Output/REPL Window to Current Namespace command, <code>ctrl+alt+c alt+n</code>.</p>","title":"Find the Output/REPL Window"},{"location":"output/#find-the-file-for-the-current-repl-window-namespace","text":"<p>When you are working from the Output/REPL window, and want to open the file that defines its current namespace, use the Show File for the Current Output/REPL Window Namespace command, <code>ctrl+alt+o o</code>.</p>  <p>Note</p> <p>This also works for Clojure core and library namespaces.</p>","title":"Find the File for the Current REPL Window Namespace"},{"location":"output/#evaluating-code","text":"<p>The window will be automatically associated with the REPL and the namespace of any project Clojure/ClojureScript file you evaluate code in. So for instance if you evaluate this code in a <code>clj</code> file with the namespace <code>fresh-reagent.handler</code>:</p> <pre><code>(def mount-target\n  [:div#app\n   [:h2 \"Welcome to fresh-reagent\"]\n   [:p \"please wait while Figwheel is waking up ...\"]\n   [:p \"(Check the js console for hints if nothing exciting happens.)\"]])\n</code></pre> <p>The output window will print the defined var and then a new prompt reflecting the current REPL connection and namespace:</p> <p></p> <p>If you then switch to the output window (<code>ctrl+alt+o o</code>), and enter this at the prompt:</p> <pre><code>mount-target\n</code></pre> <p>then evaluate it using <code>alt+enter</code>, you'll get:</p> <p></p> <p>This, since the namespace \u201dfollowed\u201d the first evaluation over to the output window.</p>","title":"Evaluating Code"},{"location":"output/#repl-history","text":"<p>Recently evaluated forms in the REPL file are persisted and can easily be shown again for modifying and re-evaluating.</p>","title":"REPL History"},{"location":"output/#navigate-repl-history","text":"<p>You can navigate up and down the last forms evaluated in the REPL file by using <code>alt+up</code> and <code>alt+down</code>, provided your cursor is at the end of the last form after the prompt. If the cursor is not at the end of the last form, then <code>alt+up</code> and <code>alt+down</code> will do what they are mapped to, which is by default \"Move Line Up\" and \"Move Line Down,\" respectively.</p> <p>If you have typed some text after the prompt before you start traversing up the history, this text will be preserved and will display when you traverse back down the history. If you modify some text in the history while traversing, the modification will be saved at that location in history.</p>","title":"Navigate REPL History"},{"location":"output/#clear-repl-history","text":"<p>You can clear the repl history by running the command \"Clear REPL History\" from the command palette.</p>","title":"Clear REPL History"},{"location":"output/#stack-traces","text":"<p>When an evaluation produces an error, the output window will automatically print the the error message. If there is a stack trace associated with the error, this can now be printed on demand using the Calva: Print Last Stacktrace to the Output Window command. The output window will also have a Codelense button below the error message that will print the stack trace..</p> <p></p> <p>For printed stacktraces, when source locations are available (Clojure files) you will be able to navigate to them by pressing <code>ctrl+click</code> (<code>cmd+click</code> on Mac) on the file name. You can also hover over symbols in the stack trace to see the symbol's documentation, and <code>ctrl+click</code> (<code>cmd+click</code> on Mac) the symbol to Peek Definition.</p> <p></p>","title":"Stack Traces"},{"location":"output/#load-current-namespace","text":"<p>When navigating namespaces it is easy to forget to first require them and that can be a bit tricky to fix. To help with this Calva's command Load/Evaluate Current File and its Requires/Dependencies also works in the output window, but then acts like Load Current Namespace.</p> <p>Consider you have two files, <code>pez/xxx.clj</code> and <code>pez/yyy.clj</code>, where <code>pez.yyy</code> requires <code>pez.xxx</code>.</p> <pre><code>(ns pez.xxx)\n\n(def a :xxx-a)\n\n(def b :xxx-b)\n</code></pre> <pre><code>(ns pez.yyy\n  (:require [pez.xxx]))\n\n(def a :yyy-a)\n\n(println \"Hello\" pez.xxx/a)\n</code></pre> <p>Then with a freshly jacked-in REPL you do <code>(ns pez.yyy)</code> and want to work with the vars defined there. Clojure will complain. But if you Load/Evaluate Current File and its Requires/Dependencies, it will start working. Something like so:</p> <p></p>  <p>Note</p> <p>This currently suffers from a limitation in Calva where it won't reload dependencies, so you will sometimes have to do this \u201dmanually\u201d anyway (by opening the files and loading them). See Calva issue #907</p>","title":"Load Current Namespace"},{"location":"output/#peek-current-namespace","text":"<p>A somewhat hidden feature: You can see documentation for, peek and navigate to a namespace by hovering on the namespace symbol in one of the repl window prompts (just like you would if it was not in the prompt \ud83d\ude04).</p>","title":"Peek Current Namespace"},{"location":"output/#paredit-enabled","text":"<p>The output window is mostly a regular Calva Clojure/ClojureScript file, which make everything that works in a regular file work in this file, including Paredit. This makes it easy to navigate the input and output. For instance, to select the last evaluation results you can press <code>ctrl+w</code> (<code>shift+alt+right</code> on Windows and Linux):</p> <p></p>","title":"Paredit Enabled"},{"location":"output/#debugger-enabled","text":"<p>The output window is mostly a regular... (you get it), which means you also have the Calva debugger at your command at the REPL prompt (only for <code>clj</code> sessions, so far). So instead of evaluating a function definition using <code>alt+enter</code> you can evaluate it and instrument it for debugging using <code>ctrl+alt+c i</code>. Then call the function.</p> <p></p>","title":"Debugger Enabled"},{"location":"output/#it-is-ephemeral","text":"<p>The contents of the output/REPL window is written to a file named <code>output.repl</code> in the <code>.calva/output-window</code> directory of your project. The file is recreated at every new session. And you should copy anything you want to keep from this file to wherever you want to keep it.</p> <p>You probably want to add <code>.calva/output-window/</code> to your <code>.&lt;something&gt;ignore</code> files. (There are some more files in that directory that you shouldn't keep under source control.)</p>","title":"It is Ephemeral"},{"location":"output/#choose-clj-or-cljs-repl-connection","text":"<p>In full stack projects, you will probably use the window as a REPL for both <code>clj</code> and <code>cljs</code>. You can toggle which REPL the window is connected to using the command Calva: Toggle REPL Connection for CLJC files. There is a button for this in the status bar:</p> <p></p>","title":"Choose CLJ or CLJS REPL Connection"},{"location":"output/#known-quirks","text":"<p>Due to limitations in the VS Code API it is hard for Calva to know if the output file is opened, and also if it is opened more than once. Make it a habit to leave this window opened. And if it is opened in several tabs, expect evaluation printouts to be a bit unpredictable.</p> <p>If you save the output/REPL file (which most often does not make much sense, but anyway) you will sometimes be presented with a message about VS Code being confused about the file contents being out of sync. Just choose to Overwrite the currently saved version and you should be fine.</p>","title":"Known Quirks"},{"boost":7,"location":"paredit/","text":"<p>Structural editing and navigation for Clojure.</p>","title":"Paredit \u2013 a Visual Guide"},{"boost":7,"location":"paredit/#what-is-paredit","text":"<p>Calva Paredit helps you navigate, select and edit Clojure code in a structural way. LISP isn't line or character oriented, it is based around S-expressions, a.k.a forms. We strongly recommend that you take advantage of the structural nature of Clojure, and have therefore put a lot of work into making Calva Paredit extra awesome.</p> <p>If you are new to Paredit, consider starting with learning the Slurp Forward (pull in the next form into this form) and Barf Forward (push the last form out of this form). It will take you quite far.</p>","title":"What is Paredit?"},{"boost":7,"location":"paredit/#strict-mode","text":"<p>To protect the integrity of your code, Strict mode is enabled by default.</p>    Strict mode keybinding Action Description     <code>backspace</code> Delete Backward Deletes one character backwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it will remove both open and close brackets.     <code>delete</code> Delete Forward Deletes one character forwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it is removed.     <code>alt+backspace</code> Force Delete Backward Deletes one character backwards, even if it will unbalance a form.     <code>alt+delete</code> Force Delete Forward Deletes one character forwards, even if it will unbalance a form.      <p>Disable at your own peril. Strict mode can be toggled on/off using the Toggle Paredit Mode command, and there is a status bar indicator telling you:</p>    Indicator Paredit Mode     <code>[\u03bb]</code> Strict   <code>(\u03bb)</code> Cave Man (strict mode off)   <code>\u03bb</code> No default key bindings    <p>Toggle between Strict and Cave Man using: <code>ctrl+alt+p ctrl+alt+m</code></p>","title":"Strict Mode"},{"boost":7,"location":"paredit/#prevent-unbalanced-closing-brackets","text":"<p>There is also a setting, <code>calva.paredit.strictPreventUnmatchedClosingBracket</code>, that will help you to not enter unbalanced closing brackets into the code.</p>","title":"Prevent Unbalanced Closing Brackets"},{"boost":7,"location":"paredit/#commands","text":"<p>The Paredit commands are sorted into Navigation, Selection, and Edit. As mentioned, Slurp and Barf are power commands, which go into the editing category. Learning to navigate structurally, using shortcuts, also saves time and adds precision to your editing. It has the double effect that you at the same time learn how to select structurally, because that is the same, just adding the shift key.</p> <p>To make the command descriptions a bit clearer, each entry is animated. When you try to figure out what is going on in the GIFs, focus on where the cursor is at the start of the animation loop.</p>","title":"Commands"},{"boost":7,"location":"paredit/#strings-are-not-lists-but-anyway","text":"<p>In Calva Paredit, strings are treated in much the same way as lists are. Here's an example showing Slurp and Barf, Forward/Backward List, and Grow Selection.</p> <p></p>","title":"Strings are not Lists, but Anyway..."},{"boost":7,"location":"paredit/#navigating","text":"<p>(Modify these with <code>shift</code> to select rather than move, see below.)</p>    Default keybinding Action Description     <code>ctrl+right</code> (win/linux)<code>alt+right</code> (mac) Forward Sexp Moves the cursor forward, to the end of the current form. If at the end, moves to the end of the next form. Will not move out of lists.    <code>ctrl+left</code> (win/linux)<code>alt+left</code> (mac) Backward Sexp Moves the cursor backward, to the start of the current form. If at the start, moves to the start of the previous form. Will not move out of lists.    <code>ctrl+down</code> Forward Down Sexp Moves the cursor into the following list.    <code>ctrl+alt+up</code> Backward Down Sexp Moves the cursor into the preceding list.    <code>ctrl+alt+down</code> Forward Up Sexp Moves the cursor forwards, out of the current list.    <code>ctrl+up</code> Backward Up Sexp Moves the cursor backwards, out of the current list.    Unbound Forward Sexp Or Up Moves the cursor forward, to the end of the current form. If at the end, moves to the end of the next form. Moves out of the lists if at the end of it.     Unbound Backward Sexp Or Up Moves the cursor backward, to the start of the current form. If at the start, moves to the start of the previous form. Moves out of the list if at the start of it.     <code>ctrl+end</code> Forward to List End/Close Moves the cursor forwards, staying within the current list.    <code>ctrl+home</code> Backward to List Start/Open Moves the cursor backwards, staying within the current list.","title":"Navigating"},{"boost":7,"location":"paredit/#selecting","text":"<p>Most of these commands are selecting \u201dversions\u201d of the navigation commands above. Repeated use will grow the current selection step by step.</p>    Default keybinding Action Description     <code>shift+alt+right</code> (win/linux)<code>ctrl+w</code> (mac) Expand Selection Starts from the cursor and selects the current form. Then will keep expanding to enclosing forms.    <code>shift+alt+left</code> (win/linux)<code>ctrl+shift+w</code> (mac) Shrink Selection Contracts back from an expanded selection performed by any Paredit selection command. (In the animation the selection is first grown using a combination of Grow Selection and some lateral selection commands, then shrunk all the way back down to no selection.)   <code>ctrl+alt+w space</code> Select Top Level Form Top level in a structural sense. Typically where your<code>(def ...)</code>/<code>(defn ...)</code> type forms. Please note that<code>(comment ...)</code> forms create a new top level.     <code>shift+ctrl+right</code> (win/linux)<code>shift+alt+right</code> (mac) Select Forward Sexp    <code>ctrl+shift+k</code> Select Right Select forward to the end of the current form or the first newline. See Kill right below. (The animation also shows Shrink Selection).    <code>shift+ctrl+left</code> (win/linux)<code>shift+alt+left</code>(mac) Select Backward Sexp    <code>ctrl+shift+down</code> Select Forward Down Sexp  (You probably do not need to select like this, but you can!)   <code>ctrl+shift+alt+up</code> Select Backward Down Sexp  (You probably do not need to select like this, but you can!)   <code>ctrl+shift+alt+down</code> Select Forward Up Sexp  (You probably do not need to select like this, but you can!)   <code>ctrl+shift+up</code> Select Backward Up Sexp  (You probably do not need to select like this, but you can!)   Unbound Select Forward Sexp Or Up  (You probably do not need to select like this, but you can!)   Unbound Select Backward Sexp Or Up  (You probably do not need to select like this, but you can!)   <code>ctrl+shift+end</code> Select Forward to List End/Close    <code>ctrl+shift+home</code> Select Backward to List Start/Open","title":"Selecting"},{"boost":7,"location":"paredit/#editing","text":"Default keybinding Action Description     <code>ctrl+alt+right</code> (mac/win)<code>ctrl+alt+.</code> (linux) Slurp Forward Moves the closing bracket forward, away from the cursor, past the following form, if any.     <code>ctrl+alt+left</code> (mac/win)<code>ctrl+alt+,</code> (linux) Barf Forward Moves the closing bracket backward, towards the cursor, past the preceding form.     <code>ctrl+alt+shift+left</code> Slurp Backward Moves the opening bracket backward, away from the cursor, past the preceding form, if any.     <code>ctrl+alt+shift+right</code> Barf Backward Moves the opening bracket forward, towards the cursor, past the following form.     <code>ctrl+alt+s</code> Splice Sexp Remove enclosing brackets.     <code>ctrl+shift+s</code> Split Sexp Splits a string, or a list, into two strings, or lists of the same type as the current.     <code>ctrl+shift+j</code> Join Sexps/Forms Joins two strings, or two lists of the same type, into one form (string/list).     <code>ctrl+alt+p ctrl+alt+r</code> Raise Sexp Replaces the enclosing list with the current form.     <code>ctrl+alt+t</code> Transpose Sexps/Forms Swaps place of the two forms surrounding the cursor.     <code>alt+up</code><code>alt+down</code> Drag Sexp Backward/Forward Moves the current form to the behind/in front of the previous/next one. (See below about behavior in maps and binding boxes.)     <code>ctrl+alt+shift</code> <code>u</code><code>ctrl+alt+shift</code> <code>d</code> Drag Sexp Backward UpDrag Sexp Forward Down Moves the current form up/out of the current list, backwards, and down/in to the following list, forwards, keeping the cursor within the sexpr being dragged.    <code>ctrl+alt+shift</code> <code>k</code><code>ctrl+alt+shift</code> <code>j</code> Drag Sexp Forward UpDrag Sexp Backward Down Moves the current form up/out of the current list, forwards, and down/in to the preceding list, backwards, keeping the cursor within the sexpr being dragged.    <code>ctrl+shift+c</code> Convolute \u00af\\_(\u30c4)_/\u00af     <code>ctrl+shift+delete</code> Kill Sexp Forward Deletes the next form in the same enclosing form as the cursor.    <code>ctrl+k</code> Kill Right Delete forward to the end of the current form or the first newline.    <code>ctrl+alt+backspace</code> Kill Sexp Backward Deletes the previous form in the same enclosing form as the cursor.    <code>ctrl+delete</code> Kill List Forward Deletes everything from the cursor to the closing of the current enclosing form.    <code>ctrl+backspace</code> Kill List Backward Deletes everything from the cursor to the opening of the current enclosing form.    <code>ctrl+alt+shift+delete</code> Splice Killing Forward Delete forward to end of the list, then Splice.     <code>ctrl+alt+shift+backspace</code> Splice Killing Backwards Delete backward to the start of the list, then Splice.     <code>ctrl+alt+shift+p</code> Wrap Around () Wraps the current form, or selection, with parens.     <code>ctrl+alt+shift+s</code> Wrap Around [] Wraps the current form, or selection, with square brackets.     <code>ctrl+alt+shift+c</code> Wrap Around {} Wraps the current form, or selection, with curlies.     <code>ctrl+alt+shift+q</code> Wrap Around \"\" Wraps the current form, or selection, with double quotes. Inside strings it will quote the quotes.     <code>ctrl+alt+r</code><code>ctrl+alt+p</code>/<code>s</code>/<code>c</code>/<code>q</code> Rewrap Changes enclosing brackets of the current form to parens/square brackets/curlies/double quotes..       <p>Copy to Clipboard when killing text</p> <p>You can have the kill commands always copy the deleted code to the clipboard by setting <code>calva.paredit.killAlsoCutsToClipboard</code> to <code>true</code>.  If you want to do this more on-demand, you can kill text by using the selection commands and then Cut once you have the selection.</p>   <p>clojure-lsp drag fwd/back overlap</p> <p>As an experimental feature, the two commands for dragging forms forward and backward have clojure-lsp alternativs. See the clojure-lsp page.</p>","title":"Editing"},{"boost":7,"location":"paredit/#drag-bindings-forwardbackward","text":"<p>When dragging forms inside maps and binding boxes, such as with <code>let</code>, <code>for</code>, <code>binding</code>, etcetera, it often makes most sense to drag each binding as a pair. And this is what Calva will do. Like so:</p> <p></p> <p>And like so (wait for it):</p> <p></p>","title":"Drag bindings forward/backward"},{"boost":7,"location":"paredit/#about-the-keyboard-shortcuts","text":"<p>Care has been put in to making the default keybindings somewhat logical, easy to use, and work with most keyboard layouts. Slurp and barf forward are extra accessible to go with the recommendation to learn using these two super handy editing commands.</p> <p>You can choose to disable all default key bindings by configuring <code>calva.paredit.defaultKeyMap</code> to <code>none</code>. (Then you probably also want to register your own shortcuts for the commands you often use.)</p> <p>You can relax how Paredit's shortcuts replace VS Code built in shortcuts a bit by setting <code>calva.paredit.hijackVSCodeDefaults</code> to <code>false</code>.</p> <p>There are some context keys you can utilize to configure keyboard shortcuts with precision. See Customizing Keyboard Shortcuts.</p> <p>The Nuclear Option: You can choose to disable all default key bindings by configuring <code>calva.paredit.defaultKeyMap</code> to <code>none</code>. (Then you probably also want to register your own shortcuts for the commands you often use.)</p> <p>In some instances built-in command defaults are the same as Paredit's defaults, and Paredit's functionality in a particular case is less than what the default is. This is true of Expand Selection and Shrink Selection for Windows/Linux when multiple lines are selected. In this particular case adding <code>!editorHasMultipleSelections</code> to the <code>when</code> clause of the binding makes for a better workflow. The point is that when the bindings overlap and default functionality is desired peaceful integration can be achieved with the right <code>when</code> clause. This is left out of Paredit's defaults to respect user preference, and ease of maintenance.</p> <p>Happy Editing! \u2764\ufe0f</p>","title":"About the Keyboard Shortcuts"},{"location":"parinfer/","text":"<p>Reverted in Calva v2.0.228</p> <p>The changes in v2.0.227 seemed to cause problems for some users. Unclear yet if and why. But to not risk causing problems for more users these changes where reverted and Calva v2.0.228 does not contain them. Please consider using v2.0.227 and help find what the problems are about! Please note: Even in v2.0.227 this feature is currently disabled by default.</p>  <p>Parinfer is a system for editing the structure of LISP text without explicit commands. The structure can be regarded as already being expressed through indentation. With Parinfer you can use your intuition about the structure inferred from the indentation to perform surprisingly many structural edits.</p>","title":"Calva Parinfer Mode is Reverted"},{"location":"parinfer/#quirks","text":"<p>There are some known quirks, of varying severity, with this feature. Some of them will need to be fixed before we move this feature out of Experimental status.</p> <p>For the most times you can always Undo to get back to where the document was fine. You just need to pay some attention and be aware when undo is needed.</p>","title":"Quirks"},{"location":"parinfer/#no-multi-cursor-support","text":"<p>The bracket inference will remove all cursors but the first one. So for instance if you edit with multiple cursors and it causes brackets to move, you'll end up with just one cursor and the subsequent edits will not be what you intended. This is particularly important to note when you have cursors that are not in the viewport. In such cases it might be better to turn Parinfer off while you do the edits, fix formatting and such manually and then switch Parinfer on again.</p>","title":"No multi-cursor support"},{"location":"parinfer/#wrong-inferences","text":"<p>For yet unknown reasons an edit such as the following does the wrong thing (the cursor indicated by the vertical bar):</p> <pre><code>(foo| (bar)\n      (baz))\n</code></pre> <p>backspace =&gt; </p> <pre><code>(fo| (bar\n      (baz)))\n</code></pre> <p>That is <code>(baz)</code> is slurped. When what should happen is:</p> <pre><code>(fo| (bar)\n     (baz))\n</code></pre>","title":"Wrong inferences"},{"location":"parinfer/#lag-causing-errors-when-fast-typing","text":"<p>The way that Calva Parinfer works is that for any edit of the document it first reformats the code around the cursor, then infer brackets. Currently these two steps are not atomic to VS Code, so if you type fast bracket inference might happen on the yet unformatted code, and thus not be correct. You might also see the cursor end up at the wrong position at times.</p>","title":"Lag causing errors when fast typing"},{"location":"parinfer/#infer-parens","text":"<p>This is no longer available in Calva</p> <p>See above about how to try this build anyway, warts and all.</p>  <p>When you enable Calva's Parinfer it is all about infering brackets from indentation. There are no further Parinfer modes. Calva's auto-formatter will take care of keeping the code correctly indented.</p> <p>Enable it with from this setting: <code>calva.fmt.experimental.inferParensAsYouType</code> or from the status bar item.</p>","title":"Infer Parens"},{"location":"parinfer/#parinfer-status-bar-items","text":"<p>To the right on the status bar, right before the Paredit status bar item, you will have two items, Parinfer toggle ON/OFF and a health indicator.</p> <ol> <li>Parinfer ON/OFF indicator/button. \u2022() (The dot/circle indicates ON/OFF)</li> <li>Structure and indentation health indicator. \u2714\ufe0f/\u26a0/\u2298</li> </ol> <p>When Parinfer is ON, the health indicator will have three states:</p> <ol> <li>\u2714\ufe0f Healthy - meaning both structure and indentation is OK</li> <li>\u2298 Structure broken - you need to fix the the structure of the code</li> <li>\u26a0 Bad indentation - meaning that to Parinfer the structure and indentation do not match, _the item is now also a button with which you can fix the indentation.</li> </ol> <p>Parinfer will be disabled in both the unhealthy states.</p> <p>When Parinfer is OFF, only the first two states above are used.</p>","title":"Parinfer Status bar items"},{"location":"parinfer/#some-vs-code-settings-automatically-changed","text":"<p>In order for some automatic VS Code behaviour not to interfere with Parinfer the following settings are automatically configured when you toggle Parinfer ON:</p> <pre><code>    \"[clojure]\": {\n        \"editor.autoClosingBrackets\": \"never\",\n        \"editor.autoClosingOvertype\": \"never\",\n        \"editor.formatOnPaste\": false\n    },\n</code></pre> <p>And when you toggle Parinfer OFF:</p> <pre><code>    \"[clojure]\": {\n        \"editor.autoClosingBrackets\": \"always\",\n        \"editor.autoClosingOvertype\": \"always\",\n        \"editor.formatOnPaste\": true\n    },\n</code></pre> <p>It is recommended that you let Calva handle these settings to avoid weird behaviour.</p>","title":"Some VS Code Settings automatically changed"},{"location":"parinfer/#no-tab-indenting","text":"<p>As the <code>tab</code> key is used for formatting the current form in Calva, it is \u201dtaken\u201d. The closest equivalents you have are <code>space</code> and <code>backspace</code>. At least for now. We'll see if we can find out a good way for supporting <code>tab</code> and <code>shift+tab</code> for indent and dedent.</p> <p><code>tab</code> for formatting is of course just a default key binding and you can assign it to something else to get it to do indenting. However, it will not be a very smart indent anyway, there is no Clojure awareness about it. You are hereby adviced to instead use some more spaces.</p>","title":"No Tab indenting"},{"location":"parinfer/#paredit-is-still-there","text":"<p>In Calva, Parinfer and Paredit are designed to coexist and both be there to let you edit the structure easily and efficiently. Since Paredit commands are always formatted, they leave the code in a state where Parinfer has what it needs to infer bracket placement as you either edit the indentation, or remove/add brackets.</p>","title":"Paredit is still there"},{"location":"parinfer/#disable-the-parinfer-extension","text":"<p>If you want to have Parinfer you are probably best served by Calva's built-in version. It is designed, and will continue to be improved to function well together with Calva's other structural editing and formatting features. It will also probably conflict with the Parinfer Extension.</p>","title":"Disable the Parinfer Extension"},{"location":"parinfer/#see-also","text":"<ul> <li>Paredit</li> <li>Formatting</li> </ul>","title":"See also"},{"location":"polylith/","text":"<p>Polylith is an architecture for backend projects that maximizes development ergonomics and code reuse.</p> <p></p> <p>When developing a Polylith application you use one REPL for everything. And as such it is a rather vanilla <code>deps.edn</code> project, so there is really not much more to using Calva with Polylith than:</p> <ol> <li>Jack in, selecting the <code>deps.edn</code> project type</li> <li>Select aliases, most often <code>:dev</code> and <code>:test</code></li> <li>Hack away!</li> </ol>","title":"How to Use Calva with Polylith"},{"location":"polylith/#the-realworld-example","text":"<p></p> <p>To make it easy to try Polylith out with Calva, the Polylith RealWorld example implementation has some Calva config to get the server started and Calva connected to its REPL quickly:</p> <ol> <li>Fork the project and open it in VS Code</li> <li>Jack-in, selecting the <code>Polylith RealWorld Server REPL</code> project type</li> <li>Wait for the REPL prompt to read <code>clj\ua789dev.server\ua789&gt;</code></li> <li>Evaluate <code>(start! 6003)</code></li> <li>Hack away!</li> </ol>","title":"The RealWorld Example"},{"location":"polylith/#try-it-with-a-frontend","text":"<p>A ClojureScript frontend, of course:</p> <ol> <li>Fork the jacekschae/conduit project and open it in VS Code</li> <li>Edit the <code>api-url</code> definition in <code>events.cljs</code> file to be     <pre><code>(def api-url \"http://localhost:6003/api\")\n</code></pre></li> <li>Jack-in, selecting to start and connect to the <code>:app</code> build</li> <li>Wait for it to compile and then open http://localhost:3000</li> <li>Hack away!</li> </ol>","title":"Try it with a Frontend"},{"location":"pprint/","text":"<p>In Calva, pretty printing is a mode. Prettiness is on by default and all your evaluation results will get that treatment.</p>","title":"Pretty Printing"},{"location":"pprint/#toggle-it","text":"<p>There is a <code>pprint</code> indicator to the right in the status bar which shows the status of the mode. Click the indicator to toggle prettification on and off. There is also a Calva: Toggle Pretty Printing for All Evaluations command.</p> <p>Tip: If you have evaluated something time consuming, or that is not idempotent, with pretty printing mistakenly off: toggle it on and evaluate <code>*1</code>.</p>","title":"Toggle it"},{"location":"pprint/#configuration","text":"<p>For most people the defaults will probably work, but Calva pretty printing comes a few knobs you can turn, and they are all available through the <code>calva.prettyPrintingOptions</code> settings. Things you can set are:</p>    Setting Type Effect     <code>enabled</code> boolean So this is a third way you can change this mode \ud83d\ude04   <code>printEngine</code> enum Which printer function that will be used. Default is <code>pprint</code>, more about this setting below   <code>printFn</code> object You can configure Calva to use a custom <code>nREPL</code> compatible <code>print</code> function, more below.   <code>width</code> number The maximum line length of printed output (or at least the printers will try)   <code>maxLength</code> number The maximum number of elements printed in nested nodes, good for evaluating something like <code>(iterate inc 0)</code>, which you shouldn't do without setting <code>maxLength</code>. Most printers will indicate truncated lists with <code>...</code> at the end.   <code>maxDepth</code> number The maximum number of levels deep that will get printed. Different printers mark a stop different ways. <code>puget</code> doesn't support it at all.    <p>See Customizing Calva for some tips on adding settings like these.</p> <p>Here's an example of how <code>zprint</code> handles <code>maxDepth</code> (from the Calva implementation of it's client side pretty printing.).</p> <pre><code>  (pretty-print [[[[[[[[:deeper]]]]]]]] {:max-depth 4})\n  ;; =&gt; {:value \"[[[[##]]]]\"}\n</code></pre>","title":"Configuration"},{"location":"pprint/#your-selection-of-prettifiers","text":"<p>Pretty printing can happen on the server (i.e. in the JVM, via nREPL), or on the client (i.e. in node, via VS Code/Calva). Client side always uses <code>zprint</code>. Server side you can choose from these printers:</p>    Print Engine Client or Server Side Comments     <code>calva</code> client The nREPL server will plain print the results, and then Calva will pretty it (using <code>zprint</code>).   <code>pprint</code> server Current Calva default. <code>clojure.core/pprint</code> is a bit basic, but it's tried and tested, and doesn't suffer from the issues with the other server side printing options, mentioned below.   <code>fipp</code> server    <code>puget</code> server Lacks <code>maxDepth</code> option.   <code>zprint</code> server A very good option. However, it will need to be configured before Jack-in if you want Calva's help to inject its dependencies. (If you are not using Jack-in, you'll need to supply this dependency yourself.)    <p>These particular server side functions were chosen because they have pre-configured print-functions in <code>cider-nrepl</code>.</p>","title":"Your Selection of Prettifiers"},{"location":"pprint/#or-configure-printfn","text":"<p>If the selection of built-in <code>printEngine</code> support doesn't cut it, you can configure a custom function. This function will need to conform to the requirements of nREPL print functions. The VS Code settings editor will help you configure this one. (This is also a bit experimental, please consider giving feedback about how it works for you if you try it.)</p>","title":"Or configure <code>printFn</code>"},{"location":"pprint/#why-does-server-or-client-side-matter","text":"<p>This matters because on the server all pretty printers, except <code>pprint</code> does more than just pretty print the result that would be printed with plain printing. Pretty printing results on the server causes some results to get expanded. This can have huge implications depending on the results and which printer is used. E.g. for Datomic transaction results, you will get the whole database printed. Twice. Depending on the database, you could be so unlucky that nothing gets printed, and instead you will soon have a very hot computer.</p>  <p>Note: With the help of zprint creator, Kim Kinnear, we have found ways to compensate for this problem. Ways that are not yet implemented, but please stay tuned.</p>  <p>Then why not always do it client side? It turns out that on the client side there are also things going on. Calva gets the results back as a string and therefore it needs to first be parsed back to EDN, before it can be pretty printed by <code>zprint</code>. And \u2013 here's the catch \u2013 all results are not valid EDN and therefore can't be pretty printed by <code>zprint</code>. Datomic transaction results are one example.</p>","title":"Why does Server or Client Side Matter?"},{"location":"pprint/#need-more-configurability","text":"<p>The current options are limited, because our time developing Calva is limited. But <code>cider-nrepl</code> really allows for fully configurable pretty printing, so it is within reach. Please feel invited to give us feedback on what you would want to configure for the printing of results. File issues and/or chat us up in #calva in the Clojurians slack.</p>","title":"Need More Configurability?"},{"location":"pprint/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"pprint/#pprint-is-not-working","text":"<p>If pprint is not working, try a different pprint engine or use Calva's jack-in to make sure the necessary dependencies are loaded in your REPL. If you are starting your REPL without jack-in and want to continue doing so, you can use the command <code>Copy Jack-in Command to Clipboard</code> then paste the command somewhere to see what dependencies it injects. You can then add these dependencies to your REPL in whatever way suits your needs.</p> <p>Enjoy Prettiful Printing! \u2764\ufe0f</p>","title":"pprint is not working"},{"location":"quirks/","text":"<p>Here's a shocker for ya': Calva isn't perfect. \ud83d\ude04</p> <p>There are quirks and things that flat out do not work. We'll try to collect info about such things here, providing workarounds when available (or, rather, known to us).</p>","title":"Quirks"},{"location":"quirks/#test-features-not-available-with-clojurescript","text":"<p>Currently <code>cider-nrepl</code> does not provide its test functionality for ClojureScript code. Please consider contributing to fixing that.</p>","title":"Test features not available with ClojureScript"},{"location":"quirks/#using-with-parinfer","text":"<p>See Using with Parinfer</p>","title":"Using with Parinfer"},{"location":"quirks/#calva-and-the-vim-extension","text":"<p>See Using Calva with the VIM Extension.</p>","title":"Calva and the VIM Extension"},{"location":"quirks/#command-not-found-errors-on-jack-in","text":"<p>Jack-in starts by running a command in a new terminal. You will need the commands used installed on your computer:</p> <ul> <li><code>clojure</code> for tools.deps/deps.edn</li> <li><code>lein</code> for Leiningen</li> <li><code>npx</code> for shadow-cljs</li> </ul> <p>Also, in some circumstances VS Code is not spawned from a shell with the environment variables, especially <code>$PATH</code>, which might mean that even though you have the tools installed, they are not found when VS Code/Calva tries to execute them. To fix this you will need to do one of these two things:</p> <ol> <li>Figure out from where VS Code is spawned, and make sure the <code>$PATH</code> there includes the directory with the needed binary.</li> <li>Start VS Code from a terminal where the <code>$PATH</code> is correctly configured. (Using the <code>code</code> command.)</li> </ol> <p>See this issue for more clues on this problem.</p>","title":"\u201dCommand not found\u201d Errors on Jack-in"},{"location":"quirks/#strange-linting-errors","text":"<p>This is not really a quirk, and most linting errors are not strange when you learn about why they are there. Calva does not do any linting, btw, see also linting.</p>","title":"Strange linting errors?"},{"location":"re-frame-template/","text":"<p>The re-frame template(https://github.com/BetterThanTomorrow/calva) creates a <code>shadow-cljs</code> projects, making it easy to use with Calva. </p> <ol> <li><code>npm install</code></li> <li>From VS Code, issue the command Calva: Start a Project REPL and Connect (a.k.a Jack-in), <code>ctrl+alt+c ctrl+alt+j</code>.</li> <li>Calva will auto-detect that this is a <code>shadow-cljs</code> project and ask for which build to compile.</li> <li>Calva's output window will open and log some progress information.</li> <li>When prompted for which build to start, select <code>:app</code>.</li> <li><code>:app</code> is the only configured build, but the VS Code menu for this is a bit strange so make sure the <code>:app</code> checkbox is really ticked before proceeding.</li> <li>This will start the app, so in this workflow you don't do the Run application steps outlined below.</li> <li>When prompted for which build to connect to, select <code>:app</code>.<ul> <li>In the View menu of VS Code, you can tell it to show the Terminal view, where you see which command the jack-in process is started with, and it's output. <code>Ctrl+C</code> in this pane will kill your app and free up all resources it has allocated.</li> </ul> </li> <li>When the app is compiled<ol> <li>Open http://localhost:8280 in your browser.</li> <li>Confirm that it says Hello from re-frame. (Depending on how long the app takes to compile, you might need to reload the page a few times.)</li> </ol> </li> <li>Open the <code>views.cljs</code> file from <code>src/&lt;your-project-name&gt;</code> and issue Calva: Load/Evaluate Current File and its Requires/Dependencies. <code>ctrl+alt+c enter</code>.<ol> <li>Confirm that you are connected by adding evaluating <code>(js/alert \"Hello from Calva\")</code> (<code>alt+enter</code> and <code>ctrl+enter</code> are your friends).</li> <li>Confirm that Shadow is hot reloading by changing the greeting message.</li> </ol> </li> </ol>","title":"How to use Calva with the re-frame template"},{"location":"rebl/","text":"<p>REBL is a graphical, interactive tool for browsing Clojure data.</p>","title":"How to Use Calva and REBL Together"},{"location":"rebl/#depsedn","text":"<p>Add the following aliases to your deps.edn file. Use the deps.edn file in the <code>~/.clojure</code> directory to enable alias reuse across multiple projects. This is the configuration for REBL on openjdk 12. Check out the REBL github page for more info.</p> <pre><code>;; REBL Base\n:rebl\n{:extra-deps {org.clojure/core.async {:mvn/version \"0.4.490\"}\n                ;; deps for file datafication (0.9.149 or later)\n                org.clojure/data.csv {:mvn/version \"0.1.4\"}\n                org.clojure/data.json {:mvn/version \"0.2.3\"}\n                org.yaml/snakeyaml {:mvn/version \"1.23\"}\n                com.cognitect/rebl\n                ;; adjust to match your install location\n                {:local/root \"/Users/ozimos/REBL/latest/REBL.jar\"}}}\n\n;; REBL 12\n:rebl-12\n{:extra-deps {org.openjfx/javafx-fxml     {:mvn/version \"12.0.1\"}\n                org.openjfx/javafx-controls {:mvn/version \"12.0.1\"}\n                org.openjfx/javafx-graphics {:mvn/version \"12.0.1\"}\n                org.openjfx/javafx-media    {:mvn/version \"12.0.1\"}\n                org.openjfx/javafx-swing    {:mvn/version \"12.0.1\"}\n                org.openjfx/javafx-base     {:mvn/version \"12.0.1\"}\n                org.openjfx/javafx-web      {:mvn/version \"12.0.1\"}}}\n\n;; nREBL\n:nrebl {:extra-deps {rickmoynihan/nrebl.middleware {:mvn/version \"0.2.0\"}}\n            :main-opts [\"-e\" \"((requiring-resolve,'cognitect.rebl/ui))\" \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[nrebl.middleware/wrap-nrebl]\" \"-I\"]}\n</code></pre> <p>Create a Calva custom connect sequence for your VSCode editor. (Read Custom REPL Connect Sequences if you haven't.) Add the following to your vscode settings.json:</p> <pre><code>{\n    \"calva.replConnectSequences\": [\n        {\n            \"name\": \"Rebl Connect\",\n            \"projectType\": \"deps.edn\",\n            \"menuSelections\": {\n                \"cljAliases\": [\n                    \"rebl\",\n                    \"rebl-12\",\n                    \"nrebl\"\n                ]\n            }\n        }\n    ]\n}\n</code></pre>","title":"deps.edn"},{"location":"rebl/#leiningen","text":"<p>Add rebl profiles to your user-wide profiles so that they will be available for all your projects. Here's a sample user profile (located at <code>~/.lein/profiles.clj</code> on mac):</p> <p><pre><code>{:user {:plugins [[lein-ancient \"0.6.15\"]]}\n\n ;; REBL Base\n :rebl {:resource-paths [\"/Users/ozimos/REBL/latest/REBL.jar\"]\n        :dependencies [[org.clojure/core.async \"0.4.490\"]\n                       [org.clojure/data.csv \"0.1.4\"]\n                       [org.clojure/data.json \"0.2.3\"]\n                       [cljfmt \"0.6.4\"]\n                       [org.yaml/snakeyaml \"1.23\"]]}\n\n ;; REBL 12 for JDK 12.0.1. Swap out for your JDK version\n :rebl-12 {:dependencies [[org.openjfx/javafx-fxml  \"12.0.1\"]\n                          [org.openjfx/javafx-controls \"12.0.1\"]\n                          [org.openjfx/javafx-graphics \"12.0.1\"]\n                          [org.openjfx/javafx-media \"12.0.1\"]\n                          [org.openjfx/javafx-swing \"12.0.1\"]\n                          [org.openjfx/javafx-base  \"12.0.1\"]\n                          [org.openjfx/javafx-web \"12.0.1\"]]}\n\n;; NREBL https://github.com/RickMoynihan/nrebl.middleware\n :nrebl {:repl-options {:nrepl-middleware [nrebl.middleware/wrap-nrebl]}\n        :dependencies [[rickmoynihan/nrebl.middleware \"0.3.1\"]]}}\n</code></pre> More info here</p> <p>Create a Calva custom connect sequence for your VSCode editor. (Read Custom REPL Connect Sequences if you haven't.) Add the following to your vscode settings.json:</p> <pre><code>{\n    \"calva.replConnectSequences\": [\n        {\n            \"name\": \"Lein REBL\",\n            \"projectType\": \"Leiningen\",\n            \"menuSelections\": {\n                \"leinProfiles\": [\"rebl\", \"rebl-12\", \":nrebl\"]\n            },\n            \"afterCLJReplJackInCode\": \"((requiring-resolve 'cognitect.rebl/ui))\"\n        }\n    ]\n}\n</code></pre>","title":"Leiningen"},{"location":"rebl/#shadow-cljs-tbd","text":"<p>TBD. If you know how to do it, please update this page.</p>","title":"shadow-cljs (TBD)"},{"location":"refactoring/","text":"<p>There are two \u201dflavours\u201d to refactoring support. Some (just a few) refactorings are made available as Quick Fix suggestions (the light bulb), the rest are regular commands in the clojure-lsp Refactoring category.</p> <p></p> <p>You can enable or disable the Quick Fix suggestion lightbulb using the VS Code setting <code>editor.lightbulb.enabled</code>.</p> <p>The refactoring commands do not have default keyboard shortcuts. You find them all by typing \u201dclojure-lsp Refactor\u201d in the Command Palette.</p>","title":"Refactoring"},{"location":"refactoring/#commands","text":"Command Title Command Key Description     Clean NS Form <code>clojureLsp.refactor.cleanNs</code>    Add Missing Require <code>clojureLsp.refactor.addMissingLibspec</code>    Extract to New Function <code>clojureLsp.refactor.extractFunction</code>    Cycle/Toggle Privacy <code>clojureLsp.refactor.cyclePrivacy</code>    Inline Symbol <code>clojureLsp.refactor.inlineSymbol</code>    Introduce let <code>clojureLsp.refactor.introduceLet</code> Creates a new let box with the binding. Follow up with \u201dExpand let\u201d to move it upwards.   Expand Let <code>clojureLsp.refactor.expandLet</code>    Move to Previous let Box <code>clojureLsp.refactor.moveToLet</code>    Thread First <code>clojureLsp.refactor.threadFirst</code>    Thread First All <code>clojureLsp.refactor.threadFirstAll</code>    Thread Last <code>clojureLsp.refactor.threadLast</code>    Thread Last All <code>clojureLsp.refactor.threadLastAll</code>    Unwind All <code>clojureLsp.refactor.unwindAll</code>    Unwind Thread <code>clojureLsp.refactor.unwindThread</code>      <p>Formatting</p> <p>The way that some of the refactorings are applied to the document, makes it difficult for Calva to format the results. So, sometimes you'll need to navigate the cursor to the enclosing form and hit <code>tab</code> to tidy up the formatting after a refactoring. See also Formatting.</p>","title":"Commands"},{"location":"refactoring/#thanks-to-clojure-lsp","text":"<p>Most of Calva's refactoring support is sourced directly from clojure-lsp. This also means that most often, if you find issues with refactoring, or have suggestions about it, the clojure-lsp repo is where to direct your reporting.</p>","title":"Thanks to clojure-lsp"},{"location":"remote-development/","text":"<p>VS Code Remote Development is a new feature in version 1.35 of VS Code that allows a developer to use a container, remote machine, or the Windows Subsystem for Linux (WSL) as a full-featured development environment.</p> <p>I would recommend reading the introductory blog post and watching the videos. I find the feature extremely exciting and wish more IDEs would implement something like it.</p> <p>From a Clojure perspective it allows you to have VS Code installed on your Java-less, Clojure-less hardware and still use it to develop Clojure through it.</p>","title":"Using Calva with Remote Development"},{"location":"remote-development/#a-use-case","text":"<ul> <li>For some reason your physical computer has to be running Windows (organizational rules etc.)</li> <li>Your deployment environment is Linux</li> <li>You want to edit files in an editor running on your physical computer</li> <li>Most Clojure tooling is made with *nix first in mind and there are incompatibilities with Windows</li> </ul>","title":"A use-case"},{"location":"remote-development/#how-to","text":"<p>Run Remote-Containers: Add Development Container Configuration Files... and pick a suitable Java base image. Then:</p>","title":"How to"},{"location":"remote-development/#modify-dockerfile-to-install-clojure-cli-and-optionally-lein","text":"<p>Add:</p> <pre><code># ...\n\n# Install Clojure - see https://github.com/Quantisan/docker-clojure/blob/master/target/openjdk-14-slim-buster/tools-deps/Dockerfile\nENV CLOJURE_VERSION=1.10.1.619\nWORKDIR /tmp\nRUN \\\napt-get update &amp;&amp; \\\napt-get install -y curl make rlwrap wget &amp;&amp; \\\nrm -rf /var/lib/apt/lists/* &amp;&amp; \\\nwget https://download.clojure.org/install/linux-install-$CLOJURE_VERSION.sh &amp;&amp; \\\nsha256sum linux-install-$CLOJURE_VERSION.sh &amp;&amp; \\\necho \"28b1652686426cdf856f83551b8ca01ff949b03bc9a533d270204d6511a8ca9d *linux-install-$CLOJURE_VERSION.sh\" | sha256sum -c - &amp;&amp; \\\nchmod +x linux-install-$CLOJURE_VERSION.sh &amp;&amp; \\\n./linux-install-$CLOJURE_VERSION.sh\nRUN \\\nsu vscode -c \"clojure -e '(clojure-version)'\" &amp;&amp; \\\nrm ./linux-install-$CLOJURE_VERSION.sh\n\n# Install Lein\nRUN \\\nwget https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein -O /bin/lein &amp;&amp; \\\nchmod uog+x /bin/lein\nRUN su vscode -c \"/bin/lein\"\n\n# Cleanup\nRUN apt-get purge -y --auto-remove curl wget\n\n# ...\n</code></pre>","title":"Modify Dockerfile to install Clojure CLI (and optionally lein)"},{"location":"remote-development/#modify-devcontainerjson","text":"<p>Add Calva and, optionally, forward some ports to the host::</p> <pre><code>\"extensions\": [\"betterthantomorrow.calva\"],\n\"forwardPorts\": [8088, 52162], // example: your webapp, your nREPL\n</code></pre>","title":"Modify devcontainer.json"},{"location":"remote-development/#build-and-start","text":"<p>Run Remote-Containers: Rebuild and Reopen in container</p>","title":"Build and start"},{"location":"remote-development/#wsl","text":"<p>See Using Calva with WSL</p>","title":"WSL"},{"location":"reveal/","text":"<p>Reveal is a \"Read Eval Visualize Loop for Clojure\". This page describes how to use Reveal in your development setup based on Calva.</p>","title":"How to use Calva and Reveal together"},{"location":"reveal/#when-using-toolsdeps","text":"<p>You can go for the nrepl middleware or just add the dependency. </p>","title":"When using tools.deps"},{"location":"reveal/#middleware","text":"<p>This will make Reveal to start together with your project.</p>  <p>Note</p> <p>This will make all Calva evaluations go to Reveal. Too chatty for you? Take the dependencies only approach.</p>  <p>Add this alias <code>deps.edn</code>:</p> <pre><code>:aliases\n{:reveal-nrepl-middleware\n    {:extra-deps {vlaaad/reveal {:mvn/version \"1.3.194\"}}\n     :main-opts  [\"-m\" \"nrepl.cmdline\"\n                  \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,cider.nrepl/cider-middleware]\"]}}\n</code></pre> <p>And then jack-in choosing the deps.edn option and then pick the <code>:reveal-nrepl-middleware</code> alias.</p>","title":"Middleware"},{"location":"reveal/#dependencies-only","text":"<p>If you don't want to use the nrepl-middleware you can configure just the dependency and then start Reveal yourself.</p> <p>The alias:</p> <pre><code>:reveal-dep-only\n  {:extra-deps {vlaaad/reveal {:mvn/version \"1.3.194\"}}}\n</code></pre> <p>A custom REPL command for starting Reveal in your project:</p> <pre><code>    \"calva.customREPLCommandSnippets\": [\n        ...\n        {\n            \"name\": \"Start Reveal Tapper\",\n            \"snippet\": \"(require '[vlaaad.reveal :as reveal])(add-tap (reveal/ui))\",\n            \"key\": \"sr\"\n        },\n        ...\n    ]\n</code></pre> <p>See Custom REPL Command for how to configure more commands, and bind shortcuts to them, to make Reveal integration nice for you.</p>","title":"Dependencies only"},{"location":"reveal/#when-using-leiningen","text":"<p>In your <code>project.clj</code>, add a profile named \"reveal\":</p> <pre><code>:profiles {:reveal {:dependencies [[vlaaad/reveal \"1.3.194\"]]\n                    :repl-options {:nrepl-middleware [vlaaad.reveal.nrepl/middleware]}}}\n</code></pre> <p>Now when you jack-in using Calva, you enable this profile and Reveal will be started automatically. Please note that Reveal requires Java 8 or higher, and uses JavaFX. Depending on your setup, you may need to make sure it is available.</p>","title":"When using Leiningen"},{"location":"reveal/#tips-about-font-size","text":"<p>If you find the font to small you can add a <code>:jvm-opts</code> key to make it a little bigger:</p> <pre><code>:aliases\n{:reveal\n    {:extra-deps {vlaaad/reveal {:mvn/version \"1.3.194\"}}\n     :jvm-opts   [\"-Dvlaaad.reveal.prefs={:font-size,17}\"]\n     :main-opts  [\"-m\" \"nrepl.cmdline\"\n                  \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,cider.nrepl/cider-middleware]\"]}}\n</code></pre>","title":"Tips about font size"},{"boost":5,"location":"rich-comments/","text":"<p>Why bother with Rich comments? Read on. Consider watching this Youtube video for a demo of the workflow using the (in?)famous FizzBuzz problem as an example.</p>","title":"Rich Comments Support"},{"boost":5,"location":"rich-comments/#things-in-comment-are-not-evaluated","text":"<p>The Clojure <code>comment</code> macro is defined like so:</p> <pre><code>(defmacro comment\n  \"Ignores body, yields nil\"\n  {:added \"1.0\"}\n  [&amp; body])\n</code></pre> <p>It has no forms in its body and will therefore always (as long as the Clojure Reader can read it) evaluate to <code>nil</code>. That is: nothing in the <code>(comment ...)</code> form will get evaluated when the file is loaded.</p> <p>This makes it a very good \u201dplace\u201d where you can develop code, experiment with code, and keep example code. Since you will be able to load/evaluate the current file without worrying that the code in the <code>comment</code> form will get evaluated. This also holds true when using tools that hot-reload the code on save, such as Figwheel, shadow-cljs and Krell.</p> <p>To develop or refine a function you might:</p> <ol> <li>Open up a <code>(comment ...)</code> form</li> <li>Inside this form, type a first, super simple, version (or refinement) of your function and evaluate it</li> <li>Inside the same <code>comment</code> form, type some code to test your function and evaluate that<ul> <li>Or type and evaluate some code you might need for your function</li> </ul> </li> <li>Repeat from 2., until the function does what you want it to do</li> <li>Move the function definition out of the <code>comment</code> form</li> <li>Clean up the <code>comment</code> form to keep some of the test code as example use, or \u201ddesign decision log\u201d for the function.</li> </ol>  <p>Note</p> <p>Using <code>(comment ...)</code> forms for developing code is very common among Clojure coders. Rich Hickey is known for using it, which is why they are called Rich comments to begin with (even if it also is a very rich experience).</p>","title":"Things in <code>comment</code> are not evaluated"},{"boost":5,"location":"rich-comments/#calva-encourages-rich-comments","text":"<p>Calva has several features to facilitate the Rich comments workflow, e.g.</p> <ol> <li>A command that helps you create a new Rich comment form quickly: Calva: Add Rich Comment, ctrl+alt+r c</li> <li>Special Syntax highlight. By default <code>comment</code> forms are rendered in italics</li> <li>Special top-level form context</li> <li>Special formatting</li> </ol>","title":"Calva encourages Rich comments"},{"boost":5,"location":"rich-comments/#comment-is-top-level","text":"<p>To make it easy to evaluate forms in <code>(comment ...)</code> forms, they create a new top-level context. Instead of you having to place the cursor with precision before evaluating the current form, you can have the cursor anywhere within a <code>comment</code> enclosed form and Evaluate Top-Level Form.</p> <p>This carries over to all commands in Calva which deal with the top level form. Including custom command snippets.</p>","title":"<code>comment</code> is top-level"},{"boost":5,"location":"rich-comments/#special-formatting","text":"<p>To invite a Rich comments workflow, the Calva command Format Current Form will not fold the closing bracket of the <code>(comment ...)</code> form. Instead it will place this bracket on a line of its own (or keep it there).</p> <pre><code>(comment\n  )\n</code></pre> <p>With the cursor somewhere directly inside the comment form (denoted with a <code>|</code>):</p> <pre><code>(comment\n  (def foo\n:foo)|)\n</code></pre> <p>tab</p> <pre><code>(comment\n  (def foo\n    :foo)\n  |)\n</code></pre> <p>!!! Note \"Only for the current comment form\u201d     The special formatting only applies in the current <code>comment</code> form. When outside it, formatting tucks the closing paren in again. That's why fold when done, below works like it does. This also applies to VS Code commands like Format Document, or when you have Format On Save enabled. There are several reasons for this, and one is that there is no <code>cljfmt</code> config for it and leaving the closing comment un-tucked might give you troubles with CI pipelines that enforce some cljfmt config be followed. (Another reason is that it would be pretty hard to do on the whole document.)</p>","title":"Special formatting"},{"boost":5,"location":"rich-comments/#thinking-space-is-kept","text":"<p>The formatter will not remove newlines between the cursor and the closing bracket. So if you have entered a few lines to get \u201dthinking\u201d room:</p> <pre><code>(comment\n  (def foo\n:foo)\n\n|\n\n)\n</code></pre> <p>tab</p> <pre><code>(comment\n  (def foo\n    :foo)\n\n  |\n\n  )\n</code></pre>","title":"Thinking space is kept"},{"boost":5,"location":"rich-comments/#fold-when-done","text":"<p>To fold the trailing paren automatically, place the cursor immediately outside (before or after) the form:</p> <pre><code>(comment\n  (def foo\n:foo))|\n</code></pre> <p>tab</p> <pre><code>(comment\n  (def foo\n    :foo))|\n</code></pre>","title":"Fold when done"},{"boost":5,"location":"rich-comments/#enabled-by-default","text":"<p>You can disable this behavior with the setting: <code>calva.fmt.keepCommentTrailParenOnOwnLine</code>.</p> <p>But why would you? It is awesome! \ud83d\ude04</p>","title":"Enabled by default"},{"boost":5,"location":"rich-comments/#only-for-the-current-form","text":"<p>Note</p> <p>This treatment only applies to formatting of the current form. With fold when done as an exception.</p>","title":"Only for the Current Form"},{"boost":7,"location":"sponsors/","text":"<p>Calva is open source and free to use. It is actively maintained during our free time, and it keeps improving. You can contribute in many different ways, one of which is sponsoring.</p> <p>If you are working at a company which benefits from Calva's existence and continued development, please consider sponsoring at the Calva Gold Sponsor tier. </p> <p>Please see this statement from Cognitect about the importance of supporting open source developers.</p>","title":"Calva Sponsors"},{"boost":7,"location":"sponsors/#patrons","text":"The right kind of different","title":"Patrons"},{"boost":7,"location":"sponsors/#gold-sponsors","text":"Scale your growth on mobile    MAKE. DO. SHIP.","title":"Gold Sponsors"},{"boost":7,"location":"sponsors/#silver-sponsors","text":"","title":"Silver Sponsors"},{"boost":7,"location":"sponsors/#clojurists-together","text":"<p>Significant additions to Calva have been made possible by funding from Clojurists Together. And this has often been transformational for the whole project. Calva would not be where it is today without Clojurists Together.</p>","title":"Clojurists Together"},{"boost":7,"location":"sponsors/#our-sponsoring-profiles","text":"<p>These are the sponsoring profiles for the active maintainers of Calva (a.k.a. The Calva Team):</p> <ul> <li>Peter Str\u00f6mberg</li> <li>Brandon Ringe</li> <li>Cora Sutton</li> <li>Lukas Domagala</li> </ul>","title":"Our Sponsoring Profiles"},{"boost":7,"location":"sponsors/#readme-visibility","text":"<p>There is also a sponsors section in the README of the Calva project (which means it is also displayed in the VS Code Extension Marketlace).</p>","title":"README visibility"},{"location":"static-only/","text":"<p>Why would anyone want to use a Clojure editor without a REPL? It could be because you prefer some other REPL client over Calva's ditto, like Clover, but would be lacking Calva's clojure-lsp support, formatter, Paredit, highlighter, etcetera.</p> <p>As it could be a bit confusing and cluttered to have several REPL UIs active at the same time, Calva supports this use with a setting to disable most of its REPL UI elements, like statusbar items, command palette entries and editor context menus.</p> <ul> <li>Set <code>calva.hideReplUi</code> to <code>true</code> and the only commands still visible should be those for Connect and Jack-in.</li> </ul> <p>If you have the Calva REPL UI disabled and still want to connect or jack-in to a REPL using Calva, just do it. Then Calva's REPL UI will wake up and be there for the duration of the session.</p>","title":"Use Calva w/o the REPL"},{"location":"static-only/#consider-uninstalling-these-extensions","text":"<p>Without Calva, many users install other nifty extensions (some of which are old pieces of Calva) that help with this or that problem. It might sometimes work together with Calva, sometimes not. Here's a list of some common extensions you should consider to at least disable:</p> <ul> <li>Strict Paredit - Calva Paredit has evolved a lot since that version</li> <li>Calva-fmt/Calva Formatter - Same here, evolution</li> <li>Clojure Warrior - Calva includes it, in a much evolved way</li> <li>Parinfer - This one you can actually keep, at some cost, see Using Calva with Parinfer.</li> </ul>","title":"Consider uninstalling these extensions"},{"location":"static-only/#theres-only-one-calva-repl-though","text":"<p>Of course we encourage you to use Calva's REPL. It gives you easy ways to</p> <ul> <li>start a Clojure REPL</li> <li>connect to an running REPL</li> <li>super duper nice debugger</li> <li>test runner</li> <li>custom REPL commands</li> <li>enhanced symbol lookup and code navigation (keep navigating into library and Clojure core code, as well as into Java code).</li> <li>easy to use output with pretty printing, on-demand stack traces, and that awesome debugger.md</li> </ul> <p>Happy REPLing, whichever REPL client you choose. \u2764\ufe0f</p>","title":"There's only one Calva REPL, though"},{"location":"syntax-highlighting/","text":"<p>Calva takes care of syntax highlighting, and also provides some features not available through VS Code's highlighting mechanism. These extras include rainbow parens, sane bracket matching, and comment form dimming/highlighting.</p>","title":"Calva Highlight"},{"location":"syntax-highlighting/#syntax-highlighting","text":"<p>When using Calva, you are also using its TMLanguage grammar (the core mechanism VS Code uses for syntax highlighting).</p> <p>Our grammar tokenizes Clojure keywords as <code>constant.keyword.clojure</code>. Since it is pretty uncommon with keyword constants in the programming languages out there, your theme might not have a highlight defined for this scope. Try find a grammar that highlights keywords! If you are very fond of some theme lacking this, you can help it with a setting:</p> <pre><code>\"editor.tokenColorCustomizations\": {\n    \"[Default Dark+]\": {\n        \"textMateRules\": [\n            {\n                \"scope\": [\n                    \"constant.keyword.clojure\"\n                ],\n                \"settings\": {\n                    \"foreground\": \"#6fbfff\"\n                }\n            }\n        ]\n    }\n},\n</code></pre> <p>Instead of <code>Default Dark+</code> you should use your theme's name/key. And choose a color you like, of course.</p>","title":"Syntax Highlighting"},{"location":"syntax-highlighting/#extra-highlighting","text":"<p>You are in charge of how brackets and comments are highlighted via the <code>calva.highlight.&lt;setting&gt;</code> settings:</p>    Setting Meaning Example     <code>enableBracketColors</code> Enable rainbow colors <code>true</code>   <code>rainbowIndentGuides</code> Enable rainbow indent guides <code>true</code>   <code>highlightActiveIndent</code> Highlight the active indent guide <code>true</code>   <code>bracketColors</code> Which colors to use <code>[\"#000\", \"#999\"]</code>   <code>cycleBracketColors</code> Whether same colors should be  reused for deeply nested brackets <code>true</code>   <code>misplacedBracketStyle</code> Style of misplaced bracket <code>{ \"border\": \"2px solid #c33\" }</code>   <code>matchedBracketStyle</code> Style of bracket pair highlight <code>{\"backgroundColor\": \"#E0E0E0\"}</code>   <code>ignoredFormStyle</code> Style of <code>#_...</code> form <code>{\"textDecoration\": \"none; opacity: 0.5\"}</code>   <code>commentFormStyle</code> Style of <code>(comment ...)</code> form <code>{\"fontStyle\": \"italic\"}</code>     <p>Calva disables the VS Code built-in indent guides</p> <p>The VS Code built-in settings <code>editor.renderIndentGuides</code> and <code>editor.highlightActiveIndent</code> do not have any effect, since the former is switched off by the Clojure Defaults, mentioned above. Use Calva Highlight's <code>rainbowIndentGuides</code> and <code>highlightActiveIndent</code> instead. They are different from the built in ones in that they are independent, meaning you can choose to have active indent highlighted while the guides generally are not rendered (this is the default, even).</p>   <p>VS Code bracket coloring vs Calva's</p> <p>Calva's bracket coloring is more Clojure aware than VS Code's built-in coloring. And also will chime better with Calva's indent guides. If you like to have bracket coloring outside Clojure code, by all means enable it. Calva's bracket coloring will \u201dover paint\u201d in Clojure files, when enabled. These settings work nicely:</p> <pre><code>\"calva.highlight.highlightActiveIndent\": true,\n\"editor.bracketPairColorization.enabled\": true,\n</code></pre> <p>The <code>calva.highlight.bracketColors</code> setting can be used to harmonize the coloring between VS Code and Calva.</p>","title":"Extra Highlighting"},{"location":"tao/","text":"<p>Calva, the spirit, gains much of its taste and color from the Cider it is distilled from, and the oak it is matured in. I started to wonder what it is that shapes Calva, the VS Code Clojure Extension. I should know, being the master distiller, right?. Indeed. Poking some at the question, I do find that I have some answers.</p> <p>Please read the following to learn what Calva is, and, to some extent, is not, about. Read it to get an idea about which path Calva is following, where we are headed with the project, and how you can contribute to the journey.</p>","title":"The Tao of Calva"},{"location":"tao/#why-calva","text":"<p>Calva's raison d\u00b4\u00eatre is to provide Visual Studio Code users with an easy to use and productive environment for Clojure and ClojureScript development. See the Why Calva? page for some evidence that we are succeeding.</p> <p>While Calva draws a lot of inspiration from CIDER, Cursive, Fireplace, and other Clojure development environments, it does not try to compete with them. Reading r/Clojure and elsewhere, it is easy to get the impression that the most common question is \"Which editor should I use for Clojure development?\u201d. I think a much more common question is \u201dHow do I use my favorite editor for Clojure development?\u201d. For VS Code users, that is where Calva should be a good choice.</p> <p>I also have an ambition to leverage VS Code for easing the path to Clojure. Given that it is the favorite editor for so many developers, it is important to have a good development environment in place on this platform, and to make it as easy to use as we possibly can, while also being productive and something that you want to stick with, once you are hooked on Clojure.</p> <p>That said, and therefore: For people who want to start out with Clojure, and do ask about what development environment would make it the most enjoyable, I'd like for Calva to be a really good option, an option so good that Clojurians feel they can recommend it.</p>","title":"Why Calva?"},{"location":"tao/#design-goals","text":"<p>Calva should be easy to start with and productive enough to stick with. It should support Clojure Best Practices, and be pleasant and enjoyable to use. It should also be easy to hack on, and to contribute to. The ClojureScript story keeps getting more important. Calva should contribute to making the development experience with ClojureScript delightful.</p>","title":"Design Goals"},{"location":"tao/#easy-to-start-with","text":"<p>There are reasons as to why VS Code is so popular. Among those, one stands out to me: It is the most approachable code editor out there. There is nothing you need to learn when you start using it. The editor makes it obvious that you can start typing, deleting, cutting, pasting and undoing, without having to figure anything out. Then you learn how to bring up the command palette and get a boost few other environments can provide with such immediacy.</p> <p>A language extension for VS Code can leverage this, by recognizing that what's old is old, and that what's new should be as easy as possible to pick up. Coming to a new language, people bring with them a lot of expectations from the languages they are used to. This is also true for the editor support. Syntax highlighting and formatting should just work, as should documentation lookup, linting and other IDE commodities.</p> <p>Clojure brings some new concepts to the table. Chief among these: The REPL. It does take some time to grasp it. Calva needs to remove any obstacles it can when it comes to helping the user to reach the REPL, in order to help getting it, and start loving it.</p> <p>To help the users to quickly focus on Clojure, we provide a package that is all-inclusive, with few knobs to turn, and with sane defaults for the knobs that still need to be there.</p>","title":"Easy to Start With"},{"location":"tao/#productive-enough-to-stick-with","text":"<p>I think VS Code brings inspiration also when it comes to following up its excellent Getting Started story. You do not have to dig very deep under its surface to find that there is a lot more power to be unleashed. VS Code makes it easy to pick up more features as you get ready for it, and each little piece makes you more productive. To me, only Vim beats VS Code in this game.</p> <p>Most often there should be no contradiction between Easy to Start With and Productive. Quite the contrary. This story is mainly about being feature complete with the most important tools. As beginners start to pick up the first few features, they should be rewarded with finding more productive tools when they go looking for them. The VS Code way is Calva's way.</p>","title":"Productive Enough to Stick With"},{"location":"tao/#pleasant-and-enjoyable","text":"<p>Enjoyable starts with that Calva shouldn't be an experience full of pains. I think Calva is living up to this first bar of enjoyability. The next step is making it delightful!</p> <p>Calva has two main assets it can leverage for being delightful to use: Clojure and VS Code:</p> <p>Clojure is plain wonderful and also has this totally awesome REPL thing. Wherever we can, Calva should use the REPL to make the editor spark and bring joy to the developer.</p> <p>VS Code is a sweet development environment, offering its power in a consistent way across languages. Even if Clojure is very special, most of Calva's features are surfaced in the ways that VS Code encourages. It makes for less to learn for the user, and most often also makes it easier to implement functionality.</p>","title":"Pleasant and Enjoyable"},{"location":"tao/#support-clojure-best-practices","text":"<p>Mainly, I think Stuart Halloway is right about the REPL being best used from inside the files you are editing rather than from the prompt. It doesn't mean that Calva's REPL window should be neglected, but efforts should be directed such that the file editor REPL is our first way to improve the experience. Expect the Calva REPL window to get much less \u201din your face\u201d, than it is today, as the editor REPL gets stronger.</p> <p>Halloway also gives me some peace of mind with his reasoning of keeping a spartan setup. Calva does not need to pack every feature imaginable. If we can get the right features in place, in the right way, the mission is accomplished.</p> <p>Clojure is data centric. Calva should make it easy to examine data and how our code affects it. Today, this is not good enough when it comes to data structures larger than a few elements.</p> <p>Clojure is a LISP. Thus Structural Editing is possible, and TBH, desirable. Calva should support this and encourage it. There is little we can do about Parinfer not playing well with VS Code, but there is Paredit, and Paredit rocks! Calva's Paredit plays in the top league of Paredits, for this reason.</p>","title":"Support Clojure Best Practices"},{"location":"tao/#made-from-the-produce-of-the-orchard","text":"<p>Calva is distilled from CIDER, which in turn is brewed from the products of The Orchard. This makes a lot of Calva's features thin wrappers around cider-nrepl and related middleware. It also should mean that we strive for adding features by thinking \u201dThe Orchard\u201d first. If it lacks what we need, we should assist in providing it there. We need to up this game a bit from where we are today, I think.</p>","title":"Made from the Produce of the Orchard"},{"location":"tao/#leveraging-clojure-lsp","text":"<p>Today, Calva draws a lot of its static power from clojure-lsp. As does a lot of other Clojure tooling out there. The Calva and the clojure-lsp teams work very nicely together, which is something we cherish and should take care to maintain.</p>","title":"Leveraging clojure-lsp"},{"location":"tao/#project-stewardship","text":"<p>Here Calva takes inspiration from many Clojure related projects, and perhaps most so from CIDER,shadow-cljs, and clojure-lsp. Bozhidar Batsov, Thomas Heller, and Eric Dallo all lead their projects with clarity and with gusto. You can feel how they really care about their products and their users. They are there. They listen. They respond. And they relentlessly keep improving their products.</p> <p>So we are there. We listen. We respond. And we keep trying to improve Calva.</p> <p>The Calva team cares deeply about the user experience. That is a major part of why we do this. When implementing a new feature, or changing a feature, Ux is always the first thing on our mind. Personally, to keep that direction I often start with the documentation of the feature. Reading the documentation before implementation reveals a lot about if the Ux design is within the ballpark or not.</p> <p>We have limited time on our hands, however, and we must cut some corners. We can't afford to spend very much time in Ux design. Rather we will use our Ux intuition, iterate the documentation quickly, and be fast to get things out. Then we are responsive in tweaking those things, based on user feedback. This also has impact on general quality at times. We only can do so much QA, and it happens that some releases of Calva cause disruptions in people's workflow because of things we haven't thought of, or not found during our testing. Again, we try to be attentive to feedback and quick to fix. Apologies in advance for any inconveniences caused!</p> <p>A super major part of our love for Ux is that Calva should be serving its users. That's why we treat feedback as a gift, listen intently, and use the feedback as a major ingredient in shaping Calva.</p> <p>Calva develops from user feedback in more direct ways as well. It is quite astonishing how many people have decided to improve on it by hacking it to do some small or big thing differently. That's great! We should make sure Calva is super easy to contribute to. </p> <p>There has been quite a lot of work put into improving the development process. Starting to hack on Calva is just a few steps, taking less than three minutes from cloning to running a dev version in the VS Code debugger. We encourage contributions, from the tiniest typo to whole new features. And we are ready to spend time helping people get their contributions integrated.</p> <p>However, Calva can't be what everyone wants it to be, that would make it useless. It needs direction and aim. And it is we, the Calva Team, who are the stewards. We need to be in charge of what Calva is about, and what it is not about.</p>","title":"Project Stewardship"},{"location":"tao/#the-road-ahead","text":"<p>Tying back to Stuart Halloway, I don't think he means that spartan needs to also mean poor. The products he helps to bring to the market tell another story. VS Code and Clojure brought together has the capacity to create something amazingly rich and luxurious. And I want Calva to tap into that potential.</p> <p>On the Calva journey we will allow ourselves to change our minds about how things work. Calva is not a library. Its an interface between Clojure and human beings. Human beings can adapt. And they will need to enjoy adapting in order to enjoy Calva. \ud83d\ude04</p> <p>By now it should be clear that you can expect Calva to keep evolving, keep being tended and maintained, and keep getting ever more enjoyable to use. Lately we have been improving Calva pretty rapidly. It would be great to keep it up like that, but I think it is good to expect a more humble and sustainable pace.</p> <p>Calva is still quite new. A bit like freshly distilled Calvados. It will need time in those oak barrels to develop its full bouquet of flavors. And time is what we will give it. Our time, our creativity, and our passion.</p>","title":"The Road Ahead"},{"location":"test-runner/","text":"<p>Calva provides commands that make running your Clojure tests easier.</p>  <p>Note</p> <p>Since the test commands utilize cider-nrepl, they only work with Clojure, not ClojureScript. See this issue for more details.</p>","title":"Test Runner"},{"location":"test-runner/#test-commands","text":"Command Shortcut Description     Run All Tests <code>ctrl+alt+c shift+t</code> Runs all tests   Run Failing Tests <code>ctrl+alt+c ctrl+t</code> Runs the tests that failed   Run Tests for Current Namespace <code>ctrl+alt+c t</code> Runs the tests for the current namespace. If not a <code>-test</code> namespace, tests for the current namespace plus its corresponding <code>&lt;current-namespace&gt;-test</code> namespace will be run.   Run Current Test <code>ctrl+alt+c ctrl+alt+t</code> Runs the test at the cursor. This includes a <code>defn</code> with a <code>:test</code> in its metadata, a <code>defn</code> defined in a <code>with-test</code>, and a <code>deftest</code>.   Toggle between implementation and test - Switches the file between implementation and test, prompts to create a new file if not found.","title":"Test Commands"},{"location":"test-runner/#test-on-save","text":"<p>You can enable the Calva setting \"Test on Save\" to have tests for the current namespace run on file save.</p>","title":"Test on Save"},{"location":"test-runner/#vs-code-test-ui","text":"<p>Calva has experimental support for showing test results in VS Code's Test UI. You can enable this support by setting <code>calva.useTestExplorer</code> to <code>true</code>. When you enable this setting, the Testing icon will appear in the Testing tab of VS Code's Activity Bar.</p> <p>With this feature enabled you will be able to browse and run tests directly from the Testing tab.</p> <p>Please join the #calva channel on the Clojurians Slack if you have any feedback on this new feature.</p>","title":"VS Code Test UI"},{"location":"test-runner/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"test-runner/#tests-are-not-found","text":"<p>If you have tests in a test directory separate from your source directory, and those tests are not being found by the test runner, make sure the test directory is included in your paths. This will not be the case by default with a tools.deps (deps.edn) project. If your project is a tools.deps project, you can create an alias in your deps.edn file with <code>:extra-paths</code> that includes <code>\"test\"</code> (or the name of your test directory).</p> <pre><code>{:aliases {:dev {:extra-paths [\"test\"]}}}\n</code></pre> <p>Having added the above to your deps.edn, when you jack-in, choose the <code>:dev</code> alias and the <code>test</code> directory will be added to your paths, which will allow tests located in the directory to be found by the test runner.</p>","title":"Tests Are Not Found"},{"location":"test-runner/#toggle-between-implementation-and-test-command-not-working-as-intended","text":"<p>This feature mostly works with projects that has leiningen style folder structure and makes some assumption about your folder structure and test file names. - It assumes that the test files ends with <code>_test</code> prefix. - It assumes that your implementation files are in <code>src</code> folder and the test files are in <code>test</code> folder.</p> <p>If you are using any non leiningen style folder structure, you may have to add source paths inside <code>.lsp/config.edn</code>.</p>","title":"Toggle between implementation and test command not working as intended"},{"location":"try-first/","text":"<p>You should start with loading the file you are working with. Do this with Load/Evaluate Current File and its Requires/Dependencies, <code>ctrl+alt+c enter</code>.</p> <p>To get a feeling for evaluating code in the editor and get immediate response from the REPL try this:</p> <ul> <li>On a new line, type a <code>comment</code> form and put some code inside it:</li> </ul> <pre><code>(comment\n  (+ (* 2 2)\n      2)\n  (Math/abs -1)\n  (hello \"Calva REPL\")\n  (defn hello [s]\n    (str \"Hello \" s))\n  (range 10)\n  \"I \u2665\ufe0f Clojure\")\n</code></pre> <p>Then:</p> <ol> <li>Place the cursor behind the form <code>(* 2 2)</code> and issue the command Calva: Evaluate Current Form, <code>ctrl+enter</code>.<ul> <li>You should see the result being displayed inline. Press <code>esc</code> to dismiss it.</li> </ul> </li> <li>Now issue the command Evaluate Current Top Level Form (defun), <code>alt+enter</code>.<ul> <li>You should see the whole form <code>(+ (* 2 2) 2)</code> getting highlighted and the result of that expression being displayed inline.</li> </ul> </li> <li>Evaluate each form inside the comment form using the Top Level command.<ul> <li>You should see each one of them evaluated.</li> <li>Evaluating the <code>(hello \"Calva REPL\")</code> form before the <code>(defn hello...</code> form should result in an error/exception. A stacktrace is then printed in the output window</li> <li>Try it again after having evaluated the <code>defn</code>form.</li> </ul> </li> </ol> <p>Demo:</p> <p></p>","title":"Something to Try First (After Connecting)"},{"location":"try-first/#how-does-this-work","text":"<p>Calva has this notion about the current form. Issue the Evaluate Current Form command, with the cursor placed in different locations to get a feeling for how the current form is determined.</p> <p>There is also a concept about the current top level form. Good for evaluating  various <code>def</code>s <code>defn</code>, <code>defthis</code>, <code>defthat</code>. With your cursor placed anywhere inside such a form.</p> <p>The Top Level command also works inside <code>(comment ...)</code> forms, treating the <code>comment</code> as creating a new top level context. It is good for in-file code experimentation.</p>","title":"How does this work?"},{"location":"try-first/#see-also","text":"<ul> <li>Calva Top 10 Commands.</li> <li>Code Evaluation Tips</li> </ul>","title":"See also"},{"location":"vim/","text":"<p>First thing first. The VIM Extension and Calva has some friction between them. The alternative VSCode Neovim extension may fare a bit better as it unbinds keystrokes from VS Code while not in insert mode and uses Neovim as a backend.</p>","title":"Calva and the VIM Extension"},{"location":"vim/#selection-commands","text":"<p>Calva's various structural selection commands do not put VIM into VISUAL mode. This is true for many VS Code selection scenarios too, so it is not really Calva's fault, but it will be problematic for VIM Extension Calva users, regardless.</p>","title":"Selection commands"},{"location":"vim/#key-bindings","text":"<p>In general Calva's default key bindings are not very VI-ish.</p> <p>You can add these keybindings to your <code>init.vim</code> if you are using the VSCode Neovim extension. It is inspired by and tries to emulate the keybindings found in vim-fireplace which is the most popular vim plugin for Clojure.</p> <pre><code>nmap cqp :call VSCodeNotify('calva.jackIn')&lt;CR&gt;\nnmap cqq :call VSCodeNotify('calva.disconnect')&lt;CR&gt;\nnmap cpr :call VSCodeNotify('calva.loadFile')&lt;CR&gt;\nnmap cpR :call VSCodeNotify('calva.loadNamespace')&lt;CR&gt;\nnmap cpp :call VSCodeNotify('calva.evaluateSelection')&lt;CR&gt;\nnmap cqc :call VSCodeNotify('calva.evalCurrentFormInREPLWindow')&lt;CR&gt;\n</code></pre> <p>Unfortunately these key combinations will not work in the normal VIM extension as <code>c</code> is an operator key and cannot be remapped. This is a call for someone to share their VIM re-mappings.</p>","title":"Key bindings"},{"location":"vim/#expand-selection","text":"<p>Calva binds expand selection to <code>ctrl+w</code> (<code>shift+alt+right</code> on Windows and Linux). This conflicts with the VIM Extension's default mapping of window splitting shortcuts. You'll need to remap it either with Calva or with the VIM Extension.</p>","title":"Expand selection"},{"location":"vim/#the-esc-key","text":"<p>Calva binds the <code>esc</code> key to dismiss the display of inline results. This gets into conflict with any <code>vi</code> coding since <code>esc</code> then is used to go back to command mode. You can either change Calva's default keybinding or the VIM extension's.</p> <p>Alternatively, you can use the native Vim command <code>Ctrl + [</code> to escape and get back to command mode. Rebinding your keyboard's CapsLock key to Control may make this even easier.</p>","title":"The <code>esc</code> key"},{"location":"vim/#remap-calvas-clearinlineresults","text":"<ul> <li>Open the Keyboard Shortcuts JSON file from the Command Palette</li> <li>Disable <code>clearInlineResults</code> and remap the command e.g.</li> </ul> <pre><code>// Place your key bindings in this file to override the defaults\n[\n  {\n    \"key\": \"escape\",\n    \"command\": \"-calva.clearInlineResults\"\n  },\n  {\n    \"key\": \"shift+escape\",\n    \"command\": \"calva.clearInlineResults\",\n    \"when\": \"editorTextFocus &amp;&amp; !editorHasMultipleSelections &amp;&amp; !editorReadOnly &amp;&amp; !hasOtherSuggestions &amp;&amp; !suggestWidgetVisible &amp;&amp; editorLangId == 'clojure'\"\n  }\n]\n</code></pre> <p>If you run into issues, refer to the commands in the default Keyboard Shortcuts JSON file.</p>","title":"Remap Calva's <code>clearInlineResults</code>"},{"location":"vim/#remap-vims-insert-mode","text":"<p>Remap vim's insert mode keybinding to go into command mode by adding the following to your user settings:</p> <pre><code>\"vim.insertModeKeyBindings\": [\n    {\n        \"before\": [\"j\", \"k\"],\n        \"after\": [\"&lt;esc&gt;\"]\n    }\n]\n</code></pre> <p>(Change <code>before</code> to whatever keybinding you are comfortable with!)</p>","title":"Remap Vim's Insert Mode"},{"location":"why-calva/","text":"<p>The main reason you would choose Calva for your Clojure and/or ClojureScript coding is that you want to use Visual Studio Code. Calva provides VS Code users with a comprehensive set of features to keep you productive and make it easy to follow Clojure coding best practices. This also means that if your choice of editor is not made yet, we think you should give VS Code and Calva a try.</p> <p>While Calva is a good choice for professional and experienced Clojure developers, great care has been taken in making Calva a really good choice for beginners of Clojure as well.</p> <p>We who make Calva are actively stewarding, maintaining, documenting and supporting it. We are also very active Clojure (and Calva) users, participating in the community. Clojure is dear to us, a lot because it keeps programming fun and rewarding.</p> <p>Calva has very happy users! Check out the Programming Languages section on the Visual Studio Code Marketplace, sorted by rating:</p> <p></p> <p>Recently there was a thread over at ClojureVerse, asking about how Calva Compares to Emacs with CIDER. It is well worth reading. We would like to highlight the answer by Nick Cernis, which focuses on Calva. We'll even quote parts of it. \ud83d\ude0d</p>","title":"Why Calva?"},{"location":"why-calva/#nick-cernis-on-clojureverse","text":"<p>My advice to anyone starting their Clojure journey who is unsure about what editor to use:</p> <ul> <li>Pick something today and start writing Clojure.</li> <li>Probably pick an editor you are familiar with already.</li> <li>If you\u2019re not familiar with any editor yet or you don\u2019t have a strong allegiance to one, choose VS Code and Calva.</li> <li>Switch to something else only if you encounter persistent annoyances that you can\u2019t remove with plugins, code/config changes, help from the community, or more sleep.</li> </ul> <p>I now use VS Code with Calva every day but went through a long journey trying almost every other editor and plugin combo first. I switched from Emacs to VS Code, which might make my perspective different to others here.</p> <p>\u2026</p> <p>I started with the jaded assumption that VS Code was probably bad because it's built by committee at Microsoft on a web-tech based Electron stack, only to find that it succeeds in embodying the spirit of a \u201chacker's editor\u201d more than even Emacs does in many ways: </p> <p>\u2026</p> <p>On the benefits of Calva:</p> <ul> <li> <p>Of all the amazing Clojure community projects, Calva seems most likely to encourage new users to try Clojure and ClojureScript. A lot of developers use VS Code. It\u2019s been tricky to convince frontend developer friends to try ClojureScript, but at least they don\u2019t have the excuse that they\u2019ll need to switch editors to even try it now. I think as a community we should try to support the projects that encourage Clojure\u2019s adoption and ease of use, including by using those products ourselves.</p> </li> <li> <p>Calva provides a better first-time experience than any other editor/plugin combo whether you\u2019re new to Clojure or not. You can install the plugin and be chatting with your REPL in under a minute without any knowledge of Elisp or VimScript/Lua or how to configure Run Configurations in IntelliJ.</p> </li> <li>The default key bindings are good and the commands are easily discoverable.</li> <li>For its age it\u2019s surprisingly feature rich.</li> </ul>","title":"Nick Cernis on ClojureVerse"},{"location":"why-calva/#100-five-star-marketplace-reviews","text":"<p>We are super proud of the Calva reviews on the Visual Studio Code Marketplace. Please read them all. \ud83d\ude04 Here's a selection that we think captures what we focus on in when developing Calva:</p>  <p>\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f Calva has become an essential part of my Clojure workflow.</p> <p>It's an incredible piece of work by the team behind it.</p> <p>Sean Corfield</p>    <p>\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f Calva hits the sweet spot of being both approachable for new users and powerful for seasoned ones.</p> <p>The creators/maintainers are fantastic individuals that care deeply about streamlining the user experience, and it shows.</p> <p>Good stuff, check it out.</p> <p>Clay Hopperdietzel</p>    <p>\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f I switched from IntelliJ / Cursive to VS Code and Calva and it's been amazing.</p> <p>...</p> <p>That is the biggest thing I can say for Calva, it just works. I was never a fan of VS Code before, but VS Code + Calva for Clojure is now my favorite language / IDE experience.</p> <p>Plus, the #calva on the clojurians slack is brilliant, always someone there to help if you have issues (although any issue I've had has been squarely on me, and never Calva itself).</p> <p>I often feel we live in an age where so much software is badly written, without care, slow, buggy and just generally awful. Calva is the complete opposite. I think the maintainers want to, and have, made a wonderful piece of software for Clojure developers.</p> <p>Stuart Stein</p>    <p>\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f This is great, and makes VS Code a truly viable IDE/editor for clojure development.</p> <p>It already has great REPL support (including inline evaluation), an extensive Paredit implementation, and excellent linting (care of the bundled clj-kondo). Calva is being improved on at an impressive clip by maintainers who appear solidly committed to its ongoing development. It's well-documented, and manages to be both approachable and capable.</p> <p>A no-brainer if you're already a VS Code user, and well worth a look if you're not.</p> <p>Crispin Bennett</p>    <p>\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f\u2605\ufe0f\ufe0f\ufe0f\ufe0f\ufe0f I'm using Calva now for a few months and I'm loving it.</p> <p>I joined the Slack channel about 2 wks ago and I must say that I'm very impressed by how active and responsive this community is. Already 2 of my issues fixed and I really like Calva (and the extensions it uses!).</p> <p>These are professional people and they make me very happy!</p> <p>Uitbeijerse, E (Eric)</p>","title":"100% Five-star Marketplace Reviews"},{"location":"workspace-layouts/","text":"<p>Project directory layouts can vary quite a lot. From the \u201dtemplate\u201d projects where the Clojure project files are at the root, to, well, let's just say that the project files are not always at the root. And sometimes there is more than one project.</p> <p>Calva only really supports working with one project at a time per VS Code window. Here's a short guide for some different setups:</p> <ol> <li>You have one project in the workspace, the project files are in there somewhere.<ul> <li>Use a regular VS Code \u201dfolder window\u201d or a Workspace proper, both will totally work.</li> </ul> </li> <li>You have more than one project in the repository, but only really work with one at a tine.<ul> <li>Use a Workspace proper and add the different project directories as separate Workspace Folders.</li> <li>You can only jack-in/connect to one project at a time.</li> </ul> </li> <li>You have more than one project in the repository, and need to work with them in parallell.<ul> <li>Open each project you want to work with in a separate VS Code window.</li> </ul> </li> </ol>","title":"Workspace Layouts"},{"location":"workspace-layouts/#one-folder-two-windows","text":"<p>As is mentioned in the Calva Jack-In Guide, if you have a full stack project using a Clojure backend and a shadow-cljs frontend, you will need to open the same project in two separate VS Code windows, one for the backend and one for the frontend. This is how you can do that:</p> <ol> <li>Open a new VS Code window.</li> <li>Select File-&gt;Add Folder to Workspace.... Save the workspace as, say, <code>Server.code-workspace</code>.</li> <li>Open a new VS Code window.</li> <li>Select File-&gt;Add Folder to Workspace.... Save the workspace as, say, <code>Client.code-workspace</code>.</li> </ol> <p>Now, whenever you want to Jack-in to the backend and/or frontend, do it from the Server and/or Client workspace, respectively.</p>","title":"One Folder - Two Windows?"},{"location":"wsl/","text":"<p>The use of Calva with WSL (Windows Subsystem for Linux) is fully supported through the Remote - WSL extension. Simply install the extension an open your project with one of the <code>Remote-WSL</code> commands. Calva will run directly in the WSL environment and no further configuration is required.</p>","title":"Calva \u2764\ufe0f WSL"},{"location":"wsl/#steps-involved","text":"<ol> <li>Enable WSL</li> <li>Install Ubuntu in WSL</li> <li>Install Java in WSL</li> <li>Install latest Clojure in WSL</li> <li>Install the Remote - WSL extension in VS Code</li> <li>Launch remote window</li> <li>Install Calva (gets installed into the WSL instance)</li> <li>Work away</li> </ol> <p>See also Remote Development.</p>","title":"Steps Involved"}]}